# 08-演示代码说明

## 一、演示代码概述

演示代码项目位于 `demo-failover-loadbalance` 目录，通过简化的代码演示Eureka故障转移和负载均衡的核心概念。

### 项目结构

```
demo-failover-loadbalance/
├── pom.xml                          # 父POM
├── demo-eureka-server/              # Eureka Server
│   ├── pom.xml
│   └── src/main/
│       ├── java/
│       │   └── com/example/eureka/
│       │       └── DemoEurekaServerApplication.java
│       └── resources/
│           └── application.yml
├── demo-service-provider/           # 服务提供者
│   ├── pom.xml
│   └── src/main/
│       ├── java/
│       │   └── com/example/provider/
│       │       ├── DemoProviderApplication.java
│       │       ├── controller/
│       │       │   └── HelloController.java
│       │       └── config/
│       │           └── HealthCheckConfig.java
│       └── resources/
│           └── application.yml
├── demo-service-consumer/           # 服务消费者
│   ├── pom.xml
│   └── src/main/
│       ├── java/
│       │   └── com/example/consumer/
│       │       ├── DemoConsumerApplication.java
│       │       ├── controller/
│       │       │   └── ConsumerController.java
│       │       ├── config/
│       │       │   └── RibbonConfig.java
│       │       └── rule/
│       │           ├── CustomIpHashRule.java
│       │           ├── CustomWeightedRule.java
│       │           └── CustomGrayReleaseRule.java
│       └── resources/
│           └── application.yml
├── start-demo.sh                    # 启动脚本
├── stop-demo.sh                     # 停止脚本
├── test-failover.sh                 # 故障转移测试脚本
└── README.md                        # 使用说明
```

## 二、演示场景

### 场景1：故障检测与剔除

**目的**：演示Eureka如何检测服务实例故障并剔除

**步骤**：
1. 启动Eureka Server
2. 启动3个Provider实例（端口8081、8082、8083）
3. 观察Eureka控制台，确认3个实例都已注册
4. 手动停止端口8081的实例
5. 观察Eureka Server日志，查看心跳超时和剔除过程
6. 观察Eureka控制台，确认实例被剔除

**关键配置**：
```yaml
eureka:
  instance:
    lease-renewal-interval-in-seconds: 5   # 心跳间隔5秒
    lease-expiration-duration-in-seconds: 15  # 过期时间15秒
  server:
    eviction-interval-timer-in-ms: 5000    # 剔除间隔5秒
```

**预期结果**：
- 实例停止后约15-20秒被剔除
- Eureka控制台不再显示该实例

### 场景2：Ribbon重试机制

**目的**：演示Ribbon在实例故障时的自动重试和切换

**步骤**：
1. 启动Eureka Server和3个Provider实例
2. 启动Consumer实例
3. 通过Consumer调用Provider服务，观察负载均衡
4. 停止其中一个Provider实例
5. 继续调用服务，观察Ribbon自动切换到其他实例
6. 查看Consumer日志，确认重试过程

**关键配置**：
```yaml
ribbon:
  ConnectTimeout: 1000
  ReadTimeout: 3000
  MaxAutoRetries: 0
  MaxAutoRetriesNextServer: 2
```

**预期结果**：
- 请求失败时自动切换到其他实例
- 用户无感知，请求成功返回

### 场景3：负载均衡策略对比

**目的**：演示不同负载均衡策略的效果

**测试策略**：
1. RoundRobinRule（轮询）
2. RandomRule（随机）
3. WeightedResponseTimeRule（响应时间加权）
4. AvailabilityFilteringRule（可用性过滤）

**步骤**：
1. 修改Consumer配置，切换不同策略
2. 发送100个请求
3. 统计每个实例接收的请求数
4. 对比不同策略的分布情况

**测试脚本**：
```bash
# 发送100个请求并统计
for i in {1..100}; do
  curl -s http://localhost:9090/consumer/hello | grep "from instance"
done | sort | uniq -c
```

**预期结果**：
- RoundRobinRule：均匀分布（约33:33:34）
- RandomRule：随机分布（波动较大）
- WeightedResponseTimeRule：性能好的实例接收更多请求

### 场景4：自定义IP Hash策略

**目的**：演示基于客户端IP的会话保持

**步骤**：
1. 配置使用CustomIpHashRule
2. 从同一IP发送多个请求
3. 观察请求总是路由到同一实例
4. 从不同IP发送请求
5. 观察请求路由到不同实例

**关键代码**：
```java
public class CustomIpHashRule extends AbstractLoadBalancerRule {
    @Override
    public Server choose(Object key) {
        String clientIp = getClientIp();
        int hash = Math.abs(clientIp.hashCode());
        int index = hash % servers.size();
        return servers.get(index);
    }
}
```

**预期结果**：
- 同一IP的请求总是路由到同一实例
- 实现会话保持效果

### 场景5：灰度发布

**目的**：演示基于版本的灰度发布

**步骤**：
1. 启动2个稳定版Provider（version=stable）
2. 启动1个灰度版Provider（version=v2.0）
3. 普通请求路由到稳定版
4. 带灰度标识的请求路由到灰度版

**请求示例**：
```bash
# 普通请求 → 稳定版
curl http://localhost:9090/consumer/hello

# 灰度请求 → v2.0版本
curl -H "X-Gray-Version: v2.0" http://localhost:9090/consumer/hello
```

**预期结果**：
- 普通用户访问稳定版
- 灰度用户访问新版本
- 实现A/B测试效果

## 三、快速开始

### 3.1 环境要求

- JDK 1.8
- Maven 3.6+
- 可用端口：8761（Eureka）、8081-8083（Provider）、9090（Consumer）

### 3.2 启动步骤

**方式1：使用脚本启动**

```bash
# 进入演示代码目录
cd demo-failover-loadbalance

# 启动所有服务
./start-demo.sh

# 等待所有服务启动完成（约30秒）
# 访问Eureka控制台：http://localhost:8761
```

**方式2：手动启动**

```bash
# 1. 启动Eureka Server
cd demo-eureka-server
mvn spring-boot:run

# 2. 启动Provider实例1（新终端）
cd demo-service-provider
mvn spring-boot:run -Dspring-boot.run.arguments="--server.port=8081"

# 3. 启动Provider实例2（新终端）
mvn spring-boot:run -Dspring-boot.run.arguments="--server.port=8082"

# 4. 启动Provider实例3（新终端）
mvn spring-boot:run -Dspring-boot.run.arguments="--server.port=8083"

# 5. 启动Consumer（新终端）
cd demo-service-consumer
mvn spring-boot:run
```

### 3.3 验证服务

```bash
# 1. 访问Eureka控制台
open http://localhost:8761

# 2. 测试Provider服务
curl http://localhost:8081/hello
curl http://localhost:8082/hello
curl http://localhost:8083/hello

# 3. 测试Consumer服务（通过Ribbon负载均衡）
curl http://localhost:9090/consumer/hello

# 4. 多次调用观察负载均衡
for i in {1..10}; do curl http://localhost:9090/consumer/hello; echo; done
```

## 四、测试脚本

### 4.1 故障转移测试

```bash
# 运行故障转移测试脚本
./test-failover.sh

# 脚本执行流程：
# 1. 持续发送请求
# 2. 提示手动停止一个Provider实例
# 3. 观察请求是否自动切换到其他实例
# 4. 统计成功率和响应时间
```

### 4.2 负载均衡测试

```bash
# 测试轮询策略
curl http://localhost:9090/consumer/test-round-robin

# 测试随机策略
curl http://localhost:9090/consumer/test-random

# 测试响应时间加权策略
curl http://localhost:9090/consumer/test-weighted

# 查看统计结果
curl http://localhost:9090/consumer/stats
```

### 4.3 自定义策略测试

```bash
# 测试IP Hash策略
curl http://localhost:9090/consumer/test-ip-hash

# 测试权重策略
curl http://localhost:9090/consumer/test-weighted-custom

# 测试灰度发布
curl http://localhost:9090/consumer/hello
curl -H "X-Gray-Version: v2.0" http://localhost:9090/consumer/hello
```

## 五、关键代码说明

### 5.1 自定义健康检查

```java
@Component
public class CustomHealthCheckHandler implements HealthCheckHandler {
    @Override
    public InstanceInfo.InstanceStatus getStatus(InstanceInfo.InstanceStatus currentStatus) {
        // 检查数据库、Redis等依赖
        if (!checkDependencies()) {
            return InstanceInfo.InstanceStatus.DOWN;
        }
        return InstanceInfo.InstanceStatus.UP;
    }
}
```

### 5.2 自定义负载均衡策略

```java
public class CustomIpHashRule extends AbstractLoadBalancerRule {
    @Override
    public Server choose(Object key) {
        List<Server> servers = getLoadBalancer().getReachableServers();
        String clientIp = getClientIp();
        int hash = Math.abs(clientIp.hashCode());
        int index = hash % servers.size();
        return servers.get(index);
    }
}
```

### 5.3 Ribbon配置

```java
@Configuration
public class RibbonConfig {
    @Bean
    public IRule ribbonRule() {
        // 可以切换不同的策略进行测试
        return new RoundRobinRule();
        // return new CustomIpHashRule();
        // return new CustomGrayReleaseRule();
    }
}
```

## 六、常见问题

### Q1: 服务启动后Eureka控制台看不到实例？

**A**: 检查以下几点：
1. Eureka Server是否已启动
2. 配置的`eureka.client.service-url.defaultZone`是否正确
3. 等待30秒左右（注册需要时间）
4. 查看应用日志是否有错误

### Q2: 停止实例后多久会被剔除？

**A**: 根据配置：
- 心跳超时：15秒（lease-expiration-duration-in-seconds）
- 剔除间隔：5秒（eviction-interval-timer-in-ms）
- 总时间：约15-20秒

### Q3: Ribbon重试不生效？

**A**: 检查：
1. 是否配置了`MaxAutoRetriesNextServer > 0`
2. 超时时间是否合理
3. 是否是GET请求（默认只重试GET）
4. 查看日志确认是否有重试记录

### Q4: 负载不均衡？

**A**: 可能原因：
1. 使用了有状态的策略（如IpHashRule）
2. 实例刚启动，权重未收敛（WeightedResponseTimeRule）
3. 缓存未更新
4. 实例数量太少，样本不足

## 七、扩展练习

### 练习1：调整时间参数

修改心跳、剔除、缓存等时间参数，观察对故障转移速度的影响。

### 练习2：实现自定义策略

实现一个基于权重的负载均衡策略，权重从配置文件读取。

### 练习3：添加监控

集成Prometheus，采集负载均衡相关指标。

### 练习4：压力测试

使用JMeter或ab工具进行压力测试，观察高并发下的表现。

### 练习5：故障注入

使用Chaos Monkey或手动方式注入故障，测试系统的容错能力。

## 八、总结

演示代码项目通过简化的实现，帮助你：
1. ✅ 理解Eureka故障检测和剔除机制
2. ✅ 掌握Ribbon重试和负载均衡原理
3. ✅ 学会自定义负载均衡策略
4. ✅ 实践灰度发布等高级特性

**下一步**：学习生产级项目演示，了解完整的生产环境实践。

---

**相关文档**：
- [04-Eureka故障转移机制深度剖析.md](./04-Eureka故障转移机制深度剖析.md)
- [05-Eureka负载均衡策略详解.md](./05-Eureka负载均衡策略详解.md)
- [09-生产级项目演示说明.md](./09-生产级项目演示说明.md)
