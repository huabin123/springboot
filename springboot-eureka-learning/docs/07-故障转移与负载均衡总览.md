# 07-故障转移与负载均衡总览

## 一、文档导航

本系列文档从架构师视角深入剖析Eureka的故障转移机制、负载均衡策略以及生产环境最佳实践。

### 文档列表

1. **[04-Eureka故障转移机制深度剖析.md](./04-Eureka故障转移机制深度剖析.md)**
   - 问题场景分析
   - Eureka故障检测机制（心跳、剔除、自我保护）
   - 客户端缓存机制
   - 故障转移完整流程
   - Ribbon重试机制
   - 故障转移优化策略
   - 监控与告警

2. **[05-Eureka负载均衡策略详解.md](./05-Eureka负载均衡策略详解.md)**
   - Ribbon负载均衡架构
   - 7种内置负载均衡策略详解
   - 自定义负载均衡策略（IP Hash、权重、灰度发布）
   - 策略对比与选择
   - 监控与调优

3. **[06-Eureka生产环境最佳实践.md](./06-Eureka生产环境最佳实践.md)**
   - 高可用架构设计
   - 多机房部署方案
   - 故障转移优化配置
   - 监控与告警体系
   - 安全加固
   - 性能优化
   - 容灾与备份

## 二、核心问题解答

### 2.1 服务实例宕机后，Eureka如何处理？

**问题场景**：
```
1. 服务实例A突然宕机
2. Eureka注册表中仍保留实例A的信息
3. 客户端可能将请求路由到已宕机的实例A
```

**Eureka的处理机制**：

```
时间线：
T0: 服务实例宕机
  ↓
T1: 心跳超时检测（默认90秒）
  - Eureka Server等待心跳
  - 超时后标记为过期
  ↓
T2: 服务剔除（默认60秒间隔）
  - 剔除任务执行
  - 从注册表删除实例
  ↓
T3: Server缓存更新（默认30秒）
  - 只读缓存同步
  ↓
T4: Client缓存更新（默认30秒）
  - Client拉取最新注册表
  ↓
T5: Ribbon缓存更新
  - 停止路由到故障实例

总延迟：最长可达240秒（4分钟）
```

**详细说明**：参见 [04-Eureka故障转移机制深度剖析.md](./04-Eureka故障转移机制深度剖析.md) 第二、三、四章

### 2.2 如何快速故障转移，避免请求失败？

**方案1：优化时间配置**

```yaml
# Eureka Server配置
eureka:
  server:
    eviction-interval-timer-in-ms: 10000  # 剔除间隔10秒
    response-cache-update-interval-ms: 3000  # 缓存更新3秒

# Eureka Client配置
eureka:
  instance:
    lease-renewal-interval-in-seconds: 10  # 心跳间隔10秒
    lease-expiration-duration-in-seconds: 30  # 过期时间30秒
  client:
    registry-fetch-interval-seconds: 10  # 拉取间隔10秒

优化后延迟：约30-60秒
```

**方案2：Ribbon重试机制**

```yaml
ribbon:
  ConnectTimeout: 1000  # 连接超时1秒
  ReadTimeout: 3000  # 读取超时3秒
  MaxAutoRetries: 0  # 同一实例不重试
  MaxAutoRetriesNextServer: 2  # 切换实例重试2次

工作流程：
1. 请求实例A失败（连接超时）
2. 自动切换到实例B重试
3. 实例B成功响应
```

**方案3：Hystrix熔断**

```yaml
hystrix:
  command:
    default:
      circuitBreaker:
        enabled: true
        requestVolumeThreshold: 10  # 10个请求后统计
        errorThresholdPercentage: 50  # 错误率50%触发熔断
        sleepWindowInMilliseconds: 5000  # 熔断5秒后尝试恢复

效果：快速失败，避免请求堆积
```

**详细说明**：参见 [04-Eureka故障转移机制深度剖析.md](./04-Eureka故障转移机制深度剖析.md) 第五、六章

### 2.3 Eureka的负载均衡策略有哪些？

**内置策略对比**：

| 策略 | 算法 | 适用场景 |
|------|------|---------|
| RoundRobinRule | 轮询 | 实例性能相近 |
| RandomRule | 随机 | 简单场景 |
| WeightedResponseTimeRule | 响应时间加权 | 性能差异大 |
| RetryRule | 重试 | 网络不稳定 |
| BestAvailableRule | 最低并发 | 请求时长差异大 |
| AvailabilityFilteringRule | 可用性过滤 | 需要高可用 |
| ZoneAvoidanceRule | 区域避让 | 多机房部署（推荐） |

**选择建议**：

```
生产环境推荐：
1. 单机房：AvailabilityFilteringRule
2. 多机房：ZoneAvoidanceRule（默认）
3. 灰度发布：自定义GrayReleaseRule
4. 会话保持：自定义IpHashRule
```

**详细说明**：参见 [05-Eureka负载均衡策略详解.md](./05-Eureka负载均衡策略详解.md) 第二、三、四章

### 2.4 生产环境最佳实践是什么？

**架构设计**：

```
1. Eureka Server集群
   - 至少3个节点
   - 跨机房部署
   - 互相注册

2. 多Zone部署
   - 配置Zone亲和性
   - 优先访问同Zone实例
   - Zone故障自动切换

3. 高可用配置
   - 开启自我保护
   - 配置健康检查
   - 启用HTTPS和认证
```

**关键配置**：

```yaml
# 生产环境推荐配置
eureka:
  instance:
    lease-renewal-interval-in-seconds: 10
    lease-expiration-duration-in-seconds: 30
  client:
    registry-fetch-interval-seconds: 10
  server:
    enable-self-preservation: true  # 必须开启
    eviction-interval-timer-in-ms: 10000
    response-cache-update-interval-ms: 3000

ribbon:
  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.ZoneAvoidanceRule
  ConnectTimeout: 1000
  ReadTimeout: 3000
  MaxAutoRetriesNextServer: 2

hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 15000
      circuitBreaker:
        enabled: true
```

**监控告警**：

```
关键指标：
1. 注册实例数
2. 心跳成功率
3. 服务调用成功率
4. 响应时间P95/P99
5. 重试次数

告警规则：
1. 实例下线 → CRITICAL
2. 心跳失败率 > 10% → WARNING
3. 调用失败率 > 10% → CRITICAL
4. P95响应时间 > 3s → WARNING
```

**详细说明**：参见 [06-Eureka生产环境最佳实践.md](./06-Eureka生产环境最佳实践.md)

## 三、实战演示项目

### 3.1 演示代码（demo-code）

**目的**：通过简化的代码演示核心概念

**包含内容**：
1. 故障检测演示
2. 重试机制演示
3. 负载均衡策略演示
4. 自定义策略演示

### 3.2 生产级项目（production-demo）

**目的**：完整的生产级实践

**包含内容**：
1. Eureka Server集群（3节点）
2. 多Zone部署
3. 自定义健康检查
4. 监控指标采集
5. 灰度发布演示
6. 故障注入测试
7. 压力测试脚本

## 四、关键技术点总结

### 4.1 故障转移机制

```
核心组件：
1. 心跳机制（Heartbeat）
   - Client → Server：30秒一次
   - 超时判定：90秒

2. 服务剔除（Eviction）
   - 剔除任务：60秒执行一次
   - 剔除条件：租约过期

3. 自我保护（Self Preservation）
   - 触发条件：心跳数 < 期望值 × 85%
   - 保护措施：停止剔除服务

4. 缓存机制
   - Server端：读写缓存 + 只读缓存
   - Client端：本地缓存 + 定期拉取
   - Ribbon端：服务列表缓存

5. 重试机制
   - 同实例重试：MaxAutoRetries
   - 切换实例重试：MaxAutoRetriesNextServer
   - 总请求次数 = (1+MaxAutoRetries) × (1+MaxAutoRetriesNextServer)
```

### 4.2 负载均衡策略

```
策略分类：
1. 简单策略
   - RoundRobinRule：轮询
   - RandomRule：随机

2. 性能优化策略
   - WeightedResponseTimeRule：响应时间加权
   - BestAvailableRule：最低并发

3. 可用性策略
   - AvailabilityFilteringRule：过滤故障实例
   - RetryRule：失败重试

4. 区域策略
   - ZoneAvoidanceRule：区域避让（默认）

5. 自定义策略
   - IpHashRule：IP Hash会话保持
   - WeightedRule：权重分配
   - GrayReleaseRule：灰度发布
```

### 4.3 生产环境要点

```
部署架构：
1. Eureka Server：≥3节点集群
2. 多Zone部署：跨机房容灾
3. HTTPS + 认证：安全加固
4. 监控告警：Prometheus + Grafana

配置优化：
1. 心跳间隔：10秒
2. 租约过期：30秒
3. 剔除间隔：10秒
4. 缓存更新：3秒
5. 拉取间隔：10秒

容错机制：
1. 自我保护：开启
2. 健康检查：自定义
3. 重试策略：切换实例重试
4. 熔断降级：Hystrix

监控指标：
1. 注册实例数
2. 心跳成功率
3. 调用成功率
4. 响应时间
5. 重试次数
```

## 五、学习路径建议

### 5.1 初级（理解原理）

1. 阅读 [04-Eureka故障转移机制深度剖析.md](./04-Eureka故障转移机制深度剖析.md)
   - 理解心跳、剔除、缓存机制
   - 掌握故障转移流程

2. 运行演示代码（demo-code）
   - 观察故障检测过程
   - 体验重试机制

### 5.2 中级（掌握策略）

1. 阅读 [05-Eureka负载均衡策略详解.md](./05-Eureka负载均衡策略详解.md)
   - 理解各种负载均衡策略
   - 学习自定义策略开发

2. 运行演示代码（demo-code）
   - 测试不同负载均衡策略
   - 实现自定义策略

### 5.3 高级（生产实践）

1. 阅读 [06-Eureka生产环境最佳实践.md](./06-Eureka生产环境最佳实践.md)
   - 掌握生产级架构设计
   - 学习监控告警配置

2. 运行生产级项目（production-demo）
   - 部署Eureka Server集群
   - 配置多Zone部署
   - 实施监控告警
   - 进行故障演练

## 六、常见问题FAQ

### Q1: 为什么服务已经宕机了，Eureka还显示UP状态？

**A**: 这是由于Eureka的最终一致性设计导致的延迟：
1. 心跳超时需要90秒（默认）
2. 剔除任务间隔60秒（默认）
3. Server缓存更新30秒（默认）
4. Client缓存更新30秒（默认）

**解决方案**：
- 缩短心跳和剔除时间（参见优化配置）
- 启用健康检查
- 配置Ribbon重试机制

### Q2: 自我保护模式是什么？要不要关闭？

**A**: 自我保护是Eureka的一种容错机制：
- **触发条件**：心跳数 < 期望值 × 85%
- **保护措施**：停止剔除服务实例
- **目的**：防止网络分区导致的大规模误剔除

**建议**：
- ✅ 生产环境：必须开启
- ⚠️ 测试环境：可以关闭
- ❌ 开发环境：可以关闭

### Q3: Ribbon重试会导致重复请求吗？

**A**: 是的，需要注意：
- **默认行为**：只对GET请求重试
- **风险**：POST/PUT/DELETE重试可能导致重复操作
- **配置**：`OkToRetryOnAllOperations=false`（默认）

**建议**：
- GET请求：可以开启重试
- 非幂等操作：不要开启重试
- 幂等操作：可以开启重试

### Q4: 如何选择负载均衡策略？

**A**: 根据场景选择：
- 单机房 + 实例性能相近 → RoundRobinRule
- 单机房 + 性能差异大 → WeightedResponseTimeRule
- 多机房部署 → ZoneAvoidanceRule（推荐）
- 需要会话保持 → 自定义IpHashRule
- 灰度发布 → 自定义GrayReleaseRule

### Q5: Hystrix超时和Ribbon超时如何配置？

**A**: 必须满足关系：
```
Hystrix超时 > Ribbon总超时

Ribbon总超时 = (ConnectTimeout + ReadTimeout) 
             × (MaxAutoRetries + 1) 
             × (MaxAutoRetriesNextServer + 1)

示例：
Ribbon: ConnectTimeout=1s, ReadTimeout=3s, 
        MaxAutoRetries=0, MaxAutoRetriesNextServer=2
Ribbon总超时 = (1+3) × 1 × 3 = 12秒
Hystrix超时应设置为 > 12秒，建议15秒
```

## 七、参考资源

### 官方文档
- [Spring Cloud Netflix](https://spring.io/projects/spring-cloud-netflix)
- [Netflix Eureka Wiki](https://github.com/Netflix/eureka/wiki)
- [Netflix Ribbon Wiki](https://github.com/Netflix/ribbon/wiki)

### 源码仓库
- [Eureka源码](https://github.com/Netflix/eureka)
- [Ribbon源码](https://github.com/Netflix/ribbon)
- [Hystrix源码](https://github.com/Netflix/Hystrix)

### 推荐阅读
- 《Spring Cloud微服务实战》
- 《Spring Cloud与Docker微服务架构实战》
- Martin Fowler - 微服务架构文章

---

**文档版本**：v1.0  
**最后更新**：2026-01-20  
**作者**：架构师视角  
**适用版本**：Spring Cloud Hoxton.SR12 / Spring Boot 2.3.x / JDK 1.8
