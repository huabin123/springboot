# 09-生产级项目演示说明

## 一、项目概述

生产级项目位于 `production-demo` 目录，完整实现了Eureka在生产环境中的最佳实践，包括集群部署、多Zone配置、监控告警、灰度发布等。

### 项目特点

- ✅ Eureka Server三节点集群
- ✅ 多Zone部署（模拟多机房）
- ✅ 完整的健康检查机制
- ✅ Prometheus监控集成
- ✅ 自定义负载均衡策略
- ✅ 灰度发布支持
- ✅ 故障注入测试
- ✅ 压力测试脚本
- ✅ Docker容器化部署

### 项目结构

```
production-demo/
├── pom.xml                                    # 父POM
├── eureka-server-cluster/                     # Eureka Server集群
│   ├── pom.xml
│   └── src/main/
│       ├── java/
│       │   └── com/example/eureka/
│       │       ├── EurekaServerApplication.java
│       │       ├── config/
│       │       │   └── SecurityConfig.java    # 安全配置
│       │       └── monitor/
│       │           └── EurekaServerMetrics.java  # 监控指标
│       └── resources/
│           ├── application.yml                # 公共配置
│           ├── application-peer1.yml          # 节点1配置
│           ├── application-peer2.yml          # 节点2配置
│           ├── application-peer3.yml          # 节点3配置
│           └── logback-spring.xml             # 日志配置
├── service-provider/                          # 服务提供者
│   ├── pom.xml
│   └── src/main/
│       ├── java/
│       │   └── com/example/provider/
│       │       ├── ProviderApplication.java
│       │       ├── controller/
│       │       │   ├── UserController.java
│       │       │   └── HealthController.java
│       │       ├── service/
│       │       │   └── UserService.java
│       │       ├── config/
│       │       │   ├── EurekaConfig.java
│       │       │   └── MetricsConfig.java
│       │       ├── health/
│       │       │   └── CustomHealthCheck.java
│       │       └── monitor/
│       │           └── ServiceMetrics.java
│       └── resources/
│           ├── application.yml
│           ├── application-zone1.yml          # Zone1配置
│           ├── application-zone2.yml          # Zone2配置
│           └── logback-spring.xml
├── service-consumer/                          # 服务消费者
│   ├── pom.xml
│   └── src/main/
│       ├── java/
│       │   └── com/example/consumer/
│       │       ├── ConsumerApplication.java
│       │       ├── controller/
│       │       │   └── ConsumerController.java
│       │       ├── service/
│       │       │   └── UserServiceClient.java
│       │       ├── config/
│       │       │   ├── RibbonConfig.java
│       │       │   ├── HystrixConfig.java
│       │       │   └── FeignConfig.java
│       │       ├── rule/
│       │       │   ├── IpHashRule.java
│       │       │   ├── WeightedRule.java
│       │       │   └── GrayReleaseRule.java
│       │       ├── fallback/
│       │       │   └── UserServiceFallback.java
│       │       └── monitor/
│       │           └── RibbonMetrics.java
│       └── resources/
│           ├── application.yml
│           └── logback-spring.xml
├── monitoring/                                # 监控组件
│   ├── prometheus/
│   │   ├── prometheus.yml                     # Prometheus配置
│   │   └── alerts.yml                         # 告警规则
│   ├── grafana/
│   │   └── dashboards/
│   │       ├── eureka-dashboard.json          # Eureka监控面板
│   │       └── service-dashboard.json         # 服务监控面板
│   └── docker-compose.yml                     # 监控组件Docker编排
├── scripts/                                   # 脚本目录
│   ├── start-cluster.sh                       # 启动集群
│   ├── stop-cluster.sh                        # 停止集群
│   ├── test-failover.sh                       # 故障转移测试
│   ├── test-loadbalance.sh                    # 负载均衡测试
│   ├── test-gray-release.sh                   # 灰度发布测试
│   ├── chaos-test.sh                          # 混沌测试
│   └── performance-test.sh                    # 性能测试
├── docker/                                    # Docker相关
│   ├── Dockerfile-eureka                      # Eureka镜像
│   ├── Dockerfile-provider                    # Provider镜像
│   ├── Dockerfile-consumer                    # Consumer镜像
│   └── docker-compose.yml                     # 完整编排
└── README.md                                  # 使用说明
```

## 二、核心功能

### 2.1 Eureka Server集群

#### 架构设计

```
┌─────────────────────────────────────────────────────────┐
│                  Eureka Server集群                       │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ Eureka-1     │←→│ Eureka-2     │←→│ Eureka-3     │  │
│  │ Zone: zone1  │  │ Zone: zone2  │  │ Zone: zone1  │  │
│  │ Port: 8761   │  │ Port: 8762   │  │ Port: 8763   │  │
│  │ 主节点        │  │ 备节点        │  │ 备节点        │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
│         ↑                 ↑                 ↑            │
│         └─────────────────┴─────────────────┘           │
│                  互相注册，数据同步                       │
└─────────────────────────────────────────────────────────┘
```

#### 关键配置

**节点1（peer1）**：
```yaml
server:
  port: 8761

spring:
  application:
    name: eureka-server
  profiles:
    active: peer1
  security:
    user:
      name: admin
      password: ${EUREKA_PASSWORD:admin123}

eureka:
  instance:
    hostname: eureka-peer1
    prefer-ip-address: false
    metadata-map:
      zone: zone1
      management.port: ${management.server.port:8761}
      
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://admin:admin123@eureka-peer2:8762/eureka/,http://admin:admin123@eureka-peer3:8763/eureka/
    registry-fetch-interval-seconds: 10
    
  server:
    enable-self-preservation: true
    renewal-percent-threshold: 0.85
    eviction-interval-timer-in-ms: 10000
    response-cache-update-interval-ms: 3000
    use-read-only-response-cache: true
    
management:
  endpoints:
    web:
      exposure:
        include: '*'
  metrics:
    export:
      prometheus:
        enabled: true
```

### 2.2 多Zone部署

#### Zone配置

**Zone1（机房A）**：
```yaml
eureka:
  instance:
    metadata-map:
      zone: zone1
  client:
    prefer-same-zone-eureka: true
    availability-zones:
      region1: zone1,zone2
    region: region1
    service-url:
      zone1: http://eureka-peer1:8761/eureka/,http://eureka-peer3:8763/eureka/
      zone2: http://eureka-peer2:8762/eureka/
```

**Zone2（机房B）**：
```yaml
eureka:
  instance:
    metadata-map:
      zone: zone2
  client:
    prefer-same-zone-eureka: true
    availability-zones:
      region1: zone1,zone2
    region: region1
    service-url:
      zone1: http://eureka-peer1:8761/eureka/,http://eureka-peer3:8763/eureka/
      zone2: http://eureka-peer2:8762/eureka/
```

#### 部署拓扑

```
Zone1（机房A）                    Zone2（机房B）
├─ Eureka-1 (8761)               ├─ Eureka-2 (8762)
├─ Eureka-3 (8763)               │
├─ Provider-1 (8081)             ├─ Provider-3 (8083)
├─ Provider-2 (8082)             ├─ Provider-4 (8084)
└─ Consumer-1 (9091)             └─ Consumer-2 (9092)
```

### 2.3 健康检查机制

#### 自定义健康检查

```java
@Component
public class CustomHealthCheck implements HealthCheckHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(CustomHealthCheck.class);
    
    @Autowired
    private DataSource dataSource;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Override
    public InstanceInfo.InstanceStatus getStatus(InstanceInfo.InstanceStatus currentStatus) {
        // 1. 检查数据库
        if (!checkDatabase()) {
            logger.error("Database health check failed");
            return InstanceInfo.InstanceStatus.DOWN;
        }
        
        // 2. 检查Redis
        if (!checkRedis()) {
            logger.error("Redis health check failed");
            return InstanceInfo.InstanceStatus.DOWN;
        }
        
        // 3. 检查依赖服务
        if (!checkDependentServices()) {
            logger.warn("Dependent service check failed");
            return InstanceInfo.InstanceStatus.OUT_OF_SERVICE;
        }
        
        // 4. 检查系统资源
        if (!checkSystemResources()) {
            logger.warn("System resources check failed");
            return InstanceInfo.InstanceStatus.OUT_OF_SERVICE;
        }
        
        return InstanceInfo.InstanceStatus.UP;
    }
    
    private boolean checkDatabase() {
        try (Connection conn = dataSource.getConnection()) {
            return conn.isValid(3);
        } catch (Exception e) {
            logger.error("Database check error", e);
            return false;
        }
    }
    
    private boolean checkRedis() {
        try {
            redisTemplate.opsForValue().get("health_check_key");
            return true;
        } catch (Exception e) {
            logger.error("Redis check error", e);
            return false;
        }
    }
    
    private boolean checkDependentServices() {
        try {
            // 检查关键依赖服务是否可用
            ResponseEntity<String> response = restTemplate.getForEntity(
                "http://dependent-service/health", String.class);
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            logger.error("Dependent service check error", e);
            return false;
        }
    }
    
    private boolean checkSystemResources() {
        // 检查磁盘空间
        File root = new File("/");
        long usableSpace = root.getUsableSpace();
        long totalSpace = root.getTotalSpace();
        double diskUsage = (1 - (double) usableSpace / totalSpace) * 100;
        
        if (diskUsage > 90) {
            logger.warn("Disk usage too high: {}%", diskUsage);
            return false;
        }
        
        // 检查内存使用
        Runtime runtime = Runtime.getRuntime();
        long maxMemory = runtime.maxMemory();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        double memoryUsage = (double) usedMemory / maxMemory * 100;
        
        if (memoryUsage > 85) {
            logger.warn("Memory usage too high: {}%", memoryUsage);
            return false;
        }
        
        return true;
    }
}
```

### 2.4 监控指标采集

#### Prometheus集成

```java
@Component
public class ServiceMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter requestCounter;
    private final Timer requestTimer;
    private final Gauge instanceGauge;
    
    public ServiceMetrics(MeterRegistry meterRegistry, EurekaClient eurekaClient) {
        this.meterRegistry = meterRegistry;
        
        // 请求计数器
        this.requestCounter = Counter.builder("service.requests.total")
            .description("Total number of requests")
            .tag("service", "user-service")
            .register(meterRegistry);
        
        // 请求耗时
        this.requestTimer = Timer.builder("service.requests.duration")
            .description("Request duration")
            .tag("service", "user-service")
            .register(meterRegistry);
        
        // 实例数量
        this.instanceGauge = Gauge.builder("eureka.instances.count", this,
            metrics -> getInstanceCount(eurekaClient))
            .description("Number of registered instances")
            .register(meterRegistry);
    }
    
    private int getInstanceCount(EurekaClient eurekaClient) {
        Application application = eurekaClient.getApplication("user-service");
        return application != null ? application.getInstances().size() : 0;
    }
    
    public void recordRequest(String endpoint, boolean success, long duration) {
        requestCounter.increment();
        requestTimer.record(duration, TimeUnit.MILLISECONDS);
        
        meterRegistry.counter("service.requests.by.endpoint",
            "endpoint", endpoint,
            "success", String.valueOf(success))
            .increment();
    }
}
```

#### 监控指标

```yaml
# Prometheus采集的指标
metrics:
  # Eureka Server指标
  - eureka_registered_instances_total      # 注册实例总数
  - eureka_available_instances_total       # 可用实例总数
  - eureka_heartbeat_failures_total        # 心跳失败次数
  - eureka_registry_size_bytes             # 注册表大小
  
  # 服务调用指标
  - service_requests_total                 # 请求总数
  - service_requests_duration_seconds      # 请求耗时
  - service_requests_by_endpoint_total     # 按端点统计
  
  # Ribbon指标
  - ribbon_requests_total                  # Ribbon请求总数
  - ribbon_requests_active                 # 活跃请求数
  - ribbon_server_list_size                # 服务列表大小
  - ribbon_retry_count_total               # 重试次数
  
  # Hystrix指标
  - hystrix_circuit_breaker_open           # 熔断器状态
  - hystrix_command_total                  # 命令执行次数
  - hystrix_command_duration_seconds       # 命令执行耗时
```

### 2.5 灰度发布

#### 灰度策略实现

```java
@Component
public class GrayReleaseRule extends AbstractLoadBalancerRule {
    
    private static final String GRAY_VERSION_HEADER = "X-Gray-Version";
    private static final String GRAY_USER_HEADER = "X-Gray-User";
    private static final String METADATA_VERSION_KEY = "version";
    
    @Autowired
    private GrayReleaseConfig grayConfig;
    
    @Override
    public Server choose(Object key) {
        List<Server> servers = getLoadBalancer().getReachableServers();
        if (servers.isEmpty()) {
            return null;
        }
        
        // 获取灰度标识
        String grayVersion = getGrayVersion();
        String grayUser = getGrayUser();
        
        // 判断是否为灰度用户
        if (isGrayUser(grayVersion, grayUser)) {
            List<Server> grayServers = filterServersByVersion(servers, grayVersion);
            if (!grayServers.isEmpty()) {
                return chooseFromServers(grayServers);
            }
        }
        
        // 非灰度用户或灰度实例不可用，路由到稳定版
        List<Server> stableServers = filterStableServers(servers);
        return chooseFromServers(stableServers);
    }
    
    private boolean isGrayUser(String grayVersion, String grayUser) {
        if (grayVersion != null) {
            return true;  // 明确指定版本
        }
        
        if (grayUser != null) {
            // 检查用户是否在灰度白名单中
            return grayConfig.getGrayUsers().contains(grayUser);
        }
        
        // 按百分比灰度
        if (grayConfig.getGrayPercentage() > 0) {
            int hash = Math.abs(getRequestId().hashCode());
            return (hash % 100) < grayConfig.getGrayPercentage();
        }
        
        return false;
    }
    
    private List<Server> filterServersByVersion(List<Server> servers, String version) {
        return servers.stream()
            .filter(server -> {
                if (server instanceof DiscoveryEnabledServer) {
                    DiscoveryEnabledServer discoveryServer = (DiscoveryEnabledServer) server;
                    String serverVersion = discoveryServer.getInstanceInfo()
                        .getMetadata().get(METADATA_VERSION_KEY);
                    return version.equals(serverVersion);
                }
                return false;
            })
            .collect(Collectors.toList());
    }
    
    private Server chooseFromServers(List<Server> servers) {
        if (servers.isEmpty()) {
            return null;
        }
        // 使用轮询策略
        int index = new AtomicInteger(0).getAndIncrement() % servers.size();
        return servers.get(index);
    }
}
```

#### 灰度配置

```yaml
gray:
  release:
    enabled: true
    # 灰度版本
    version: v2.0
    # 灰度百分比（0-100）
    percentage: 10
    # 灰度用户白名单
    users:
      - user001
      - user002
      - user003
```

## 三、部署与运行

### 3.1 本地部署

#### 方式1：使用脚本

```bash
# 1. 进入项目目录
cd production-demo

# 2. 编译项目
mvn clean package -DskipTests

# 3. 启动集群
./scripts/start-cluster.sh

# 4. 等待所有服务启动（约60秒）
# 查看启动日志
tail -f logs/*.log

# 5. 验证服务
./scripts/verify-cluster.sh
```

#### 方式2：手动启动

```bash
# 1. 启动Eureka Server集群
cd eureka-server-cluster
mvn spring-boot:run -Dspring-boot.run.profiles=peer1 &
mvn spring-boot:run -Dspring-boot.run.profiles=peer2 &
mvn spring-boot:run -Dspring-boot.run.profiles=peer3 &

# 2. 启动Provider实例（Zone1）
cd service-provider
mvn spring-boot:run -Dspring-boot.run.profiles=zone1 -Dserver.port=8081 &
mvn spring-boot:run -Dspring-boot.run.profiles=zone1 -Dserver.port=8082 &

# 3. 启动Provider实例（Zone2）
mvn spring-boot:run -Dspring-boot.run.profiles=zone2 -Dserver.port=8083 &
mvn spring-boot:run -Dspring-boot.run.profiles=zone2 -Dserver.port=8084 &

# 4. 启动Consumer实例
cd service-consumer
mvn spring-boot:run -Dserver.port=9091 &
mvn spring-boot:run -Dserver.port=9092 &
```

### 3.2 Docker部署

```bash
# 1. 构建镜像
cd production-demo
docker-compose build

# 2. 启动服务
docker-compose up -d

# 3. 查看服务状态
docker-compose ps

# 4. 查看日志
docker-compose logs -f

# 5. 停止服务
docker-compose down
```

### 3.3 启动监控

```bash
# 1. 启动Prometheus和Grafana
cd monitoring
docker-compose up -d

# 2. 访问Prometheus
open http://localhost:9090

# 3. 访问Grafana
open http://localhost:3000
# 默认账号：admin/admin

# 4. 导入Dashboard
# 在Grafana中导入 monitoring/grafana/dashboards/*.json
```

## 四、测试场景

### 4.1 故障转移测试

```bash
# 运行故障转移测试
./scripts/test-failover.sh

# 测试流程：
# 1. 持续发送请求到Consumer
# 2. 随机停止一个Provider实例
# 3. 观察请求是否自动切换
# 4. 统计成功率和平均响应时间
# 5. 重启实例，观察恢复过程
```

**预期结果**：
- 实例停止后，请求自动切换到其他实例
- 成功率保持在99%以上
- 平均响应时间增加不超过50%

### 4.2 负载均衡测试

```bash
# 运行负载均衡测试
./scripts/test-loadbalance.sh

# 测试内容：
# 1. 轮询策略测试
# 2. Zone亲和性测试
# 3. 权重分配测试
# 4. IP Hash测试
```

**预期结果**：
- 轮询策略：请求均匀分布
- Zone亲和性：优先访问同Zone实例
- 权重分配：按配置比例分配流量
- IP Hash：同IP请求路由到同一实例

### 4.3 灰度发布测试

```bash
# 运行灰度发布测试
./scripts/test-gray-release.sh

# 测试场景：
# 1. 10%流量灰度
# 2. 白名单用户灰度
# 3. 指定版本访问
```

**预期结果**：
- 普通用户访问稳定版
- 灰度用户访问新版本
- 流量比例符合配置

### 4.4 混沌测试

```bash
# 运行混沌测试
./scripts/chaos-test.sh

# 故障注入：
# 1. 随机停止实例
# 2. 网络延迟注入
# 3. CPU/内存压力
# 4. 磁盘IO压力
```

**预期结果**：
- 系统能够自动恢复
- 服务降级正常工作
- 监控告警及时触发

### 4.5 性能测试

```bash
# 运行性能测试
./scripts/performance-test.sh

# 测试指标：
# 1. QPS（每秒请求数）
# 2. 响应时间（P50/P95/P99）
# 3. 错误率
# 4. 资源使用率
```

**性能基准**：
- QPS：> 1000
- P95响应时间：< 100ms
- 错误率：< 0.1%
- CPU使用率：< 70%

## 五、监控与告警

### 5.1 Grafana Dashboard

#### Eureka监控面板

```
指标：
- 注册实例数趋势
- 可用实例数趋势
- 心跳成功率
- 注册表大小
- 自我保护状态
```

#### 服务监控面板

```
指标：
- 请求QPS
- 响应时间分布
- 错误率
- 重试次数
- 熔断器状态
```

### 5.2 告警规则

```yaml
# Prometheus告警规则
groups:
  - name: eureka_critical
    rules:
      - alert: EurekaInstanceDown
        expr: eureka_available_instances_total < eureka_registered_instances_total
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Eureka实例下线"
          
      - alert: ServiceHighErrorRate
        expr: |
          sum(rate(service_requests_by_endpoint_total{success="false"}[5m]))
          /
          sum(rate(service_requests_by_endpoint_total[5m]))
          > 0.1
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "服务错误率过高"
```

## 六、最佳实践总结

### 6.1 架构设计

- ✅ Eureka Server至少3节点
- ✅ 跨Zone部署，实现容灾
- ✅ 启用HTTPS和认证
- ✅ 配置合理的超时和重试

### 6.2 配置优化

- ✅ 心跳间隔：10秒
- ✅ 租约过期：30秒
- ✅ 剔除间隔：10秒
- ✅ 缓存更新：3秒
- ✅ 开启自我保护

### 6.3 监控告警

- ✅ 集成Prometheus
- ✅ 配置Grafana面板
- ✅ 设置告警规则
- ✅ 日志集中收集

### 6.4 容错机制

- ✅ 自定义健康检查
- ✅ Ribbon重试策略
- ✅ Hystrix熔断降级
- ✅ 灰度发布支持

---

**相关文档**：
- [06-Eureka生产环境最佳实践.md](./06-Eureka生产环境最佳实践.md)
- [08-演示代码说明.md](./08-演示代码说明.md)
