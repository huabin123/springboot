# Spring长事务优化指南

## 一、什么是长事务

### 1.1 定义

**长事务**：执行时间较长的数据库事务，通常指执行时间超过几秒甚至几十秒的事务。

### 1.2 判断标准

```sql
-- 查询执行时间超过5秒的事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_seconds,
    trx_mysql_thread_id,
    trx_query
FROM information_schema.innodb_trx
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 5
ORDER BY duration_seconds DESC;
```

**时间标准**：
- **短事务**：< 1秒
- **中等事务**：1-5秒
- **长事务**：> 5秒
- **超长事务**：> 30秒

## 二、长事务的危害

### 2.1 锁资源占用时间长

```java
@Transactional(rollbackFor = Exception.class)
public void longTransactionWithLock() {
    // 1. 加锁查询
    Account account = accountMapper.selectByIdForUpdate(1L);
    
    // 2. 复杂业务逻辑（耗时10秒）
    complexBusinessLogic();  // 10秒
    
    // 3. 调用外部API（耗时5秒）
    callExternalApi();  // 5秒
    
    // 4. 更新数据
    accountMapper.updateBalance(1L, account.getBalance());
    
    // 问题：锁被持有了15秒，其他事务都在等待
    // 导致大量请求阻塞，系统吞吐量下降
}
```

**影响**：
- 其他事务长时间等待
- 系统并发能力下降
- 可能导致请求超时

### 2.2 Undo Log膨胀

```java
@Transactional(rollbackFor = Exception.class)
public void longTransactionUndoLog() {
    // 事务开始时间：10:00:00
    
    // 大量更新操作
    for (int i = 0; i < 10000; i++) {
        accountMapper.updateBalance(i, new BigDecimal("1000"));
    }
    
    // 复杂计算（耗时30秒）
    Thread.sleep(30000);
    
    // 事务结束时间：10:00:30
    
    // 问题：
    // 1. 30秒内产生的所有Undo Log都无法清理
    // 2. 其他事务的Undo Log也无法清理（因为需要保持一致性视图）
    // 3. ibdata1文件持续增长
    // 4. 磁盘空间占用增加
}
```

**影响**：
- Undo Log无法及时清理
- 磁盘空间占用增加
- 影响MVCC性能

### 2.3 主从延迟

```java
@Transactional(rollbackFor = Exception.class)
public void longTransactionReplicationDelay() {
    // 主库执行时间：30秒
    for (int i = 0; i < 100000; i++) {
        orderMapper.insert(new Order());
    }
    
    // 问题：
    // 1. 主库事务执行30秒
    // 2. Binlog一次性写入大量数据
    // 3. 从库需要30秒才能完成同步
    // 4. 主从延迟增加到30秒
    
    // 影响：
    // - 读写分离场景下，从库数据严重滞后
    // - 可能读到过期数据
}
```

### 2.4 连接池资源占用

```java
// 连接池配置
spring:
  datasource:
    hikari:
      maximum-pool-size: 10  // 最大10个连接

@Transactional(rollbackFor = Exception.class)
public void longTransactionConnectionPool() {
    // 事务执行30秒
    Thread.sleep(30000);
    
    // 问题：
    // 1. 这个连接被占用30秒
    // 2. 如果有5个这样的长事务，连接池就用了一半
    // 3. 其他请求可能拿不到连接
    // 4. 导致连接池耗尽，系统无法响应
}
```

### 2.5 容易产生死锁

```java
// 事务1（执行时间长）
@Transactional(rollbackFor = Exception.class)
public void longTransaction1() {
    accountMapper.selectByIdForUpdate(1L);  // 锁定账户1
    Thread.sleep(10000);  // 持有锁10秒
    accountMapper.selectByIdForUpdate(2L);  // 尝试锁定账户2
}

// 事务2（执行时间长）
@Transactional(rollbackFor = Exception.class)
public void longTransaction2() {
    accountMapper.selectByIdForUpdate(2L);  // 锁定账户2
    Thread.sleep(10000);  // 持有锁10秒
    accountMapper.selectByIdForUpdate(1L);  // 尝试锁定账户1
}

// 问题：
// 1. 事务持有锁的时间越长，死锁概率越大
// 2. 长事务增加了锁冲突的时间窗口
```

### 2.6 回滚时间长

```java
@Transactional(rollbackFor = Exception.class)
public void longTransactionRollback() {
    // 执行了大量操作
    for (int i = 0; i < 100000; i++) {
        orderMapper.insert(new Order());
    }
    
    // 最后抛出异常
    throw new RuntimeException("业务异常");
    
    // 问题：
    // 1. 需要回滚10万条记录
    // 2. 回滚时间可能长达几分钟
    // 3. 回滚期间锁仍然被持有
    // 4. 严重影响系统性能
}
```

## 三、长事务的识别

### 3.1 SQL查询识别

```sql
-- 1. 查询当前运行的事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_seconds,
    trx_mysql_thread_id,
    trx_query,
    trx_rows_locked,
    trx_rows_modified
FROM information_schema.innodb_trx
ORDER BY trx_started;

-- 2. 查询长时间持有锁的事务
SELECT 
    r.trx_id AS waiting_trx_id,
    r.trx_mysql_thread_id AS waiting_thread,
    r.trx_query AS waiting_query,
    b.trx_id AS blocking_trx_id,
    b.trx_mysql_thread_id AS blocking_thread,
    b.trx_query AS blocking_query,
    TIMESTAMPDIFF(SECOND, b.trx_started, NOW()) AS blocking_duration
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;

-- 3. 查询Undo Log使用情况
SHOW ENGINE INNODB STATUS;
-- 查看 "History list length" 的值
-- 如果这个值很大（如 > 10000），说明有长事务
```

### 3.2 应用日志识别

```java
@Aspect
@Component
@Slf4j
public class TransactionMonitorAspect {
    
    private static final long LONG_TRANSACTION_THRESHOLD = 5000; // 5秒
    
    @Around("@annotation(org.springframework.transaction.annotation.Transactional)")
    public Object monitorTransaction(ProceedingJoinPoint pjp) throws Throwable {
        long startTime = System.currentTimeMillis();
        String methodName = pjp.getSignature().toShortString();
        
        try {
            Object result = pjp.proceed();
            long duration = System.currentTimeMillis() - startTime;
            
            if (duration > LONG_TRANSACTION_THRESHOLD) {
                log.warn("检测到长事务: method={}, duration={}ms", methodName, duration);
                // 可以发送告警
                sendAlert(methodName, duration);
            }
            
            return result;
        } catch (Throwable e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("事务执行失败: method={}, duration={}ms", methodName, duration, e);
            throw e;
        }
    }
    
    private void sendAlert(String methodName, long duration) {
        // 发送告警到监控系统
    }
}
```

### 3.3 监控工具

```yaml
# 1. Spring Boot Actuator
management:
  endpoints:
    web:
      exposure:
        include: metrics,health
  metrics:
    enable:
      jdbc: true

# 2. 使用Prometheus + Grafana监控
# 3. 使用APM工具（如SkyWalking、Pinpoint）
# 4. 数据库监控工具（如Percona Monitoring）
```

## 四、长事务优化方案

### 4.1 缩小事务范围

#### 问题代码

```java
@Transactional(rollbackFor = Exception.class)
public void badExample(Order order) {
    // 1. 数据库操作
    orderMapper.insert(order);
    
    // 2. 调用外部API（耗时5秒）
    String result = externalService.callApi(order);  // ❌ 不应该在事务中
    
    // 3. 复杂计算（耗时3秒）
    BigDecimal amount = calculateComplexAmount(order);  // ❌ 不应该在事务中
    
    // 4. 发送MQ消息（耗时1秒）
    mqService.sendMessage(order);  // ❌ 不应该在事务中
    
    // 5. 更新数据库
    orderMapper.updateAmount(order.getId(), amount);
    
    // 总耗时：9秒以上
}
```

#### 优化方案

```java
public void goodExample(Order order) {
    // 1. 事务外执行：调用外部API
    String result = externalService.callApi(order);
    
    // 2. 事务外执行：复杂计算
    BigDecimal amount = calculateComplexAmount(order);
    
    // 3. 事务内执行：数据库操作
    executeInTransaction(order, amount);
    
    // 4. 事务外执行：发送MQ消息
    mqService.sendMessage(order);
}

@Transactional(rollbackFor = Exception.class)
private void executeInTransaction(Order order, BigDecimal amount) {
    orderMapper.insert(order);
    orderMapper.updateAmount(order.getId(), amount);
    // 事务耗时：< 100ms
}
```

### 4.2 避免在事务中执行耗时操作

#### 不应该在事务中的操作

```java
@Transactional(rollbackFor = Exception.class)
public void badTransactionOperations() {
    // ❌ 1. 调用外部HTTP接口
    restTemplate.getForObject("http://api.example.com/data", String.class);
    
    // ❌ 2. 调用RPC服务
    userService.getUserInfo(userId);
    
    // ❌ 3. 复杂计算
    for (int i = 0; i < 1000000; i++) {
        // 复杂计算
    }
    
    // ❌ 4. 文件IO操作
    Files.readAllLines(Paths.get("/path/to/file"));
    
    // ❌ 5. 发送邮件
    emailService.sendEmail(to, subject, content);
    
    // ❌ 6. Thread.sleep()
    Thread.sleep(5000);
    
    // ❌ 7. 大批量数据处理
    List<Order> orders = orderMapper.selectAll();  // 10万条数据
    orders.forEach(order -> {
        // 处理每条数据
    });
}
```

#### 正确的做法

```java
public void goodTransactionOperations() {
    // 1. 事务外执行耗时操作
    String externalData = restTemplate.getForObject("http://api.example.com/data", String.class);
    User user = userService.getUserInfo(userId);
    BigDecimal result = complexCalculation();
    
    // 2. 事务内只执行数据库操作
    saveToDatabase(externalData, user, result);
}

@Transactional(rollbackFor = Exception.class)
private void saveToDatabase(String data, User user, BigDecimal result) {
    // 只包含数据库操作，执行时间很短
    dataMapper.insert(data);
    userMapper.update(user);
    resultMapper.insert(result);
}
```

### 4.3 拆分大事务

#### 问题代码

```java
@Transactional(rollbackFor = Exception.class)
public void bigTransaction() {
    // 处理10万条订单
    List<Order> orders = orderMapper.selectAll();  // 10万条
    
    for (Order order : orders) {
        // 处理每个订单
        processOrder(order);
        orderMapper.update(order);
    }
    
    // 问题：
    // 1. 事务时间过长
    // 2. 锁定大量数据
    // 3. Undo Log膨胀
    // 4. 回滚代价巨大
}
```

#### 优化方案1：分批处理

```java
public void batchProcessOrders() {
    int pageSize = 1000;
    int pageNum = 0;
    
    while (true) {
        // 分批查询
        List<Order> orders = orderMapper.selectByPage(pageNum * pageSize, pageSize);
        if (orders.isEmpty()) {
            break;
        }
        
        // 每批数据在独立事务中处理
        processBatch(orders);
        
        pageNum++;
    }
}

@Transactional(rollbackFor = Exception.class)
private void processBatch(List<Order> orders) {
    for (Order order : orders) {
        processOrder(order);
        orderMapper.update(order);
    }
    // 每个事务只处理1000条，时间可控
}
```

#### 优化方案2：异步处理

```java
@Service
public class OrderProcessService {
    
    @Autowired
    private ThreadPoolTaskExecutor taskExecutor;
    
    public void asyncProcessOrders() {
        List<Order> orders = orderMapper.selectAll();
        
        // 分批提交到线程池异步处理
        int batchSize = 1000;
        for (int i = 0; i < orders.size(); i += batchSize) {
            int end = Math.min(i + batchSize, orders.size());
            List<Order> batch = orders.subList(i, end);
            
            taskExecutor.submit(() -> processBatch(batch));
        }
    }
    
    @Transactional(rollbackFor = Exception.class)
    private void processBatch(List<Order> orders) {
        orders.forEach(order -> {
            processOrder(order);
            orderMapper.update(order);
        });
    }
}
```

### 4.4 使用编程式事务

#### 场景：部分操作需要事务

```java
@Service
public class OrderService {
    
    @Autowired
    private TransactionTemplate transactionTemplate;
    
    public void processOrder(Order order) {
        // 1. 事务外：调用外部API
        String result = callExternalApi(order);
        
        // 2. 事务内：保存订单
        transactionTemplate.execute(status -> {
            orderMapper.insert(order);
            return null;
        });
        
        // 3. 事务外：发送通知
        sendNotification(order);
        
        // 4. 事务内：更新状态
        transactionTemplate.execute(status -> {
            orderMapper.updateStatus(order.getId(), "COMPLETED");
            return null;
        });
        
        // 优势：精确控制事务边界
    }
}
```

### 4.5 使用事务传播行为

#### REQUIRES_NEW：独立事务

```java
@Service
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    @Transactional(rollbackFor = Exception.class)
    public void processOrder(Order order) {
        // 主业务逻辑
        orderMapper.insert(order);
        
        // 记录日志（使用REQUIRES_NEW，即使主事务回滚，日志也会保存）
        logService.insertLog("ORDER_CREATED", order.getId());
        
        // 如果这里抛异常，订单不会保存，但日志已保存
        if (order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new RuntimeException("金额必须大于0");
        }
    }
}

@Service
public class LogService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)
    public void insertLog(String type, Long orderId) {
        // 在新事务中执行，不受外层事务影响
        TransactionLog log = new TransactionLog();
        log.setOperationType(type);
        log.setOrderId(orderId);
        logMapper.insert(log);
        
        // 这个事务很短，不会影响主事务
    }
}
```

### 4.6 使用消息队列解耦

#### 问题代码

```java
@Transactional(rollbackFor = Exception.class)
public void createOrder(Order order) {
    // 1. 保存订单
    orderMapper.insert(order);
    
    // 2. 扣减库存（调用库存服务）
    inventoryService.deduct(order.getProductId(), order.getQuantity());
    
    // 3. 创建支付单（调用支付服务）
    paymentService.create(order);
    
    // 4. 发送通知（调用通知服务）
    notificationService.send(order);
    
    // 问题：
    // 1. 调用多个外部服务，耗时长
    // 2. 任何一个服务失败，整个事务回滚
    // 3. 服务之间强耦合
}
```

#### 优化方案

```java
@Service
public class OrderService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(Order order) {
        // 1. 保存订单（事务内）
        orderMapper.insert(order);
        
        // 2. 发送MQ消息（事务内）
        OrderCreatedEvent event = new OrderCreatedEvent(order);
        rabbitTemplate.convertAndSend("order.exchange", "order.created", event);
        
        // 事务结束，耗时很短
    }
}

// 消费者1：扣减库存
@Component
public class InventoryConsumer {
    
    @RabbitListener(queues = "inventory.queue")
    @Transactional(rollbackFor = Exception.class)
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 异步扣减库存
        inventoryService.deduct(event.getProductId(), event.getQuantity());
    }
}

// 消费者2：创建支付单
@Component
public class PaymentConsumer {
    
    @RabbitListener(queues = "payment.queue")
    @Transactional(rollbackFor = Exception.class)
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 异步创建支付单
        paymentService.create(event.getOrder());
    }
}

// 优势：
// 1. 主事务很短
// 2. 服务解耦
// 3. 异步处理，提高吞吐量
```

### 4.7 使用只读事务

```java
// 问题代码
@Transactional(rollbackFor = Exception.class)
public List<Order> queryOrders(Long userId) {
    // 只是查询，不需要写操作
    return orderMapper.selectByUserId(userId);
    
    // 问题：
    // 1. 开启了读写事务，占用资源
    // 2. 产生Undo Log
}

// 优化方案
@Transactional(readOnly = true)
public List<Order> queryOrders(Long userId) {
    return orderMapper.selectByUserId(userId);
    
    // 优势：
    // 1. 告诉数据库这是只读事务
    // 2. 数据库可以优化（不加锁、不记录Undo Log）
    // 3. 提高性能
}
```

### 4.8 设置事务超时

```java
// 设置超时时间，防止事务无限期执行
@Transactional(
    rollbackFor = Exception.class,
    timeout = 30  // 30秒超时
)
public void processOrder(Order order) {
    // 如果30秒内没有完成，自动回滚
    orderMapper.insert(order);
    
    // 复杂业务逻辑
    complexBusinessLogic();
}
```

### 4.9 使用乐观锁代替悲观锁

#### 悲观锁（长时间持有锁）

```java
@Transactional(rollbackFor = Exception.class)
public void updateWithPessimisticLock(Long accountId) {
    // 加锁查询
    Account account = accountMapper.selectByIdForUpdate(accountId);
    
    // 复杂业务逻辑（耗时5秒）
    BigDecimal newBalance = complexCalculation(account);
    
    // 更新
    accountMapper.updateBalance(accountId, newBalance);
    
    // 问题：锁被持有5秒，其他事务都在等待
}
```

#### 乐观锁（不持有锁）

```java
@Transactional(rollbackFor = Exception.class)
public void updateWithOptimisticLock(Long accountId) {
    // 不加锁查询
    Account account = accountMapper.selectById(accountId);
    
    // 事务外执行复杂计算
    BigDecimal newBalance = complexCalculation(account);
    
    // 使用版本号更新
    int rows = accountMapper.updateBalanceWithVersion(
        accountId, 
        newBalance, 
        account.getVersion()
    );
    
    if (rows == 0) {
        throw new RuntimeException("数据已被修改，请重试");
    }
    
    // 优势：不持有锁，并发性能好
}
```

## 五、最佳实践

### 5.1 事务设计原则

```java
/**
 * 事务设计的ACID原则
 * 
 * A - As Short As Possible（尽可能短）
 * C - Clear Boundary（边界清晰）
 * I - Isolated Operations（操作隔离）
 * D - Database Only（只包含数据库操作）
 */

// ✅ 好的事务
@Transactional(rollbackFor = Exception.class)
public void goodTransaction() {
    // 1. 只包含数据库操作
    orderMapper.insert(order);
    orderDetailMapper.batchInsert(details);
    
    // 2. 执行时间很短（< 100ms）
    // 3. 边界清晰
    // 4. 不依赖外部服务
}

// ❌ 坏的事务
@Transactional(rollbackFor = Exception.class)
public void badTransaction() {
    // 1. 包含外部调用
    externalService.call();
    
    // 2. 包含复杂计算
    complexCalculation();
    
    // 3. 包含IO操作
    fileService.read();
    
    // 4. 执行时间长（> 5秒）
}
```

### 5.2 代码规范

```java
@Service
public class OrderService {
    
    /**
     * ✅ 推荐：事务方法简短，只包含数据库操作
     */
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(Order order) {
        orderMapper.insert(order);
        orderDetailMapper.batchInsert(order.getDetails());
    }
    
    /**
     * ✅ 推荐：复杂业务逻辑在事务外执行
     */
    public void processOrder(Order order) {
        // 1. 验证（事务外）
        validateOrder(order);
        
        // 2. 计算（事务外）
        BigDecimal amount = calculateAmount(order);
        
        // 3. 保存（事务内）
        saveOrder(order, amount);
        
        // 4. 通知（事务外）
        sendNotification(order);
    }
    
    @Transactional(rollbackFor = Exception.class)
    private void saveOrder(Order order, BigDecimal amount) {
        order.setAmount(amount);
        orderMapper.insert(order);
    }
    
    /**
     * ✅ 推荐：查询使用只读事务
     */
    @Transactional(readOnly = true)
    public List<Order> queryOrders(Long userId) {
        return orderMapper.selectByUserId(userId);
    }
    
    /**
     * ✅ 推荐：设置超时时间
     */
    @Transactional(
        rollbackFor = Exception.class,
        timeout = 30
    )
    public void updateOrder(Order order) {
        orderMapper.update(order);
    }
    
    /**
     * ❌ 不推荐：事务中调用外部服务
     */
    @Transactional(rollbackFor = Exception.class)
    public void badExample(Order order) {
        orderMapper.insert(order);
        externalService.call();  // ❌ 不要这样做
    }
}
```

### 5.3 监控和告警

```java
@Configuration
public class TransactionMonitorConfig {
    
    @Bean
    public TransactionMonitorAspect transactionMonitorAspect() {
        return new TransactionMonitorAspect();
    }
}

@Aspect
@Component
@Slf4j
public class TransactionMonitorAspect {
    
    private static final long WARNING_THRESHOLD = 1000;  // 1秒
    private static final long ERROR_THRESHOLD = 5000;    // 5秒
    
    @Around("@annotation(transactional)")
    public Object monitor(ProceedingJoinPoint pjp, Transactional transactional) throws Throwable {
        long startTime = System.currentTimeMillis();
        String methodName = pjp.getSignature().toShortString();
        
        try {
            Object result = pjp.proceed();
            long duration = System.currentTimeMillis() - startTime;
            
            if (duration > ERROR_THRESHOLD) {
                log.error("检测到超长事务: method={}, duration={}ms", methodName, duration);
                // 发送告警
                alertService.sendAlert("超长事务", methodName, duration);
            } else if (duration > WARNING_THRESHOLD) {
                log.warn("检测到长事务: method={}, duration={}ms", methodName, duration);
            }
            
            // 记录到监控系统
            metricsService.recordTransactionDuration(methodName, duration);
            
            return result;
        } catch (Throwable e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("事务执行失败: method={}, duration={}ms", methodName, duration, e);
            throw e;
        }
    }
}
```

## 六、实际案例

### 案例1：订单创建优化

#### 优化前

```java
@Transactional(rollbackFor = Exception.class)
public void createOrder(OrderDTO dto) {
    // 1. 验证用户（调用用户服务，耗时200ms）
    User user = userService.getUser(dto.getUserId());
    if (user == null) {
        throw new RuntimeException("用户不存在");
    }
    
    // 2. 验证商品（调用商品服务，耗时300ms）
    Product product = productService.getProduct(dto.getProductId());
    if (product.getStock() < dto.getQuantity()) {
        throw new RuntimeException("库存不足");
    }
    
    // 3. 计算价格（复杂计算，耗时500ms）
    BigDecimal amount = calculateAmount(dto);
    
    // 4. 保存订单（数据库操作，耗时50ms）
    Order order = new Order();
    order.setUserId(dto.getUserId());
    order.setAmount(amount);
    orderMapper.insert(order);
    
    // 5. 扣减库存（调用库存服务，耗时400ms）
    inventoryService.deduct(dto.getProductId(), dto.getQuantity());
    
    // 6. 发送通知（调用通知服务，耗时300ms）
    notificationService.send(order);
    
    // 总耗时：1750ms（长事务）
}
```

#### 优化后

```java
public void createOrder(OrderDTO dto) {
    // 1. 验证用户（事务外）
    User user = userService.getUser(dto.getUserId());
    if (user == null) {
        throw new RuntimeException("用户不存在");
    }
    
    // 2. 验证商品（事务外）
    Product product = productService.getProduct(dto.getProductId());
    if (product.getStock() < dto.getQuantity()) {
        throw new RuntimeException("库存不足");
    }
    
    // 3. 计算价格（事务外）
    BigDecimal amount = calculateAmount(dto);
    
    // 4. 保存订单（事务内，耗时50ms）
    Long orderId = saveOrder(dto, amount);
    
    // 5. 异步扣减库存（MQ）
    sendInventoryDeductMessage(dto.getProductId(), dto.getQuantity());
    
    // 6. 异步发送通知（MQ）
    sendNotificationMessage(orderId);
    
    // 总耗时：50ms（短事务）
}

@Transactional(rollbackFor = Exception.class)
private Long saveOrder(OrderDTO dto, BigDecimal amount) {
    Order order = new Order();
    order.setUserId(dto.getUserId());
    order.setAmount(amount);
    orderMapper.insert(order);
    return order.getId();
}
```

### 案例2：批量数据处理优化

#### 优化前

```java
@Transactional(rollbackFor = Exception.class)
public void batchProcess() {
    // 查询所有待处理订单（10万条）
    List<Order> orders = orderMapper.selectAll();
    
    // 处理每个订单
    for (Order order : orders) {
        // 复杂业务逻辑
        processOrder(order);
        
        // 更新订单
        orderMapper.update(order);
    }
    
    // 问题：
    // 1. 事务时间过长（可能几分钟）
    // 2. 锁定大量数据
    // 3. Undo Log膨胀
    // 4. 回滚代价巨大
}
```

#### 优化后

```java
public void batchProcess() {
    int batchSize = 1000;
    int offset = 0;
    
    while (true) {
        // 分批查询
        List<Order> orders = orderMapper.selectByPage(offset, batchSize);
        if (orders.isEmpty()) {
            break;
        }
        
        // 每批在独立事务中处理
        processBatch(orders);
        
        offset += batchSize;
        
        // 可选：添加延迟，避免对数据库造成过大压力
        Thread.sleep(100);
    }
}

@Transactional(rollbackFor = Exception.class)
private void processBatch(List<Order> orders) {
    for (Order order : orders) {
        processOrder(order);
        orderMapper.update(order);
    }
    // 每个事务只处理1000条，时间可控（< 5秒）
}
```

## 七、总结

### 7.1 核心要点

1. **事务要短**
   - 只包含必要的数据库操作
   - 执行时间控制在1秒以内
   - 避免在事务中执行耗时操作

2. **边界要清晰**
   - 明确事务的开始和结束
   - 不要嵌套过深
   - 合理使用事务传播行为

3. **操作要隔离**
   - 外部调用放在事务外
   - 复杂计算放在事务外
   - IO操作放在事务外

4. **监控要到位**
   - 监控事务执行时间
   - 监控长事务数量
   - 及时告警和优化

### 7.2 优化检查清单

- [ ] 事务中是否包含外部服务调用？
- [ ] 事务中是否包含复杂计算？
- [ ] 事务中是否包含文件IO操作？
- [ ] 事务执行时间是否超过1秒？
- [ ] 是否可以拆分为多个小事务？
- [ ] 查询操作是否使用了只读事务？
- [ ] 是否设置了合理的超时时间？
- [ ] 是否使用了乐观锁代替悲观锁？
- [ ] 是否使用了消息队列解耦？
- [ ] 是否有监控和告警机制？

### 7.3 记忆口诀

```
事务要短不要长，
数据库操作放中央，
外部调用移两旁，
复杂计算先思量，
分批异步是良方，
监控告警不能忘。
```
