**好问题！让我详细解释间隙锁的使用场景。**

## 一、间隙锁的使用条件

### 核心规则

**间隙锁（Gap Lock）只在 RR（REPEATABLE READ）隔离级别下使用**

```sql
-- RC隔离级别：不使用间隙锁
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- RR隔离级别：使用间隙锁
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;  -- MySQL默认

-- SERIALIZABLE隔离级别：也使用间隙锁（更严格）
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

## 二、RR隔离级别下产生间隙锁的场景

### 场景1：范围查询（最常见）

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void rangeQueryWithGapLock() {
    // 当前数据：age = 10, 20, 30, 50

    // 范围查询会产生间隙锁
    List<User> users = userMapper.selectByAgeRange(20, 30);

    // 产生的间隙锁：
    // 1. (10, 20] - 临键锁
    // 2. (20, 30] - 临键锁
    // 3. (30, 50) - 间隙锁（Next-Key Lock退化）

    // 被阻塞的操作：
    // INSERT age=15  -- 阻塞（在间隙中）
    // INSERT age=25  -- 阻塞（在间隙中）
    // INSERT age=35  -- 阻塞（在间隙中）
}
```

**SQL示例****：**

```sql
-- 会产生间隙锁
SELECT * FROM user WHERE age BETWEEN 20 AND 30 FOR UPDATE;
SELECT * FROM user WHERE age > 20 FOR UPDATE;
SELECT * FROM user WHERE age < 30 FOR UPDATE;
SELECT * FROM user WHERE age >= 20 AND age <= 30 FOR UPDATE;
```

### 场景2：查询不存在的记录

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void queryNonExistentRecord() {
    // 当前数据：id = 1, 5, 10, 15

    // 查询不存在的记录
    User user = userMapper.selectById(7);  // id=7不存在

    // 产生的间隙锁：
    // (5, 10) - 锁定这个间隙

    // 被阻塞的操作：
    // INSERT id=6  -- 阻塞
    // INSERT id=7  -- 阻塞
    // INSERT id=8  -- 阻塞
    // INSERT id=9  -- 阻塞

    // 不被阻塞的操作：
    // INSERT id=4  -- 成功（不在间隙中）
    // INSERT id=11 -- 成功（不在间隙中）
}
```

**SQL示例****：**

```sql
BEGIN;
-- 查询不存在的记录，产生间隙锁
SELECT * FROM user WHERE id = 7 FOR UPDATE;

-- 其他事务
INSERT INTO user (id, name) VALUES (7, 'test');  -- 阻塞
```

### 场景3：唯一索引的范围查询

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void uniqueIndexRangeQuery() {
    // email是唯一索引
    // 当前数据：email = 'a@test.com', 'c@test.com', 'e@test.com'

    // 范围查询唯一索引
    List<User> users = userMapper.selectByEmailRange("b@test.com", "d@test.com");

    // 产生的间隙锁：
    // ('a@test.com', 'c@test.com'] - 临键锁
    // ('c@test.com', 'e@test.com') - 间隙锁

    // 被阻塞的操作：
    // INSERT email='b@test.com'  -- 阻塞
    // INSERT email='d@test.com'  -- 阻塞
}
```

### 场景4：非唯一索引查询

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void nonUniqueIndexQuery() {
    // age是普通索引（非唯一）
    // 当前数据：age = 10, 20, 20, 30

    // 查询非唯一索引
    List<User> users = userMapper.selectByAge(20);

    // 产生的间隙锁：
    // (10, 20] - 临键锁（锁定第一个20）
    // (20, 20] - 临键锁（锁定第二个20）
    // (20, 30) - 间隙锁

    // 被阻塞的操作：
    // INSERT age=15  -- 阻塞
    // INSERT age=20  -- 阻塞（即使值相同）
    // INSERT age=25  -- 阻塞
}
```

### 场景5：等值查询但记录不存在

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void equalQueryNonExistent() {
    // 当前数据：status = 'PENDING', 'PROCESSING', 'COMPLETED'

    // 查询不存在的状态
    List<Order> orders = orderMapper.selectByStatus("CANCELLED");

    // 产生的间隙锁：
    // 锁定 'CANCELLED' 应该在的间隙
    // 假设 'CANCELLED' < 'COMPLETED'
    // 则锁定 ('PROCESSING', 'COMPLETED') 间隙

    // 被阻塞的操作：
    // INSERT status='CANCELLED'  -- 阻塞
}
```

### 场景6：使用LOCK IN SHARE MODE或FOR UPDATE

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void explicitLock() {
    // 显式加锁会产生间隙锁

    // 1. FOR UPDATE（排他锁）
    List<User> users1 = userMapper.selectByAgeRangeForUpdate(20, 30);
    // 产生间隙锁

    // 2. LOCK IN SHARE MODE（共享锁）
    List<User> users2 = userMapper.selectByAgeRangeForShare(20, 30);
    // 也产生间隙锁
}
```

**SQL示例****：**

```sql
-- 都会产生间隙锁
SELECT * FROM user WHERE age BETWEEN 20 AND 30 FOR UPDATE;
SELECT * FROM user WHERE age BETWEEN 20 AND 30 LOCK IN SHARE MODE;
```

## 三、不会产生间隙锁的场景

### 1. RC隔离级别

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void rcNoGapLock() {
    // RC隔离级别下，任何查询都不会产生间隙锁
    List<User> users = userMapper.selectByAgeRange(20, 30);

    // 只锁定已存在的记录，不锁间隙
    // 其他事务可以自由插入
}
```

### 2. 主键等值查询（记录存在）

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void primaryKeyQuery() {
    // 主键等值查询，且记录存在
    User user = userMapper.selectById(10);  // id=10存在

    // 只产生记录锁，不产生间隙锁
    // 其他事务可以插入id=9或id=11
}
```

### 3. 唯一索引等值查询（记录存在）

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void uniqueIndexQuery() {
    // 唯一索引等值查询，且记录存在
    User user = userMapper.selectByEmail("test@test.com");  // 记录存在

    // 只产生记录锁，不产生间隙锁
}
```

### 4. 普通SELECT（快照读）

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void snapshotRead() {
    // 普通SELECT不加锁，不产生间隙锁
    List<User> users = userMapper.selectByAgeRange(20, 30);

    // 使用MVCC机制，不加任何锁
    // 其他事务可以自由操作
}
```

## 四、间隙锁的实际应用场景

### 场景1：防止幻读

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void preventPhantomRead() {
    // 第一次查询
    List<Order> orders1 = orderMapper.selectByStatus("PENDING");
    log.info("待处理订单数: {}", orders1.size());  // 假设10条

    // 产生间隙锁，防止其他事务插入新的PENDING订单

    // 处理订单...
    for (Order order : orders1) {
        processOrder(order);
    }

    // 第二次查询
    List<Order> orders2 = orderMapper.selectByStatus("PENDING");
    log.info("待处理订单数: {}", orders2.size());  // 仍然是10条

    // 间隙锁保证了两次查询结果一致（防止幻读）
}
```

### 场景2：库存扣减（防止超卖）

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void deductInventory(Long productId, Integer quantity) {
    // 查询库存（产生记录锁）
    Product product = productMapper.selectByIdForUpdate(productId);

    if (product.getStock() >= quantity) {
        // 扣减库存
        productMapper.deductStock(productId, quantity);

        // 如果使用范围查询，会产生间隙锁
        // 防止其他事务插入相同productId的记录
    } else {
        throw new RuntimeException("库存不足");
    }
}
```

### 场景3：订单号生成（防止重复）

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public String generateOrderNo() {
    // 查询今天的最大订单号
    String maxOrderNo = orderMapper.selectMaxOrderNoToday();

    // 产生间隙锁，防止其他事务生成相同的订单号

    // 生成新订单号
    String newOrderNo = generateNext(maxOrderNo);

    // 插入订单
    Order order = new Order();
    order.setOrderNo(newOrderNo);
    orderMapper.insert(order);

    return newOrderNo;
}
```

### 场景4：分布式锁实现

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public boolean tryLock(String lockKey) {
    // 查询锁记录
    DistributedLock lock = lockMapper.selectByKeyForUpdate(lockKey);

    if (lock == null) {
        // 记录不存在，产生间隙锁
        // 防止其他事务插入相同的lockKey

        // 插入锁记录
        lock = new DistributedLock();
        lock.setLockKey(lockKey);
        lock.setExpireTime(System.currentTimeMillis() + 30000);
        lockMapper.insert(lock);

        return true;
    }

    return false;
}
```

## 五、间隙锁的问题和解决方案

### 问题1：降低并发性能

```java
// 问题：间隙锁会阻塞大量插入操作
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void slowConcurrency() {
    // 范围查询产生大量间隙锁
    List<User> users = userMapper.selectByAgeRange(1, 100);

    // 阻塞所有age在1-100之间的插入操作
    // 并发性能很差
}

// 解决方案1：使用RC隔离级别
@Transactional(isolation = Isolation.READ_COMMITTED)
public void betterConcurrency() {
    List<User> users = userMapper.selectByAgeRange(1, 100);
    // 不产生间隙锁，并发性能好
}

// 解决方案2：缩小查询范围
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void smallerRange() {
    // 只查询必要的范围
    List<User> users = userMapper.selectByAgeRange(20, 30);
    // 减少间隙锁的范围
}

// 解决方案3：使用主键查询
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void usePrimaryKey() {
    // 主键查询不产生间隙锁
    User user = userMapper.selectById(10);
}
```

### 问题2：容易产生死锁

```java
// 问题：间隙锁容易导致死锁
// 事务1
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void transaction1() {
    // 锁定 (10, 20) 间隙
    userMapper.selectByAgeRange(10, 20);

    // 尝试插入age=15
    userMapper.insert(new User(15, "user1"));  // 等待事务2
}

// 事务2
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void transaction2() {
    // 锁定 (15, 25) 间隙
    userMapper.selectByAgeRange(15, 25);

    // 尝试插入age=18
    userMapper.insert(new User(18, "user2"));  // 等待事务1
}
// 死锁！

// 解决方案：统一加锁顺序
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void avoidDeadlock() {
    // 始终按照age从小到大的顺序加锁
    userMapper.selectByAgeRange(10, 20);
    userMapper.selectByAgeRange(15, 25);
}
```

## 六、总结表格


| **隔离级别**         | **是否使用间隙锁** | **场景**                       |
| -------------------- | ------------------ | ------------------------------ |
| **READ UNCOMMITTED** | **❌**             | **不使用**                     |
| **READ COMMITTED**   | **❌**             | **不使用**                     |
| **REPEATABLE READ**  | **✅**             | **范围查询、查询不存在的记录** |
| **SERIALIZABLE**     | **✅**             | **所有查询都加锁**             |

### 产生间隙锁的具体场景（RR隔离级别）


| **场景**                          | **是否产生间隙锁** | **示例**                                                                      |
| --------------------------------- | ------------------ | ----------------------------------------------------------------------------- |
| **范围查询 + FOR UPDATE**         | **✅**             | `<span class="ne-text">WHERE age BETWEEN 20 AND 30 FOR UPDATE</span>`         |
| **查询不存在的记录 + FOR UPDATE** | **✅**             | `<span class="ne-text">WHERE id = 999 FOR UPDATE</span>`(id=999不存在)        |
| **非唯一索引查询 + FOR UPDATE**   | **✅**             | `<span class="ne-text">WHERE status = 'PENDING' FOR UPDATE</span>`            |
| **主键等值查询（存在）**          | **❌**             | `<span class="ne-text">WHERE id = 10 FOR UPDATE</span>`(id=10存在)            |
| **唯一索引等值查询（存在）**      | **❌**             | `<span class="ne-text">WHERE email = 'test@test.com' FOR UPDATE</span>`(存在) |
| **普通SELECT（快照读）**          | **❌**             | `<span class="ne-text">SELECT * FROM user WHERE age > 20</span>`              |

**核心记忆点****：**

1. **只有RR和SERIALIZABLE使用间隙锁**
2. **范围查询最容易产生间隙锁**
3. **间隙锁是为了防止幻读**
4. **高并发场景考虑使用RC避免间隙锁**
