# 分布式强一致性事务实现

## 一、快速结论

**核心问题**：
1. 如何在分布式数据库中实现强一致性事务？
2. 事务执行中表能否被读取？

**快速答案**：

| 对比项 | 单机事务 | 分布式事务 |
|-------|---------|----------|
| **实现方式** | MVCC + 锁 | 2PC/3PC/Paxos/Raft |
| **一致性保证** | ACID | 最终一致性 or 强一致性 |
| **事务执行中读取** | 可以（快照读） | 取决于隔离级别和实现方式 |
| **性能** | 高 | 低（网络开销） |
| **复杂度** | 低 | 高 |

**强一致性事务实现方案**：
1. **2PC（两阶段提交）**：最常用，强一致性，性能一般
2. **3PC（三阶段提交）**：改进2PC，减少阻塞
3. **Paxos/Raft**：分布式共识算法，强一致性
4. **Percolator（Google）**：基于时间戳的分布式事务
5. **Spanner（Google）**：TrueTime + 2PC，全球强一致性

**事务执行中表能否被读取**：
- ✅ **可以读取**（快照读）：读取事务开始前的快照
- ⚠️ **阻塞读取**（当前读）：需要等待事务提交或回滚
- 📌 **取决于隔离级别**：READ COMMITTED、REPEATABLE READ、SERIALIZABLE

---

## 二、分布式事务基础

### 2.1 什么是分布式事务？

**定义**：跨越多个数据库节点的事务，需要保证所有节点的操作要么全部成功，要么全部失败。

**示例场景**：

```
场景1：跨库转账
- 用户A在数据库1，余额1000元
- 用户B在数据库2，余额500元
- A转账100元给B

操作：
1. 数据库1：UPDATE account SET balance = balance - 100 WHERE user_id = 'A'
2. 数据库2：UPDATE account SET balance = balance + 100 WHERE user_id = 'B'

要求：两个操作要么都成功，要么都失败
```

```
场景2：订单系统
- 订单服务：创建订单（数据库1）
- 库存服务：扣减库存（数据库2）
- 积分服务：增加积分（数据库3）

要求：三个操作要么都成功，要么都失败
```

---

### 2.2 分布式事务的挑战

```
1. 网络延迟和不可靠
   - 网络分区（Network Partition）
   - 消息丢失
   - 节点故障

2. 一致性保证
   - 如何保证所有节点的数据一致？
   - 如何处理部分节点失败？

3. 性能问题
   - 跨网络通信开销大
   - 锁等待时间长
   - 吞吐量下降

4. 可用性问题
   - 协调者单点故障
   - 节点阻塞
```

---

### 2.3 CAP定理

**CAP定理**：分布式系统最多只能同时满足以下三个特性中的两个。

```
C（Consistency）：一致性
- 所有节点在同一时间看到相同的数据

A（Availability）：可用性
- 每个请求都能得到响应（成功或失败）

P（Partition Tolerance）：分区容错性
- 系统在网络分区的情况下仍能继续工作

CAP定理：
┌─────────────────────────────────┐
│   只能同时满足其中两个特性        │
├─────────────────────────────────┤
│ CP：一致性 + 分区容错性           │
│     - 牺牲可用性                 │
│     - 示例：HBase、MongoDB       │
│                                 │
│ AP：可用性 + 分区容错性           │
│     - 牺牲一致性（最终一致性）    │
│     - 示例：Cassandra、DynamoDB  │
│                                 │
│ CA：一致性 + 可用性               │
│     - 不支持分区容错性            │
│     - 示例：单机数据库（MySQL）   │
└─────────────────────────────────┘

实际选择：
- 网络分区是客观存在的，所以P是必须的
- 因此只能在C和A之间权衡
- 强一致性事务选择CP（牺牲可用性）
```

---

## 三、2PC（两阶段提交）

### 3.1 什么是2PC？

**定义**：最经典的分布式事务协议，分为准备阶段和提交阶段。

**角色**：
- **协调者（Coordinator）**：事务管理器，负责协调所有参与者
- **参与者（Participant）**：资源管理器，执行本地事务

---

### 3.2 2PC的执行流程

```
阶段1：准备阶段（Prepare Phase）
┌────────────┐
│ 协调者      │
│ Coordinator│
└─────┬──────┘
      │
      │ 1. 发送 PREPARE 请求
      ├──────────────────────────────┐
      │                              │
      ▼                              ▼
┌────────────┐                ┌────────────┐
│ 参与者1     │                │ 参与者2     │
│Participant1│                │Participant2│
└────────────┘                └────────────┘
      │                              │
      │ 2. 执行本地事务（不提交）      │
      │ 3. 写入 Undo/Redo 日志        │
      │ 4. 锁定资源                   │
      │                              │
      │ 5. 返回 YES（准备好）或 NO    │
      ├──────────────────────────────┤
      │                              │
      ▼                              ▼
┌────────────┐
│ 协调者      │
│ Coordinator│
└────────────┘


阶段2：提交阶段（Commit Phase）
┌────────────┐
│ 协调者      │
│ Coordinator│
└─────┬──────┘
      │
      │ 6. 判断所有参与者的响应
      │    - 全部YES → 发送 COMMIT
      │    - 任意NO → 发送 ROLLBACK
      │
      ├──────────────────────────────┐
      │                              │
      ▼                              ▼
┌────────────┐                ┌────────────┐
│ 参与者1     │                │ 参与者2     │
│Participant1│                │Participant2│
└────────────┘                └────────────┘
      │                              │
      │ 7. 执行 COMMIT 或 ROLLBACK   │
      │ 8. 释放锁                     │
      │ 9. 返回 ACK                   │
      │                              │
      ├──────────────────────────────┤
      │                              │
      ▼                              ▼
┌────────────┐
│ 协调者      │
│ Coordinator│
│ 10. 事务完成│
└────────────┘
```

---

### 3.3 2PC的详细示例

```sql
-- 场景：跨库转账
-- 数据库1：用户A，余额1000元
-- 数据库2：用户B，余额500元
-- 操作：A转账100元给B

-- 阶段1：准备阶段
-- 协调者发送 PREPARE 请求

-- 参与者1（数据库1）：
START TRANSACTION;
UPDATE account SET balance = balance - 100 WHERE user_id = 'A';
-- 检查余额是否足够
-- 写入 Undo Log（balance = 1000）
-- 锁定行（X锁）
-- 返回 YES

-- 参与者2（数据库2）：
START TRANSACTION;
UPDATE account SET balance = balance + 100 WHERE user_id = 'B';
-- 写入 Undo Log（balance = 500）
-- 锁定行（X锁）
-- 返回 YES

-- 阶段2：提交阶段
-- 协调者收到所有 YES，发送 COMMIT

-- 参与者1（数据库1）：
COMMIT;
-- 释放锁
-- 返回 ACK

-- 参与者2（数据库2）：
COMMIT;
-- 释放锁
-- 返回 ACK

-- 协调者：事务完成
```

---

### 3.4 2PC的优缺点

#### 优点

```
1. ✅ 强一致性
   - 保证所有节点的数据一致
   - 符合ACID特性

2. ✅ 实现相对简单
   - 逻辑清晰
   - 易于理解和实现

3. ✅ 广泛应用
   - XA协议（X/Open DTP标准）
   - JTA（Java Transaction API）
   - 数据库原生支持（MySQL、Oracle等）
```

#### 缺点

```
1. ❌ 同步阻塞
   - 准备阶段，参与者锁定资源
   - 等待协调者的决策
   - 其他事务被阻塞

2. ❌ 单点故障
   - 协调者故障，参与者一直阻塞
   - 参与者不知道是提交还是回滚

3. ❌ 数据不一致（极端情况）
   - 协调者发送COMMIT后崩溃
   - 部分参与者收到COMMIT，部分未收到
   - 导致数据不一致

4. ❌ 性能差
   - 两次网络通信
   - 锁等待时间长
   - 吞吐量低
```

---

### 3.5 2PC的故障处理

```
场景1：参与者故障（准备阶段）
┌────────────┐
│ 协调者      │  PREPARE
└─────┬──────┘ ─────────→ ┌────────────┐
      │                   │ 参与者1     │
      │                   │   ❌ 故障   │
      │                   └────────────┘
      │
      │ 超时或收到 NO
      │ 决策：ROLLBACK
      │
      ├─────────────────→ ┌────────────┐
      │      ROLLBACK     │ 参与者2     │
      │                   │   回滚      │
      └───────────────────└────────────┘

结果：事务回滚，数据一致 ✅


场景2：协调者故障（准备阶段后）
┌────────────┐
│ 协调者      │  PREPARE
│   ❌ 故障   │ ─────────→ ┌────────────┐
└────────────┘             │ 参与者1     │
                           │   等待...   │
                           └────────────┘
                           ┌────────────┐
                           │ 参与者2     │
                           │   等待...   │
                           └────────────┘

问题：参与者一直阻塞，锁定资源 ❌

解决方案：
1. 超时机制：参与者超时后自动回滚
2. 协调者备份：选举新的协调者
3. 持久化日志：新协调者读取日志，继续事务


场景3：协调者故障（提交阶段）
┌────────────┐
│ 协调者      │  COMMIT
│   ❌ 故障   │ ─────────→ ┌────────────┐
└────────────┘             │ 参与者1     │
                           │   已提交 ✅  │
                           └────────────┘
                           ┌────────────┐
                           │ 参与者2     │
                           │   未收到 ❓  │
                           └────────────┘

问题：部分参与者提交，部分未提交 ❌

解决方案：
1. 参与者2查询参与者1的状态
2. 如果参与者1已提交，参与者2也提交
3. 如果参与者1未提交，参与者2回滚
```

---

## 四、3PC（三阶段提交）

### 4.1 什么是3PC？

**定义**：2PC的改进版本，增加了预提交阶段，减少阻塞时间。

**改进点**：
1. 增加超时机制
2. 增加预提交阶段
3. 减少阻塞时间

---

### 4.2 3PC的执行流程

```
阶段1：CanCommit（询问阶段）
┌────────────┐
│ 协调者      │  CanCommit?
└─────┬──────┘ ─────────→ ┌────────────┐
      │                   │ 参与者1     │
      │                   │   YES/NO    │
      │                   └────────────┘
      │                   ┌────────────┐
      │                   │ 参与者2     │
      │                   │   YES/NO    │
      │                   └────────────┘
      │
      │ 收集响应
      │ - 全部YES → 进入阶段2
      │ - 任意NO → 中止事务


阶段2：PreCommit（预提交阶段）
┌────────────┐
│ 协调者      │  PreCommit
└─────┬──────┘ ─────────→ ┌────────────┐
      │                   │ 参与者1     │
      │                   │ 执行事务    │
      │                   │ 写入日志    │
      │                   │ 锁定资源    │
      │                   │   ACK       │
      │                   └────────────┘
      │                   ┌────────────┐
      │                   │ 参与者2     │
      │                   │ 执行事务    │
      │                   │ 写入日志    │
      │                   │ 锁定资源    │
      │                   │   ACK       │
      │                   └────────────┘
      │
      │ 收集ACK
      │ - 全部ACK → 进入阶段3
      │ - 超时/失败 → 中止事务


阶段3：DoCommit（提交阶段）
┌────────────┐
│ 协调者      │  DoCommit
└─────┬──────┘ ─────────→ ┌────────────┐
      │                   │ 参与者1     │
      │                   │   COMMIT    │
      │                   │   释放锁    │
      │                   └────────────┘
      │                   ┌────────────┐
      │                   │ 参与者2     │
      │                   │   COMMIT    │
      │                   │   释放锁    │
      │                   └────────────┘
      │
      │ 事务完成
```

---

### 4.3 3PC vs 2PC

| 对比项 | 2PC | 3PC |
|-------|-----|-----|
| **阶段数** | 2个阶段 | 3个阶段 |
| **超时机制** | ❌ 无 | ✅ 有 |
| **阻塞时间** | 长 | 短 |
| **协调者故障** | 参与者阻塞 | 参与者超时后自动提交 |
| **一致性** | 强一致性 | 可能不一致（网络分区） |
| **性能** | 一般 | 较差（多一次通信） |

**3PC的改进**：
```
1. ✅ 减少阻塞时间
   - 增加CanCommit阶段，提前判断
   - 参与者可以提前知道事务是否可以提交

2. ✅ 超时机制
   - 参与者超时后自动提交（假设其他参与者已提交）
   - 减少阻塞

3. ❌ 可能不一致
   - 网络分区时，参与者可能做出不同的决策
   - 牺牲一致性换取可用性
```

---

## 五、Paxos/Raft（分布式共识算法）

### 5.1 什么是分布式共识？

**定义**：在分布式系统中，多个节点对某个值达成一致的过程。

**应用场景**：
- 分布式数据库的事务提交
- 分布式锁
- 配置管理
- Leader选举

---

### 5.2 Raft算法简介

**Raft**：一种易于理解的分布式共识算法，比Paxos更简单。

**核心概念**：
1. **Leader**：领导者，负责处理所有客户端请求
2. **Follower**：跟随者，被动接收Leader的日志
3. **Candidate**：候选人，Leader选举时的临时角色

**Raft的三个子问题**：
1. **Leader选举**：如何选出Leader
2. **日志复制**：如何将日志复制到所有节点
3. **安全性**：如何保证一致性

---

### 5.3 Raft的日志复制流程

```
1. 客户端请求
   Client ─────→ Leader: SET x = 5

2. Leader写入本地日志
   Leader: [SET x = 5] (未提交)

3. Leader复制日志到Follower
   Leader ─────→ Follower1: [SET x = 5]
   Leader ─────→ Follower2: [SET x = 5]

4. Follower写入本地日志并返回ACK
   Follower1 ─────→ Leader: ACK
   Follower2 ─────→ Leader: ACK

5. Leader收到多数派ACK，提交日志
   Leader: [SET x = 5] (已提交)

6. Leader通知Follower提交
   Leader ─────→ Follower1: Commit
   Leader ─────→ Follower2: Commit

7. Leader返回客户端
   Leader ─────→ Client: Success

关键点：
- 多数派原则：超过半数节点ACK即可提交
- 强一致性：所有节点最终达成一致
- 容错性：少数节点故障不影响系统
```

---

### 5.4 Raft在分布式事务中的应用

```sql
-- 场景：分布式数据库（TiDB）

-- 1. 客户端发起事务
BEGIN;
UPDATE account SET balance = balance - 100 WHERE user_id = 'A';
UPDATE account SET balance = balance + 100 WHERE user_id = 'B';
COMMIT;

-- 2. Leader节点处理事务
-- 2.1 写入本地日志
-- 2.2 复制日志到Follower节点

-- 3. Follower节点
-- 3.1 接收日志
-- 3.2 写入本地日志
-- 3.3 返回ACK

-- 4. Leader节点
-- 4.1 收到多数派ACK
-- 4.2 提交事务
-- 4.3 通知Follower提交

-- 5. 所有节点
-- 5.1 应用事务
-- 5.2 更新数据

-- 结果：强一致性 ✅
```

---

## 六、Percolator（Google）

### 6.1 什么是Percolator？

**定义**：Google开发的分布式事务模型，基于BigTable，使用时间戳实现MVCC。

**核心思想**：
- 使用时间戳版本控制
- 乐观锁机制
- 两阶段提交的变种

---

### 6.2 Percolator的事务模型

```
数据结构：
每个数据项有3列：
1. data:     实际数据
2. lock:     锁信息
3. write:    写入信息（时间戳）

示例：
Key: account:A
┌──────────┬────────┬───────────┬──────────────┐
│ Timestamp│  data  │   lock    │    write     │
├──────────┼────────┼───────────┼──────────────┤
│   100    │  1000  │           │  committed   │
│   200    │  900   │  tx_200   │              │
│   300    │        │           │  committed   │
└──────────┴────────┴───────────┴──────────────┘

解释：
- 时间戳100：余额1000，已提交
- 时间戳200：余额900，事务200正在执行（有锁）
- 时间戳300：事务300已提交
```

---

### 6.3 Percolator的事务流程

```
阶段1：Prewrite（预写阶段）
1. 选择一个Primary Key（主键）
2. 对所有要修改的Key加锁
3. 写入数据到data列
4. 写入锁信息到lock列

示例：
-- 转账：A转100给B
-- Primary Key: account:A

-- 1. Prewrite account:A
Key: account:A, Timestamp: 200
data: 900
lock: primary, tx_200
write: (空)

-- 2. Prewrite account:B
Key: account:B, Timestamp: 200
data: 600
lock: secondary, tx_200, primary=account:A
write: (空)


阶段2：Commit（提交阶段）
1. 提交Primary Key
2. 删除Primary Key的锁
3. 写入write列
4. 异步提交Secondary Keys

示例：
-- 1. Commit account:A (Primary)
Key: account:A, Timestamp: 200
data: 900
lock: (删除)
write: committed, timestamp=200

-- 2. Commit account:B (Secondary)
Key: account:B, Timestamp: 200
data: 600
lock: (删除)
write: committed, timestamp=200


关键点：
- Primary Key提交成功 → 事务成功
- Primary Key提交失败 → 事务失败
- 使用Primary Key作为事务的原子性保证
```

---

### 6.4 Percolator的优缺点

#### 优点

```
1. ✅ 无中心协调者
   - 不需要单独的事务管理器
   - 避免单点故障

2. ✅ 支持大规模数据
   - 基于BigTable，可扩展性强
   - 适合海量数据

3. ✅ 乐观锁机制
   - 冲突少时性能好
   - 适合读多写少的场景
```

#### 缺点

```
1. ❌ 冲突时性能差
   - 需要重试
   - 适合冲突少的场景

2. ❌ 实现复杂
   - 需要维护多个版本
   - 需要垃圾回收机制

3. ❌ 延迟较高
   - 两阶段提交
   - 需要多次网络通信
```

---

## 七、事务执行中表能否被读取？

### 7.1 单机数据库（MySQL）

```sql
-- 场景：事务A正在执行

-- 事务A
START TRANSACTION;
UPDATE account SET balance = balance - 100 WHERE user_id = 'A';
-- 事务A未提交

-- 事务B（同时执行）
START TRANSACTION;
SELECT balance FROM account WHERE user_id = 'A';
-- 问题：能读到什么数据？

答案：取决于隔离级别

1. READ UNCOMMITTED（读未提交）
   - ✅ 可以读取
   - 读到：balance = 900（未提交的数据）
   - 问题：脏读

2. READ COMMITTED（读已提交）
   - ✅ 可以读取
   - 读到：balance = 1000（提交前的数据）
   - 使用MVCC，读取快照

3. REPEATABLE READ（可重复读）
   - ✅ 可以读取
   - 读到：balance = 1000（事务B开始时的快照）
   - 使用MVCC，读取快照

4. SERIALIZABLE（串行化）
   - ⚠️ 阻塞或读取快照
   - MySQL InnoDB：读取快照（使用MVCC）
   - 其他数据库：可能阻塞
```

**结论**：
- **快照读**：可以读取（不阻塞）
- **当前读**：阻塞（等待事务A提交）

```sql
-- 快照读（不阻塞）
SELECT balance FROM account WHERE user_id = 'A';
-- ✅ 立即返回：balance = 1000

-- 当前读（阻塞）
SELECT balance FROM account WHERE user_id = 'A' FOR UPDATE;
-- ⚠️ 阻塞，等待事务A提交或回滚
```

---

### 7.2 分布式数据库

#### 方案1：基于2PC的分布式数据库

```sql
-- 场景：分布式事务正在执行

-- 事务A（跨库转账）
BEGIN;
UPDATE db1.account SET balance = balance - 100 WHERE user_id = 'A';
UPDATE db2.account SET balance = balance + 100 WHERE user_id = 'B';
-- 准备阶段，事务A未提交

-- 事务B（读取）
SELECT balance FROM db1.account WHERE user_id = 'A';
-- 问题：能读到什么数据？

答案：取决于实现方式

1. 悲观锁（2PC）
   - 准备阶段：锁定资源
   - 快照读：✅ 可以读取（读取快照）
   - 当前读：⚠️ 阻塞（等待事务A提交）

2. 乐观锁（Percolator）
   - 预写阶段：写入数据但未提交
   - 快照读：✅ 可以读取（读取旧版本）
   - 当前读：✅ 可以读取（检查锁，读取旧版本）
```

---

#### 方案2：基于Raft的分布式数据库（TiDB）

```sql
-- TiDB的事务模型

-- 事务A
BEGIN;
UPDATE account SET balance = balance - 100 WHERE user_id = 'A';
-- 事务A未提交

-- 事务B（读取）
SELECT balance FROM account WHERE user_id = 'A';
-- 问题：能读到什么数据？

答案：使用MVCC + Raft

1. 快照读（默认）
   - ✅ 可以读取
   - 读到：balance = 1000（事务B开始时的快照）
   - 不阻塞

2. 当前读（FOR UPDATE）
   - ⚠️ 阻塞
   - 等待事务A提交或回滚

TiDB的隔离级别：
- 默认：REPEATABLE READ（可重复读）
- 使用MVCC实现快照读
- 使用Percolator实现分布式事务
```

---

#### 方案3：Google Spanner

```sql
-- Spanner的事务模型

-- 事务A
BEGIN;
UPDATE account SET balance = balance - 100 WHERE user_id = 'A';
-- 事务A未提交

-- 事务B（读取）
SELECT balance FROM account WHERE user_id = 'A';
-- 问题：能读到什么数据？

答案：使用TrueTime + MVCC

1. 快照读（默认）
   - ✅ 可以读取
   - 读到：balance = 1000（事务B开始时的快照）
   - 使用TrueTime确定快照时间戳

2. 强一致性读（READ ONLY）
   - ✅ 可以读取
   - 读到：最新已提交的数据
   - 可能需要等待（TrueTime不确定性）

3. 当前读（FOR UPDATE）
   - ⚠️ 阻塞
   - 等待事务A提交或回滚

Spanner的特点：
- 全球强一致性
- 使用TrueTime（原子钟 + GPS）
- 外部一致性（External Consistency）
```

---

### 7.3 总结：事务执行中表能否被读取

| 数据库类型 | 快照读 | 当前读 | 实现机制 |
|-----------|-------|-------|---------|
| **MySQL** | ✅ 可以 | ⚠️ 阻塞 | MVCC |
| **2PC分布式数据库** | ✅ 可以 | ⚠️ 阻塞 | MVCC + 2PC |
| **TiDB** | ✅ 可以 | ⚠️ 阻塞 | MVCC + Percolator |
| **Spanner** | ✅ 可以 | ⚠️ 阻塞 | MVCC + TrueTime |

**核心结论**：
1. **快照读**：几乎所有数据库都支持，不阻塞
2. **当前读**：需要等待事务提交，会阻塞
3. **实现机制**：MVCC是关键，提供快照隔离

---

## 八、实战案例

### 8.1 案例1：电商订单系统（2PC）

```java
/**
 * 场景：创建订单 + 扣减库存 + 增加积分
 * 要求：三个操作要么都成功，要么都失败
 */

// 方案1：使用JTA（Java Transaction API）+ XA协议
@Service
public class OrderService {
    
    @Autowired
    private OrderDao orderDao;  // 订单数据库
    
    @Autowired
    private InventoryDao inventoryDao;  // 库存数据库
    
    @Autowired
    private PointsDao pointsDao;  // 积分数据库
    
    @Transactional  // 使用JTA事务管理器
    public void createOrder(Order order) {
        // 1. 创建订单（数据库1）
        orderDao.insert(order);
        
        // 2. 扣减库存（数据库2）
        inventoryDao.decreaseStock(order.getProductId(), order.getQuantity());
        
        // 3. 增加积分（数据库3）
        pointsDao.addPoints(order.getUserId(), order.getAmount() * 0.01);
        
        // JTA事务管理器自动使用2PC协议提交事务
    }
}

// 配置XA数据源
@Configuration
public class DataSourceConfig {
    
    @Bean
    public DataSource orderDataSource() {
        // XA数据源（支持2PC）
        MysqlXADataSource xaDataSource = new MysqlXADataSource();
        xaDataSource.setUrl("jdbc:mysql://localhost:3306/order_db");
        return xaDataSource;
    }
    
    @Bean
    public DataSource inventoryDataSource() {
        MysqlXADataSource xaDataSource = new MysqlXADataSource();
        xaDataSource.setUrl("jdbc:mysql://localhost:3307/inventory_db");
        return xaDataSource;
    }
    
    @Bean
    public DataSource pointsDataSource() {
        MysqlXADataSource xaDataSource = new MysqlXADataSource();
        xaDataSource.setUrl("jdbc:mysql://localhost:3308/points_db");
        return xaDataSource;
    }
    
    @Bean
    public JtaTransactionManager transactionManager() {
        // JTA事务管理器（协调者）
        return new JtaTransactionManager();
    }
}

// 执行流程：
// 1. 准备阶段
//    - 订单数据库：INSERT order，返回YES
//    - 库存数据库：UPDATE inventory，返回YES
//    - 积分数据库：UPDATE points，返回YES
//
// 2. 提交阶段
//    - JTA事务管理器发送COMMIT
//    - 所有数据库提交事务
//
// 3. 事务执行中，其他事务能否读取？
//    - 快照读：✅ 可以（读取旧数据）
//    - 当前读：⚠️ 阻塞（等待提交）
```

---

### 8.2 案例2：分布式转账（TiDB）

```java
/**
 * 场景：跨行转账
 * 数据库：TiDB（分布式数据库）
 */

@Service
public class TransferService {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Transactional
    public void transfer(String fromAccount, String toAccount, BigDecimal amount) {
        // 1. 检查余额
        BigDecimal balance = jdbcTemplate.queryForObject(
            "SELECT balance FROM account WHERE account_no = ? FOR UPDATE",
            BigDecimal.class,
            fromAccount
        );
        
        if (balance.compareTo(amount) < 0) {
            throw new InsufficientBalanceException("余额不足");
        }
        
        // 2. 扣减转出账户
        jdbcTemplate.update(
            "UPDATE account SET balance = balance - ? WHERE account_no = ?",
            amount,
            fromAccount
        );
        
        // 3. 增加转入账户
        jdbcTemplate.update(
            "UPDATE account SET balance = balance + ? WHERE account_no = ?",
            amount,
            toAccount
        );
        
        // TiDB自动使用Percolator协议提交事务
    }
}

// TiDB的事务流程：
// 1. Prewrite阶段
//    - 选择Primary Key：account:fromAccount
//    - Prewrite account:fromAccount（加锁）
//    - Prewrite account:toAccount（加锁）
//
// 2. Commit阶段
//    - Commit Primary Key：account:fromAccount
//    - 异步Commit Secondary Key：account:toAccount
//
// 3. 事务执行中，其他事务能否读取？
//    - 快照读：✅ 可以（读取旧版本）
//    - 当前读：⚠️ 阻塞（检测到锁，等待提交）

// 示例：事务执行中的读取
@Service
public class AccountQueryService {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // 快照读（不阻塞）
    public BigDecimal getBalance(String accountNo) {
        return jdbcTemplate.queryForObject(
            "SELECT balance FROM account WHERE account_no = ?",
            BigDecimal.class,
            accountNo
        );
        // ✅ 立即返回，读取快照数据
    }
    
    // 当前读（阻塞）
    public BigDecimal getBalanceForUpdate(String accountNo) {
        return jdbcTemplate.queryForObject(
            "SELECT balance FROM account WHERE account_no = ? FOR UPDATE",
            BigDecimal.class,
            accountNo
        );
        // ⚠️ 如果有其他事务正在修改，会阻塞
    }
}
```

---

### 8.3 案例3：Seata分布式事务框架

```java
/**
 * 场景：使用Seata实现分布式事务
 * Seata模式：AT模式（自动补偿）
 */

// 订单服务
@Service
public class OrderService {
    
    @Autowired
    private OrderDao orderDao;
    
    @Autowired
    private InventoryFeignClient inventoryFeignClient;
    
    @Autowired
    private AccountFeignClient accountFeignClient;
    
    @GlobalTransactional  // Seata全局事务
    public void createOrder(Order order) {
        // 1. 创建订单
        orderDao.insert(order);
        
        // 2. 扣减库存（远程调用）
        inventoryFeignClient.decreaseStock(
            order.getProductId(), 
            order.getQuantity()
        );
        
        // 3. 扣减余额（远程调用）
        accountFeignClient.decreaseBalance(
            order.getUserId(), 
            order.getAmount()
        );
        
        // Seata自动协调分布式事务
    }
}

// 库存服务
@Service
public class InventoryService {
    
    @Autowired
    private InventoryDao inventoryDao;
    
    public void decreaseStock(Long productId, Integer quantity) {
        // Seata自动记录Undo Log
        inventoryDao.decreaseStock(productId, quantity);
    }
}

// 账户服务
@Service
public class AccountService {
    
    @Autowired
    private AccountDao accountDao;
    
    public void decreaseBalance(Long userId, BigDecimal amount) {
        // Seata自动记录Undo Log
        accountDao.decreaseBalance(userId, amount);
    }
}

// Seata的执行流程：
// 1. 阶段1：执行业务SQL
//    - 订单服务：INSERT order
//    - 库存服务：UPDATE inventory（记录Undo Log）
//    - 账户服务：UPDATE account（记录Undo Log）
//
// 2. 阶段2：提交或回滚
//    - 成功：删除Undo Log
//    - 失败：根据Undo Log回滚
//
// 3. 事务执行中，其他事务能否读取？
//    - 快照读：✅ 可以（读取旧数据）
//    - 当前读：⚠️ 阻塞（Seata加了全局锁）

// Seata的优势：
// 1. ✅ 对业务代码侵入小
// 2. ✅ 自动补偿机制
// 3. ✅ 支持多种模式（AT、TCC、SAGA、XA）
// 4. ⚠️ 性能开销（需要记录Undo Log）
```

---

## 九、最佳实践

### 9.1 如何选择分布式事务方案？

```
决策树：

需要强一致性？
├─ 是
│  ├─ 性能要求高？
│  │  ├─ 是 → Percolator/TiDB（乐观锁）
│  │  └─ 否 → 2PC/XA（悲观锁）
│  │
│  └─ 全球部署？
│     └─ 是 → Spanner（TrueTime）
│
└─ 否（最终一致性）
   ├─ 补偿机制 → Seata/TCC
   ├─ 消息队列 → RocketMQ事务消息
   └─ 本地消息表 → 本地事务 + 定时任务
```

---

### 9.2 性能优化建议

```
1. ✅ 减少跨库事务
   - 尽量在同一个数据库内完成事务
   - 使用分库分表策略，将相关数据放在同一个库

2. ✅ 使用异步化
   - 核心操作同步，非核心操作异步
   - 使用消息队列解耦

3. ✅ 缩短事务时间
   - 减少事务内的操作
   - 避免在事务内调用外部服务

4. ✅ 使用乐观锁
   - 冲突少的场景使用乐观锁
   - 减少锁等待时间

5. ✅ 读写分离
   - 读操作走从库（快照读）
   - 写操作走主库（当前读）
```

---

### 9.3 监控和告警

```java
// 监控分布式事务的关键指标

@Component
public class TransactionMonitor {
    
    // 1. 事务成功率
    @Metric
    public double transactionSuccessRate() {
        long success = getSuccessCount();
        long total = getTotalCount();
        return (double) success / total;
    }
    
    // 2. 事务平均耗时
    @Metric
    public long transactionAvgDuration() {
        return getTotalDuration() / getTotalCount();
    }
    
    // 3. 事务超时次数
    @Metric
    public long transactionTimeoutCount() {
        return getTimeoutCount();
    }
    
    // 4. 事务回滚次数
    @Metric
    public long transactionRollbackCount() {
        return getRollbackCount();
    }
    
    // 5. 锁等待时间
    @Metric
    public long lockWaitTime() {
        return getTotalLockWaitTime() / getTotalCount();
    }
}

// 告警规则：
// 1. 事务成功率 < 99% → 告警
// 2. 事务平均耗时 > 1秒 → 告警
// 3. 事务超时次数 > 10次/分钟 → 告警
// 4. 事务回滚次数 > 100次/分钟 → 告警
// 5. 锁等待时间 > 500ms → 告警
```

---

## 十、总结

### 核心要点

```
1. 分布式强一致性事务实现方案：
   - 2PC：最常用，强一致性，性能一般
   - 3PC：改进2PC，减少阻塞
   - Paxos/Raft：分布式共识算法
   - Percolator：乐观锁，适合冲突少的场景
   - Spanner：全球强一致性，使用TrueTime

2. 事务执行中表能否被读取：
   - 快照读：✅ 可以（不阻塞）
   - 当前读：⚠️ 阻塞（等待提交）
   - 实现机制：MVCC

3. 选择建议：
   - 强一致性 + 高性能 → Percolator/TiDB
   - 强一致性 + 简单 → 2PC/XA
   - 最终一致性 → Seata/消息队列
```

### 记忆口诀

```
分布式事务难实现，一致性能难兼顾
2PC协议最常用，两阶段提交保一致
3PC改进减阻塞，超时机制更灵活
Raft算法强共识，多数派原则保安全
Percolator乐观锁，冲突少时性能好
事务执行能读取，快照读取不阻塞
当前读取需等待，MVCC机制是关键
```

### 对比表格

| 方案 | 一致性 | 性能 | 复杂度 | 适用场景 |
|-----|-------|-----|-------|---------|
| **2PC** | 强一致性 | 一般 | 中 | 传统分布式数据库 |
| **3PC** | 强一致性 | 较差 | 高 | 改进2PC |
| **Raft** | 强一致性 | 好 | 高 | 分布式存储系统 |
| **Percolator** | 强一致性 | 好 | 高 | 大规模分布式数据库 |
| **Spanner** | 强一致性 | 好 | 极高 | 全球分布式数据库 |
| **Seata** | 最终一致性 | 好 | 中 | 微服务架构 |

**最终答案：分布式强一致性事务通常使用2PC、Raft或Percolator实现。事务执行中，快照读可以读取（不阻塞），当前读需要等待事务提交（阻塞）。实现机制是MVCC，提供快照隔离。**
