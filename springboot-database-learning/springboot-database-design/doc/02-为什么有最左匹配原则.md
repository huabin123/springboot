# `mysql对范围查询做了什么优化`为什么有最左匹配原则？

## 一、快速结论

**最左匹配原则（Leftmost Prefix Principle）**是MySQL联合索引的核心规则，源于B+树索引的存储结构。

### 核心要点

1. **联合索引按照字段顺序构建B+树**：`INDEX(a, b, c)` 先按a排序，a相同再按b排序，b相同再按c排序
2. **查询必须从最左边的字段开始匹配**：可以使用`(a)`、`(a,b)`、`(a,b,c)`，但不能跳过a直接使用`(b)`或`(c)`
3. **遇到范围查询会停止匹配**：`WHERE a=1 AND b>2 AND c=3`，索引只能用到`(a,b)`，c无法使用索引

## 二、为什么会有最左匹配原则？

### 2.1 B+树索引的存储结构

#### 单列索引的B+树

```sql
-- 创建单列索引
CREATE TABLE user (
    id INT PRIMARY KEY,
    age INT,
    INDEX idx_age (age)
);

-- 插入数据
INSERT INTO user VALUES
(1, 20), (2, 25), (3, 20), (4, 30), (5, 25);
```

**B+树结构（按age排序）：**

```
          [25]
         /    \
    [20, 20]  [25, 25, 30]
     ↓  ↓      ↓   ↓   ↓
    (1)(3)    (2) (5) (4)
```

- **特点**：数据按age单一维度排序
- **查询**：`WHERE age = 25` 可以快速定位到25的位置

---

#### 联合索引的B+树

```sql
-- 创建联合索引
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    city VARCHAR(50),
    INDEX idx_name_age_city (name, age, city)
);

-- 插入数据
INSERT INTO user VALUES
(1, '张三', 20, '北京'),
(2, '张三', 25, '上海'),
(3, '李四', 20, '北京'),
(4, '李四', 25, '上海'),
(5, '王五', 30, '深圳');
```

**B+树结构（按name, age, city排序）：**

```
联合索引 (name, age, city) 的B+树节点：

叶子节点（按顺序排列）：
('李四', 20, '北京') → id=3
('李四', 25, '上海') → id=4
('王五', 30, '深圳') → id=5
('张三', 20, '北京') → id=1
('张三', 25, '上海') → id=2
```

**排序规则**：

1. **第一优先级**：按name排序（'李四' < '王五' < '张三'）
2. **第二优先级**：name相同时，按age排序（'张三',20 < '张三',25）
3. **第三优先级**：name和age都相同时，按city排序

---

### 2.2 为什么必须从最左边开始？

#### 场景1：使用name查询 ✅

```sql
SELECT * FROM user WHERE name = '张三';
```

**B+树查找过程**：

```
1. 从根节点开始，按name='张三'查找
2. 定位到叶子节点：('张三', 20, '北京') 和 ('张三', 25, '上海')
3. ✅ 可以使用索引，因为name是最左边的字段
```

**为什么可以？**

- B+树按name排序，所有'张三'的记录都在一起
- 可以快速定位到'张三'的范围

---

#### 场景2：使用name和age查询 ✅

```sql
SELECT * FROM user WHERE name = '张三' AND age = 25;
```

**B+树查找过程**：

```
1. 先按name='张三'定位到：('张三', 20, '北京') 和 ('张三', 25, '上海')
2. 在'张三'的范围内，再按age=25定位到：('张三', 25, '上海')
3. ✅ 可以使用索引 (name, age)
```

**为什么可以？**

- name相同的记录，按age排序
- 在'张三'的范围内，age是有序的

---

#### 场景3：跳过name，直接使用age查询 ❌

```sql
SELECT * FROM user WHERE age = 25;
```

**B+树查找过程**：

```
B+树的排序：
('李四', 20, '北京')  ← age=20
('李四', 25, '上海')  ← age=25
('王五', 30, '深圳')  ← age=30
('张三', 20, '北京')  ← age=20
('张三', 25, '上海')  ← age=25

问题：age=25的记录分散在不同位置！
- ('李四', 25, '上海') 在第2个位置
- ('张三', 25, '上海') 在第5个位置

❌ 无法使用索引，因为age不是全局有序的
```

**为什么不可以？**

- B+树按name排序，age只在name相同的范围内有序
- age在全局范围内是无序的，无法快速定位

---

#### 场景4：跳过name和age，直接使用city查询 ❌

```sql
SELECT * FROM user WHERE city = '北京';
```

**B+树查找过程**：

```
B+树的排序：
('李四', 20, '北京')  ← city='北京'
('李四', 25, '上海')  ← city='上海'
('王五', 30, '深圳')  ← city='深圳'
('张三', 20, '北京')  ← city='北京'
('张三', 25, '上海')  ← city='上海'

问题：city='北京'的记录分散在不同位置！
❌ 无法使用索引
```

---

### 2.3 图解：为什么必须从左开始？

```
联合索引 (name, age, city) 的排序逻辑：

第1层排序（name）：全局有序
  ↓
  李四 ────────┐
  王五 ────────┤  ← name全局有序，可以快速定位
  张三 ────────┘

第2层排序（age）：局部有序（name相同时）
  ↓
  李四 ─┬─ 20  ← 在"李四"范围内，age有序
       └─ 25
  王五 ─── 30
  张三 ─┬─ 20  ← 在"张三"范围内，age有序
       └─ 25

第3层排序（city）：更局部有序（name和age都相同时）
  ↓
  李四,20 ─── 北京  ← 在"李四,20"范围内，city有序
  李四,25 ─── 上海
  ...

结论：
✅ 查询name：可以使用索引（全局有序）
✅ 查询name+age：可以使用索引（name定位后，age局部有序）
✅ 查询name+age+city：可以使用索引（name+age定位后，city局部有序）
❌ 查询age：不能使用索引（age全局无序）
❌ 查询city：不能使用索引（city全局无序）
❌ 查询age+city：不能使用索引（都是全局无序）
```

---

## 三、最左匹配原则的详细规则

### 3.1 规则1：必须从最左边的字段开始

```sql
-- 索引：INDEX idx_abc (a, b, c)

-- ✅ 可以使用索引
WHERE a = 1
WHERE a = 1 AND b = 2
WHERE a = 1 AND b = 2 AND c = 3

-- ❌ 不能使用索引
WHERE b = 2
WHERE c = 3
WHERE b = 2 AND c = 3
```

**原因**：B+树按(a, b, c)排序，跳过a后，b和c全局无序。

---

### 3.2 规则2：可以跳过中间字段，但后面的字段无法使用索引

```sql
-- 索引：INDEX idx_abc (a, b, c)

-- ✅ 可以使用索引，但只用到a
WHERE a = 1 AND c = 3

-- 执行计划：
EXPLAIN SELECT * FROM t WHERE a = 1 AND c = 3;
-- key: idx_abc
-- key_len: 5（只用到a，假设a是INT，4字节 + 1字节NULL标识）
```

**原因**：

- a可以使用索引（全局有序）
- 跳过b后，c在a相同的范围内无序，无法使用索引
- MySQL会先用索引定位a=1的记录，然后在结果中过滤c=3

---

### 3.3 规则3：遇到范围查询（>, <, BETWEEN, LIKE）会停止匹配

```sql
-- 索引：INDEX idx_abc (a, b, c)

-- ✅ 可以使用索引 (a, b)，c无法使用索引
WHERE a = 1 AND b > 2 AND c = 3

-- 执行计划：
EXPLAIN SELECT * FROM t WHERE a = 1 AND b > 2 AND c = 3;
-- key: idx_abc
-- key_len: 10（用到a和b，假设a和b都是INT，各4字节 + 1字节NULL标识）
```

**原因**：

- a=1：可以使用索引（精确匹配）
- b>2：可以使用索引（范围查询）
- c=3：无法使用索引（b是范围查询，c在b>2的范围内无序）

**图解**：

```
假设数据：
(a=1, b=1, c=1)
(a=1, b=2, c=2)
(a=1, b=3, c=1)  ← b>2的范围
(a=1, b=4, c=3)  ← b>2的范围
(a=1, b=5, c=2)  ← b>2的范围

问题：在b>2的范围内，c是无序的（1, 3, 2）
❌ c无法使用索引
```

---

### 3.4 规则4：等值查询可以乱序

```sql
-- 索引：INDEX idx_abc (a, b, c)

-- ✅ 以下查询都可以使用索引 (a, b, c)
WHERE a = 1 AND b = 2 AND c = 3
WHERE b = 2 AND a = 1 AND c = 3  ← 顺序不同
WHERE c = 3 AND b = 2 AND a = 1  ← 顺序不同

-- 原因：MySQL优化器会自动调整查询顺序
```

**MySQL优化器的处理**：

```sql
-- 原始查询
WHERE c = 3 AND b = 2 AND a = 1

-- 优化器自动调整为
WHERE a = 1 AND b = 2 AND c = 3

-- 然后使用索引 (a, b, c)
```

---

### 3.5 规则5：LIKE查询的特殊情况

```sql
-- 索引：INDEX idx_name (name)

-- ✅ 可以使用索引（前缀匹配）
WHERE name LIKE '张%'

-- ❌ 不能使用索引（非前缀匹配）
WHERE name LIKE '%张'
WHERE name LIKE '%张%'
```

**原因**：

```
B+树按name排序：
'张三'
'张四'
'张五'
'李四'
'王五'

-- LIKE '张%'：可以定位到'张'开头的范围 ✅
-- LIKE '%张'：无法定位，需要全表扫描 ❌
```

**联合索引的LIKE**：

```sql
-- 索引：INDEX idx_abc (a, b, c)

-- ✅ 可以使用索引 (a, b)
WHERE a = 1 AND b LIKE '张%' AND c = 3

-- ❌ b和c都无法使用索引
WHERE a = 1 AND b LIKE '%张%' AND c = 3
```

---

## 四、实战案例分析

### 案例1：用户查询

```sql
-- 表结构
CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    city VARCHAR(50),
    gender TINYINT,
    INDEX idx_name_age_city (name, age, city)
);

-- 查询1：✅ 使用索引 (name)
SELECT * FROM user WHERE name = '张三';

-- 查询2：✅ 使用索引 (name, age)
SELECT * FROM user WHERE name = '张三' AND age = 25;

-- 查询3：✅ 使用索引 (name, age, city)
SELECT * FROM user WHERE name = '张三' AND age = 25 AND city = '北京';

-- 查询4：✅ 使用索引 (name)，但city无法使用索引
SELECT * FROM user WHERE name = '张三' AND city = '北京';

-- 查询5：❌ 不能使用索引
SELECT * FROM user WHERE age = 25;

-- 查询6：❌ 不能使用索引
SELECT * FROM user WHERE city = '北京';

-- 查询7：✅ 使用索引 (name, age)，但city无法使用索引
SELECT * FROM user WHERE name = '张三' AND age > 20 AND city = '北京';
```

**执行计划验证**：

```sql
EXPLAIN SELECT * FROM user WHERE name = '张三' AND age > 20 AND city = '北京';

-- 结果：
-- key: idx_name_age_city
-- key_len: 208（name:50*4+2=202, age:4+1=5, 总共207，实际可能略有差异）
-- 说明：只用到了 (name, age)，city没有用到
```

---

### 案例2：订单查询

```sql
-- 表结构
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,
    status VARCHAR(20),
    created_time DATETIME,
    INDEX idx_user_status_time (user_id, status, created_time)
);

-- 查询1：✅ 使用索引 (user_id, status, created_time)
SELECT * FROM orders
WHERE user_id = 1001
  AND status = 'PAID'
  AND created_time > '2024-01-01';

-- 查询2：✅ 使用索引 (user_id, status)，但created_time无法使用索引
SELECT * FROM orders
WHERE user_id = 1001
  AND status IN ('PAID', 'SHIPPED')  -- IN相当于多个OR，会停止匹配
  AND created_time > '2024-01-01';

-- 查询3：✅ 使用索引 (user_id)
SELECT * FROM orders
WHERE user_id = 1001
  AND created_time > '2024-01-01';  -- 跳过status

-- 查询4：❌ 不能使用索引
SELECT * FROM orders
WHERE status = 'PAID'
  AND created_time > '2024-01-01';  -- 跳过user_id
```

---

### 案例3：范围查询的优化

```sql
-- 索引：INDEX idx_abc (a, b, c)

-- 问题：如何让c也能使用索引？

-- ❌ 原始查询：只能用到 (a, b)
SELECT * FROM t WHERE a = 1 AND b > 2 AND c = 3;

-- ✅ 优化方案1：改为等值查询
SELECT * FROM t WHERE a = 1 AND b IN (3, 4, 5, ...) AND c = 3;

-- ✅ 优化方案2：调整索引顺序
-- 如果c的过滤性更强，可以调整为：INDEX idx_acb (a, c, b)
SELECT * FROM t WHERE a = 1 AND c = 3 AND b > 2;
-- 这样可以用到 (a, c)

-- ✅ 优化方案3：创建覆盖索引
-- INDEX idx_abc (a, b, c)
SELECT a, b, c FROM t WHERE a = 1 AND b > 2 AND c = 3;
-- 虽然c无法用于查找，但可以用于过滤（索引覆盖）
```

---

## 五、如何设计联合索引？

### 5.1 设计原则

#### 原则1：高频查询字段放在最左边

```sql
-- 查询频率：
-- WHERE user_id = ? : 80%
-- WHERE user_id = ? AND status = ? : 15%
-- WHERE user_id = ? AND status = ? AND created_time > ? : 5%

-- 推荐索引：
INDEX idx_user_status_time (user_id, status, created_time)

-- 原因：user_id是最高频的查询字段，放在最左边
```

---

#### 原则2：区分度高的字段放在前面

```sql
-- 假设数据分布：
-- user_id: 100万个不同值（区分度高）
-- status: 5个不同值（区分度低）
-- city: 100个不同值（区分度中）

-- 推荐索引：
INDEX idx_user_city_status (user_id, city, status)

-- 原因：区分度高的字段放前面，可以快速缩小范围
```

**区分度计算**：

```sql
-- 区分度 = 不同值的数量 / 总记录数

SELECT
    COUNT(DISTINCT user_id) / COUNT(*) AS user_id_selectivity,
    COUNT(DISTINCT status) / COUNT(*) AS status_selectivity,
    COUNT(DISTINCT city) / COUNT(*) AS city_selectivity
FROM orders;

-- 结果：
-- user_id_selectivity: 0.95（高）
-- city_selectivity: 0.10（中）
-- status_selectivity: 0.005（低）

-- 推荐顺序：user_id > city > status
```

---

#### 原则3：等值查询字段放在范围查询字段前面

```sql
-- 查询：
WHERE user_id = 1001 AND created_time > '2024-01-01' AND status = 'PAID'

-- ❌ 错误索引：
INDEX idx_user_time_status (user_id, created_time, status)
-- 问题：created_time是范围查询，status无法使用索引

-- ✅ 正确索引：
INDEX idx_user_status_time (user_id, status, created_time)
-- 原因：等值查询（user_id, status）放前面，范围查询（created_time）放后面
```

---

#### 原则4：考虑排序和分组

```sql
-- 查询：
SELECT * FROM orders
WHERE user_id = 1001
ORDER BY created_time DESC
LIMIT 10;

-- 推荐索引：
INDEX idx_user_time (user_id, created_time)

-- 原因：
-- 1. user_id用于WHERE过滤
-- 2. created_time用于ORDER BY排序
-- 3. 索引本身有序，可以避免filesort
```

---

### 5.2 常见索引设计场景

#### 场景1：用户订单查询

```sql
-- 查询需求：
-- 1. 查询某用户的所有订单：WHERE user_id = ?
-- 2. 查询某用户某状态的订单：WHERE user_id = ? AND status = ?
-- 3. 查询某用户某时间段的订单：WHERE user_id = ? AND created_time BETWEEN ? AND ?

-- 推荐索引：
INDEX idx_user_status_time (user_id, status, created_time)

-- 覆盖所有查询：
-- 查询1：使用 (user_id)
-- 查询2：使用 (user_id, status)
-- 查询3：使用 (user_id)，created_time作为范围查询
```

---

#### 场景2：商品搜索

```sql
-- 查询需求：
-- 1. 按分类搜索：WHERE category_id = ?
-- 2. 按分类和价格搜索：WHERE category_id = ? AND price BETWEEN ? AND ?
-- 3. 按分类、价格和销量排序：WHERE category_id = ? AND price BETWEEN ? AND ? ORDER BY sales DESC

-- 推荐索引：
INDEX idx_category_price_sales (category_id, price, sales)

-- 注意：
-- 查询3中，price是范围查询，sales无法用于查找，但可以用于排序（如果数据量不大）
-- 如果数据量大，可能需要额外的索引：INDEX idx_category_sales (category_id, sales)
```

---

#### 场景3：日志查询

```sql
-- 查询需求：
-- 1. 查询某用户的日志：WHERE user_id = ?
-- 2. 查询某时间段的日志：WHERE created_time BETWEEN ? AND ?
-- 3. 查询某用户某时间段的日志：WHERE user_id = ? AND created_time BETWEEN ? AND ?

-- 推荐索引：
INDEX idx_user_time (user_id, created_time)  -- 覆盖查询1和3
INDEX idx_time (created_time)  -- 覆盖查询2

-- 原因：
-- 查询2跳过了user_id，无法使用idx_user_time，需要单独的索引
```

---

## 六、常见误区

### 误区1：索引字段越多越好 ❌

```sql
-- ❌ 错误：创建过多字段的索引
INDEX idx_all (a, b, c, d, e, f, g)

-- 问题：
-- 1. 索引占用空间大
-- 2. 维护成本高（INSERT/UPDATE/DELETE变慢）
-- 3. 大部分字段用不到

-- ✅ 正确：根据查询需求创建合适的索引
INDEX idx_abc (a, b, c)  -- 覆盖80%的查询
INDEX idx_de (d, e)  -- 覆盖15%的查询
```

---

### 误区2：所有查询都要用到索引的所有字段 ❌

```sql
-- 索引：INDEX idx_abc (a, b, c)

-- ❌ 错误理解：必须WHERE a=? AND b=? AND c=? 才能使用索引

-- ✅ 正确理解：
WHERE a = ?  -- 可以使用索引 (a)
WHERE a = ? AND b = ?  -- 可以使用索引 (a, b)
WHERE a = ? AND b = ? AND c = ?  -- 可以使用索引 (a, b, c)
```

---

### 误区3：范围查询完全不能使用索引 ❌

```sql
-- ❌ 错误理解：范围查询不能使用索引

-- ✅ 正确理解：范围查询可以使用索引，但会停止后续字段的匹配

-- 索引：INDEX idx_abc (a, b, c)
WHERE a = 1 AND b > 2 AND c = 3
-- 可以使用索引 (a, b)，c无法使用索引
```

---

### 误区4：IN查询等同于等值查询 ❌

```sql
-- 索引：INDEX idx_abc (a, b, c)

-- ✅ 等值查询：可以使用索引 (a, b, c)
WHERE a = 1 AND b = 2 AND c = 3

-- ⚠️ IN查询：可以使用索引 (a, b)，但c无法使用索引
WHERE a = 1 AND b IN (2, 3, 4) AND c = 3

-- 原因：IN相当于多个OR，MySQL会将其视为范围查询
```

**MySQL 8.0的优化**：

```sql
-- MySQL 8.0+对IN进行了优化，某些情况下可以使用索引

-- 如果IN的值很少（通常<5个），可能会优化为多个等值查询
WHERE a = 1 AND b IN (2, 3) AND c = 3
-- 优化为：
-- (a=1 AND b=2 AND c=3) OR (a=1 AND b=3 AND c=3)
-- 可以使用索引 (a, b, c)

-- 如果IN的值很多，仍然视为范围查询
WHERE a = 1 AND b IN (2, 3, 4, 5, 6, ..., 100) AND c = 3
-- c无法使用索引
```

---

## 七、总结

### 核心原理

```
最左匹配原则的本质：
1. B+树按照索引字段的顺序排序
2. 只有最左边的字段是全局有序的
3. 后续字段只在前面字段相同的范围内有序
4. 因此查询必须从最左边的字段开始匹配
```

### 设计原则

```
联合索引设计的5大原则：
1. 高频查询字段放在最左边
2. 区分度高的字段放在前面
3. 等值查询字段放在范围查询字段前面
4. 考虑排序和分组的需求
5. 避免创建过多字段的索引（通常3-5个字段）
```

### 使用规则

```
最左匹配原则的使用规则：
1. ✅ 必须从最左边的字段开始
2. ✅ 可以跳过中间字段，但后面的字段无法使用索引
3. ✅ 遇到范围查询会停止匹配
4. ✅ 等值查询可以乱序（MySQL优化器会调整）
5. ✅ LIKE '前缀%' 可以使用索引，LIKE '%后缀' 不能
```

### 记忆口诀

```
联合索引按序建，B+树中层层排
最左字段全局序，后续字段局部排
查询必须从左起，跳过中间后失效
范围查询停匹配，等值乱序优化器调
高频区分放最左，等值范围有先后
```

### 最佳实践

```sql
-- 1. 根据查询需求设计索引
-- 分析查询频率和过滤条件

-- 2. 使用EXPLAIN验证索引使用情况
EXPLAIN SELECT * FROM t WHERE a = 1 AND b = 2 AND c = 3;

-- 3. 监控慢查询日志
-- 找出没有使用索引的查询

-- 4. 定期优化索引
-- 删除冗余索引，添加缺失索引
```

**最终答案：最左匹配原则源于B+树的存储结构，联合索引按字段顺序排序，只有最左边的字段是全局有序的，因此查询必须从最左边开始匹配。**
