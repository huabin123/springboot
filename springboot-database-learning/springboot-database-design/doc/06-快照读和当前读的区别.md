# 快照读和当前读的区别

## 一、快速结论

**核心区别**：

| 对比项 | 快照读（Snapshot Read） | 当前读（Current Read） |
|-------|----------------------|---------------------|
| **定义** | 读取历史版本数据（MVCC） | 读取最新版本数据（加锁） |
| **是否加锁** | ❌ 不加锁 | ✅ 加锁（共享锁或排他锁） |
| **读取数据** | 读取快照版本 | 读取当前最新版本 |
| **并发性** | 高（不阻塞写操作） | 低（阻塞其他写操作） |
| **典型操作** | `SELECT` | `SELECT ... FOR UPDATE`<br>`UPDATE`<br>`DELETE`<br>`INSERT` |

**UPDATE和DELETE是当前读**：
- ✅ **UPDATE**：当前读（需要读取最新数据再更新）
- ✅ **DELETE**：当前读（需要读取最新数据再删除）
- ✅ **INSERT**：当前读（需要检查唯一性约束）

---

## 二、快照读（Snapshot Read）

### 2.1 什么是快照读？

**定义**：读取数据时，读取的是事务开始时的数据快照，而不是当前最新的数据。

**实现机制**：基于MVCC（Multi-Version Concurrency Control，多版本并发控制）。

**核心特点**：
- ❌ 不加锁
- ✅ 读取历史版本
- ✅ 高并发
- ✅ 不阻塞写操作

---

### 2.2 快照读的典型操作

```sql
-- ✅ 快照读（不加锁）
SELECT * FROM user WHERE id = 1;

SELECT id, name, age FROM user WHERE age > 18;

SELECT COUNT(*) FROM user;

SELECT * FROM user WHERE name LIKE 'zhang%';
```

**所有普通的SELECT语句都是快照读**（除非显式加锁）。

---

### 2.3 快照读的工作原理

#### MVCC机制

```sql
-- 创建测试表
CREATE TABLE user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    age INT
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO user (name, age) VALUES ('张三', 20);
```

**InnoDB的隐藏字段**：

```
每行记录都有3个隐藏字段：

1. DB_TRX_ID（6字节）：最后修改该行的事务ID
2. DB_ROLL_PTR（7字节）：回滚指针，指向undo log
3. DB_ROW_ID（6字节）：隐藏主键（如果没有主键）

实际存储结构：
┌────┬──────┬─────┬────────────┬─────────────┬────────────┐
│ id │ name │ age │ DB_TRX_ID  │ DB_ROLL_PTR │ DB_ROW_ID  │
├────┼──────┼─────┼────────────┼─────────────┼────────────┤
│ 1  │ 张三 │ 20  │    100     │   0x1234    │     1      │
└────┴──────┴─────┴────────────┴─────────────┴────────────┘
```

---

#### 版本链（Undo Log）

```sql
-- 事务100：插入数据
INSERT INTO user (name, age) VALUES ('张三', 20);

-- 事务200：更新数据
UPDATE user SET age = 21 WHERE id = 1;

-- 事务300：再次更新
UPDATE user SET age = 22 WHERE id = 1;
```

**版本链结构**：

```
当前版本（最新）：
┌────┬──────┬─────┬────────────┬─────────────┐
│ id │ name │ age │ DB_TRX_ID  │ DB_ROLL_PTR │
├────┼──────┼─────┼────────────┼─────────────┤
│ 1  │ 张三 │ 22  │    300     │   ────┐     │
└────┴──────┴─────┴────────────┴─────────┘   │
                                              │
                                              ▼
Undo Log（历史版本）：                          
┌────┬──────┬─────┬────────────┬─────────────┐
│ id │ name │ age │ DB_TRX_ID  │ DB_ROLL_PTR │
├────┼──────┼─────┼────────────┼─────────────┤
│ 1  │ 张三 │ 21  │    200     │   ────┐     │
└────┴──────┴─────┴────────────┴─────────┘   │
                                              │
                                              ▼
┌────┬──────┬─────┬────────────┬─────────────┐
│ id │ name │ age │ DB_TRX_ID  │ DB_ROLL_PTR │
├────┼──────┼─────┼────────────┼─────────────┤
│ 1  │ 张三 │ 20  │    100     │    NULL     │
└────┴──────┴─────┴────────────┴─────────────┘

通过版本链，可以读取任意历史版本的数据
```

---

#### ReadView（读视图）

**ReadView的作用**：判断当前事务可以看到哪个版本的数据。

**ReadView的核心字段**：

```
1. m_ids：当前活跃的事务ID列表
2. min_trx_id：最小活跃事务ID
3. max_trx_id：下一个要分配的事务ID
4. creator_trx_id：创建该ReadView的事务ID

示例：
┌─────────────────────────────────────┐
│ ReadView（事务250创建）              │
├─────────────────────────────────────┤
│ m_ids: [200, 250, 300]              │
│ min_trx_id: 200                     │
│ max_trx_id: 400                     │
│ creator_trx_id: 250                 │
└─────────────────────────────────────┘
```

---

#### 可见性判断规则

```
判断某个版本的数据是否可见：

1. 如果 DB_TRX_ID < min_trx_id
   → ✅ 可见（该版本在当前事务开始前已提交）

2. 如果 DB_TRX_ID >= max_trx_id
   → ❌ 不可见（该版本在当前事务开始后才创建）

3. 如果 min_trx_id <= DB_TRX_ID < max_trx_id
   ├─ 如果 DB_TRX_ID 在 m_ids 中
   │  → ❌ 不可见（该事务还未提交）
   └─ 如果 DB_TRX_ID 不在 m_ids 中
      → ✅ 可见（该事务已提交）

4. 如果 DB_TRX_ID == creator_trx_id
   → ✅ 可见（自己修改的数据）
```

---

### 2.4 快照读的实战演示

```sql
-- 准备数据
CREATE TABLE account (
    id BIGINT PRIMARY KEY,
    name VARCHAR(50),
    balance DECIMAL(10, 2)
);

INSERT INTO account VALUES (1, '张三', 1000.00);
```

**场景1：REPEATABLE READ隔离级别**

```sql
-- 时间线：T1 < T2 < T3 < T4

-- T1: 事务A开始
START TRANSACTION;  -- 事务A

-- T2: 事务A第一次查询（创建ReadView）
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 1000.00

-- T3: 事务B修改并提交
START TRANSACTION;  -- 事务B
UPDATE account SET balance = 2000.00 WHERE id = 1;
COMMIT;  -- 事务B提交

-- T4: 事务A再次查询（使用之前的ReadView）
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 1000.00 ✅（快照读，读取的是T2时刻的快照）

COMMIT;  -- 事务A提交
```

**解释**：
- 事务A在T2时刻创建了ReadView
- 事务B在T3时刻提交，但事务A的ReadView不会更新
- 事务A在T4时刻读取的仍然是T2时刻的快照数据
- 这就是**可重复读**的实现原理

---

**场景2：READ COMMITTED隔离级别**

```sql
-- 设置隔离级别为READ COMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- T1: 事务A开始
START TRANSACTION;  -- 事务A

-- T2: 事务A第一次查询（创建ReadView）
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 1000.00

-- T3: 事务B修改并提交
START TRANSACTION;  -- 事务B
UPDATE account SET balance = 2000.00 WHERE id = 1;
COMMIT;  -- 事务B提交

-- T4: 事务A再次查询（重新创建ReadView）
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 2000.00 ✅（快照读，但ReadView更新了）

COMMIT;  -- 事务A提交
```

**解释**：
- READ COMMITTED隔离级别下，每次SELECT都会创建新的ReadView
- 事务A在T4时刻重新创建了ReadView
- 此时事务B已经提交，所以能读到最新数据
- 这就是**读已提交**的实现原理

---

### 2.5 快照读的优缺点

#### 优点

```
1. ✅ 不加锁，高并发
   - 读操作不阻塞写操作
   - 写操作不阻塞读操作

2. ✅ 避免脏读
   - 只能读取已提交的数据

3. ✅ 可重复读（REPEATABLE READ隔离级别）
   - 同一事务内多次读取结果一致
```

#### 缺点

```
1. ❌ 可能读取到过期数据
   - 读取的是快照，不是最新数据

2. ❌ 幻读问题（部分场景）
   - 虽然MVCC可以避免大部分幻读，但无法完全避免

3. ❌ Undo Log开销
   - 需要维护历史版本，占用存储空间
```

---

## 三、当前读（Current Read）

### 3.1 什么是当前读？

**定义**：读取数据时，读取的是当前最新版本的数据，并且会加锁。

**实现机制**：基于锁机制（共享锁或排他锁）。

**核心特点**：
- ✅ 加锁（共享锁或排他锁）
- ✅ 读取最新版本
- ❌ 低并发（阻塞其他写操作）
- ✅ 保证数据一致性

---

### 3.2 当前读的典型操作

```sql
-- ✅ 当前读（加共享锁）
SELECT * FROM user WHERE id = 1 LOCK IN SHARE MODE;
SELECT * FROM user WHERE id = 1 FOR SHARE;  -- MySQL 8.0+

-- ✅ 当前读（加排他锁）
SELECT * FROM user WHERE id = 1 FOR UPDATE;

-- ✅ 当前读（UPDATE）
UPDATE user SET age = 21 WHERE id = 1;

-- ✅ 当前读（DELETE）
DELETE FROM user WHERE id = 1;

-- ✅ 当前读（INSERT）
INSERT INTO user (name, age) VALUES ('李四', 25);
```

**所有写操作（INSERT、UPDATE、DELETE）都是当前读**。

---

### 3.3 当前读的工作原理

#### 加锁机制

```sql
-- 准备数据
CREATE TABLE product (
    id BIGINT PRIMARY KEY,
    name VARCHAR(50),
    stock INT
);

INSERT INTO product VALUES (1, 'iPhone', 100);
```

**场景1：SELECT ... FOR UPDATE**

```sql
-- 事务A
START TRANSACTION;
SELECT * FROM product WHERE id = 1 FOR UPDATE;
-- ✅ 加排他锁（X锁）
-- ✅ 读取最新数据：stock = 100

-- 事务B（同时执行）
START TRANSACTION;
SELECT * FROM product WHERE id = 1 FOR UPDATE;
-- ❌ 阻塞（等待事务A释放锁）

-- 事务A提交
COMMIT;

-- 事务B获取锁
-- ✅ 读取最新数据：stock = 100
```

---

**场景2：UPDATE**

```sql
-- 事务A
START TRANSACTION;
UPDATE product SET stock = stock - 1 WHERE id = 1;
-- 步骤1：当前读（读取最新的stock值：100）
-- 步骤2：计算新值（100 - 1 = 99）
-- 步骤3：更新数据（stock = 99）
-- 步骤4：加排他锁（X锁）

-- 事务B（同时执行）
START TRANSACTION;
UPDATE product SET stock = stock - 1 WHERE id = 1;
-- ❌ 阻塞（等待事务A释放锁）

-- 事务A提交
COMMIT;

-- 事务B继续执行
-- 步骤1：当前读（读取最新的stock值：99）
-- 步骤2：计算新值（99 - 1 = 98）
-- 步骤3：更新数据（stock = 98）
```

**关键点**：UPDATE必须是当前读，否则会出现数据不一致。

---

**场景3：DELETE**

```sql
-- 事务A
START TRANSACTION;
DELETE FROM product WHERE id = 1;
-- 步骤1：当前读（读取最新数据，确认记录存在）
-- 步骤2：删除数据
-- 步骤3：加排他锁（X锁）

-- 事务B（同时执行）
START TRANSACTION;
DELETE FROM product WHERE id = 1;
-- ❌ 阻塞（等待事务A释放锁）

-- 事务A提交
COMMIT;

-- 事务B继续执行
-- 步骤1：当前读（记录已被删除）
-- 步骤2：无数据可删除
-- 结果：0 rows affected
```

---

**场景4：INSERT**

```sql
-- 事务A
START TRANSACTION;
INSERT INTO product VALUES (2, 'iPad', 50);
-- 步骤1：当前读（检查唯一性约束）
-- 步骤2：插入数据
-- 步骤3：加排他锁（X锁）

-- 事务B（同时执行）
START TRANSACTION;
INSERT INTO product VALUES (2, 'iPad Pro', 30);
-- ❌ 阻塞（等待事务A释放锁）

-- 事务A提交
COMMIT;

-- 事务B继续执行
-- 步骤1：当前读（检查唯一性约束）
-- 步骤2：发现主键冲突
-- 结果：ERROR 1062 (23000): Duplicate entry '2' for key 'PRIMARY'
```

---

### 3.4 当前读的实战演示

```sql
-- 准备数据
CREATE TABLE inventory (
    id BIGINT PRIMARY KEY,
    product_name VARCHAR(50),
    stock INT
);

INSERT INTO inventory VALUES (1, 'iPhone', 100);
```

**场景1：秒杀场景（必须使用当前读）**

```sql
-- ❌ 错误示范：使用快照读
-- 事务A
START TRANSACTION;
SELECT stock FROM inventory WHERE id = 1;  -- 快照读：stock = 100
-- 假设读取到 stock = 100
UPDATE inventory SET stock = 99 WHERE id = 1;
COMMIT;

-- 事务B（同时执行）
START TRANSACTION;
SELECT stock FROM inventory WHERE id = 1;  -- 快照读：stock = 100
-- 假设读取到 stock = 100（读取的是快照，不是最新数据）
UPDATE inventory SET stock = 99 WHERE id = 1;  -- ❌ 覆盖了事务A的修改
COMMIT;

-- 结果：库存应该是98，但实际是99（数据不一致）
```

```sql
-- ✅ 正确示范：使用当前读
-- 事务A
START TRANSACTION;
SELECT stock FROM inventory WHERE id = 1 FOR UPDATE;  -- 当前读：stock = 100
-- 读取到 stock = 100，并加排他锁
UPDATE inventory SET stock = 99 WHERE id = 1;
COMMIT;

-- 事务B（同时执行）
START TRANSACTION;
SELECT stock FROM inventory WHERE id = 1 FOR UPDATE;  -- 阻塞，等待事务A释放锁
-- 事务A提交后，读取到 stock = 99
UPDATE inventory SET stock = 98 WHERE id = 1;
COMMIT;

-- 结果：库存正确为98 ✅
```

---

**场景2：转账场景（必须使用当前读）**

```sql
-- 准备数据
CREATE TABLE account (
    id BIGINT PRIMARY KEY,
    name VARCHAR(50),
    balance DECIMAL(10, 2)
);

INSERT INTO account VALUES (1, '张三', 1000.00), (2, '李四', 500.00);
```

```sql
-- ❌ 错误示范：使用快照读
-- 事务A：张三转账100给李四
START TRANSACTION;
SELECT balance FROM account WHERE id = 1;  -- 快照读：balance = 1000
UPDATE account SET balance = balance - 100 WHERE id = 1;  -- 当前读
UPDATE account SET balance = balance + 100 WHERE id = 2;  -- 当前读
COMMIT;

-- 事务B：张三转账200给李四（同时执行）
START TRANSACTION;
SELECT balance FROM account WHERE id = 1;  -- 快照读：balance = 1000
UPDATE account SET balance = balance - 200 WHERE id = 1;  -- 当前读
UPDATE account SET balance = balance + 200 WHERE id = 2;  -- 当前读
COMMIT;

-- 问题：SELECT是快照读，可能读取到过期数据
-- 但UPDATE是当前读，会读取最新数据
-- 实际上不会出现数据不一致（因为UPDATE会加锁）
```

```sql
-- ✅ 正确示范：使用当前读
-- 事务A：张三转账100给李四
START TRANSACTION;
SELECT balance FROM account WHERE id = 1 FOR UPDATE;  -- 当前读：balance = 1000
-- 检查余额是否足够
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 事务B：张三转账200给李四（同时执行）
START TRANSACTION;
SELECT balance FROM account WHERE id = 1 FOR UPDATE;  -- 阻塞，等待事务A释放锁
-- 事务A提交后，读取到 balance = 900
-- 检查余额是否足够
UPDATE account SET balance = balance - 200 WHERE id = 1;
UPDATE account SET balance = balance + 200 WHERE id = 2;
COMMIT;

-- 结果：张三余额 = 700，李四余额 = 800 ✅
```

---

### 3.5 当前读的优缺点

#### 优点

```
1. ✅ 读取最新数据
   - 保证数据一致性

2. ✅ 避免幻读
   - 通过锁机制防止其他事务插入数据

3. ✅ 适合写操作
   - UPDATE、DELETE、INSERT必须使用当前读
```

#### 缺点

```
1. ❌ 加锁，低并发
   - 读操作阻塞写操作
   - 写操作阻塞读操作

2. ❌ 可能死锁
   - 多个事务相互等待锁

3. ❌ 性能开销大
   - 锁的获取和释放有开销
```

---

## 四、UPDATE和DELETE是快照读还是当前读？

### 4.1 结论

**UPDATE和DELETE都是当前读**。

**原因**：
1. **必须读取最新数据**：确保修改或删除的是最新版本的数据
2. **必须加锁**：防止其他事务同时修改相同的数据
3. **保证数据一致性**：避免丢失更新

---

### 4.2 UPDATE的当前读过程

```sql
-- 示例
UPDATE product SET stock = stock - 1 WHERE id = 1;
```

**执行步骤**：

```
1. 当前读（读取最新数据）
   ├─ 根据WHERE条件定位到记录（id = 1）
   ├─ 读取当前最新的stock值（例如：100）
   └─ 加排他锁（X锁）

2. 计算新值
   └─ stock - 1 = 99

3. 更新数据
   ├─ 将新值写入数据页
   ├─ 更新DB_TRX_ID（当前事务ID）
   └─ 创建Undo Log（保存旧版本：stock = 100）

4. 释放锁（事务提交时）
   └─ COMMIT
```

---

### 4.3 为什么UPDATE必须是当前读？

**场景：如果UPDATE使用快照读**

```sql
-- 初始数据：stock = 100

-- 事务A
START TRANSACTION;
-- 假设UPDATE使用快照读
UPDATE product SET stock = stock - 1 WHERE id = 1;
-- 读取快照：stock = 100
-- 计算：100 - 1 = 99
-- 更新：stock = 99
COMMIT;

-- 事务B（同时执行）
START TRANSACTION;
-- 假设UPDATE使用快照读
UPDATE product SET stock = stock - 1 WHERE id = 1;
-- 读取快照：stock = 100（读取的是快照，不是最新数据）
-- 计算：100 - 1 = 99
-- 更新：stock = 99  ❌ 覆盖了事务A的修改
COMMIT;

-- 结果：stock = 99（应该是98）
-- 问题：丢失更新（Lost Update）
```

**使用当前读避免丢失更新**：

```sql
-- 初始数据：stock = 100

-- 事务A
START TRANSACTION;
UPDATE product SET stock = stock - 1 WHERE id = 1;
-- 当前读：stock = 100，加排他锁
-- 计算：100 - 1 = 99
-- 更新：stock = 99
COMMIT;

-- 事务B（同时执行）
START TRANSACTION;
UPDATE product SET stock = stock - 1 WHERE id = 1;
-- 阻塞（等待事务A释放锁）
-- 事务A提交后，当前读：stock = 99
-- 计算：99 - 1 = 98
-- 更新：stock = 98
COMMIT;

-- 结果：stock = 98 ✅
```

---

### 4.4 DELETE的当前读过程

```sql
-- 示例
DELETE FROM product WHERE id = 1;
```

**执行步骤**：

```
1. 当前读（读取最新数据）
   ├─ 根据WHERE条件定位到记录（id = 1）
   ├─ 读取当前最新的数据
   └─ 加排他锁（X锁）

2. 删除数据
   ├─ 标记删除（delete mark）
   ├─ 更新DB_TRX_ID（当前事务ID）
   └─ 创建Undo Log（保存旧版本）

3. 释放锁（事务提交时）
   └─ COMMIT

4. 物理删除（后台purge线程）
   └─ 真正删除数据
```

---

### 4.5 为什么DELETE必须是当前读？

**场景：如果DELETE使用快照读**

```sql
-- 初始数据：id = 1, stock = 100

-- 事务A
START TRANSACTION;
-- 假设DELETE使用快照读
DELETE FROM product WHERE id = 1;
-- 读取快照：id = 1存在
-- 删除：标记删除
COMMIT;

-- 事务B（同时执行）
START TRANSACTION;
-- 假设DELETE使用快照读
DELETE FROM product WHERE id = 1;
-- 读取快照：id = 1存在（读取的是快照，不知道已被删除）
-- 删除：标记删除  ❌ 重复删除
COMMIT;

-- 问题：可能导致数据不一致
```

**使用当前读避免问题**：

```sql
-- 初始数据：id = 1, stock = 100

-- 事务A
START TRANSACTION;
DELETE FROM product WHERE id = 1;
-- 当前读：id = 1存在，加排他锁
-- 删除：标记删除
COMMIT;

-- 事务B（同时执行）
START TRANSACTION;
DELETE FROM product WHERE id = 1;
-- 阻塞（等待事务A释放锁）
-- 事务A提交后，当前读：id = 1已被删除
-- 结果：0 rows affected
COMMIT;

-- 结果：正确 ✅
```

---

### 4.6 INSERT的当前读过程

```sql
-- 示例
INSERT INTO product VALUES (2, 'iPad', 50);
```

**执行步骤**：

```
1. 当前读（检查唯一性约束）
   ├─ 检查主键是否存在（id = 2）
   ├─ 检查唯一索引是否冲突
   └─ 加排他锁（X锁）

2. 插入数据
   ├─ 写入数据页
   ├─ 更新索引
   └─ 设置DB_TRX_ID（当前事务ID）

3. 释放锁（事务提交时）
   └─ COMMIT
```

---

## 五、快照读 vs 当前读对比

### 5.1 完整对比表

| 对比项 | 快照读 | 当前读 |
|-------|-------|-------|
| **SQL语句** | `SELECT` | `SELECT ... FOR UPDATE`<br>`SELECT ... LOCK IN SHARE MODE`<br>`UPDATE`<br>`DELETE`<br>`INSERT` |
| **是否加锁** | ❌ 不加锁 | ✅ 加锁（S锁或X锁） |
| **读取数据** | 读取快照版本（历史数据） | 读取最新版本（当前数据） |
| **实现机制** | MVCC（多版本并发控制） | 锁机制 |
| **并发性** | 高（不阻塞写操作） | 低（阻塞其他写操作） |
| **一致性** | 可重复读（REPEATABLE READ） | 强一致性 |
| **适用场景** | 普通查询、报表统计 | 写操作、秒杀、转账 |
| **性能** | 高（无锁开销） | 低（有锁开销） |
| **幻读** | 可能出现（部分场景） | 不会出现（锁机制防止） |

---

### 5.2 隔离级别与快照读/当前读

| 隔离级别 | 快照读行为 | 当前读行为 |
|---------|----------|----------|
| **READ UNCOMMITTED** | 读取最新数据（无MVCC） | 加锁，读取最新数据 |
| **READ COMMITTED** | 每次SELECT创建新ReadView | 加锁，读取最新数据 |
| **REPEATABLE READ** | 第一次SELECT创建ReadView | 加锁，读取最新数据 |
| **SERIALIZABLE** | 所有SELECT都是当前读 | 加锁，读取最新数据 |

---

### 5.3 实战场景选择

```sql
-- 场景1：普通查询（使用快照读）
SELECT * FROM user WHERE age > 18;
-- ✅ 快照读：高并发，不加锁

-- 场景2：统计报表（使用快照读）
SELECT COUNT(*) FROM orders WHERE created_time > '2026-01-01';
-- ✅ 快照读：不影响写操作

-- 场景3：秒杀扣库存（使用当前读）
START TRANSACTION;
SELECT stock FROM product WHERE id = 1 FOR UPDATE;
-- ✅ 当前读：加锁，读取最新数据
UPDATE product SET stock = stock - 1 WHERE id = 1;
COMMIT;

-- 场景4：转账（使用当前读）
START TRANSACTION;
SELECT balance FROM account WHERE id = 1 FOR UPDATE;
-- ✅ 当前读：加锁，防止并发修改
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 场景5：批量更新（使用当前读）
UPDATE user SET status = 1 WHERE age > 18;
-- ✅ 当前读：自动加锁

-- 场景6：批量删除（使用当前读）
DELETE FROM log WHERE created_time < '2025-01-01';
-- ✅ 当前读：自动加锁
```

---

## 六、常见问题

### Q1：为什么普通SELECT是快照读，而UPDATE是当前读？

**A**：因为读和写的需求不同。

```
普通SELECT：
- 目的：查询数据
- 需求：高并发，不阻塞写操作
- 方案：快照读（MVCC）

UPDATE/DELETE：
- 目的：修改数据
- 需求：保证数据一致性，避免丢失更新
- 方案：当前读（加锁）
```

---

### Q2：如何让SELECT变成当前读？

**A**：使用`FOR UPDATE`或`LOCK IN SHARE MODE`。

```sql
-- 方式1：加排他锁（X锁）
SELECT * FROM user WHERE id = 1 FOR UPDATE;

-- 方式2：加共享锁（S锁）
SELECT * FROM user WHERE id = 1 LOCK IN SHARE MODE;
SELECT * FROM user WHERE id = 1 FOR SHARE;  -- MySQL 8.0+

-- 方式3：SERIALIZABLE隔离级别（所有SELECT都是当前读）
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM user WHERE id = 1;  -- 自动加锁
```

---

### Q3：快照读会读取到未提交的数据吗？

**A**：不会（在READ COMMITTED及以上隔离级别）。

```sql
-- 事务A
START TRANSACTION;
UPDATE user SET age = 30 WHERE id = 1;
-- 未提交

-- 事务B
START TRANSACTION;
SELECT age FROM user WHERE id = 1;
-- 结果：age = 20（读取的是旧版本，不是未提交的30）

-- 原因：ReadView的可见性判断
-- 事务A的事务ID在m_ids中（活跃事务列表）
-- 所以事务B看不到事务A的修改
```

---

### Q4：当前读会阻塞快照读吗？

**A**：不会。

```sql
-- 事务A（当前读）
START TRANSACTION;
SELECT * FROM user WHERE id = 1 FOR UPDATE;
-- 加排他锁

-- 事务B（快照读）
START TRANSACTION;
SELECT * FROM user WHERE id = 1;
-- ✅ 不阻塞（快照读不需要加锁）

-- 事务C（当前读）
START TRANSACTION;
SELECT * FROM user WHERE id = 1 FOR UPDATE;
-- ❌ 阻塞（等待事务A释放锁）
```

---

### Q5：如何查看当前事务的ReadView？

**A**：无法直接查看，但可以通过行为推断。

```sql
-- 查看事务隔离级别
SELECT @@transaction_isolation;

-- 查看当前活跃的事务
SELECT * FROM information_schema.innodb_trx;

-- 查看锁信息
SELECT * FROM performance_schema.data_locks;

-- 查看锁等待
SELECT * FROM performance_schema.data_lock_waits;
```

---

### Q6：UPDATE的WHERE条件会使用快照读吗？

**A**：不会，WHERE条件的查找也是当前读。

```sql
UPDATE user SET age = 30 WHERE name = '张三';

-- 执行过程：
-- 1. 当前读：根据WHERE条件（name = '张三'）查找记录
-- 2. 加排他锁
-- 3. 更新数据

-- 如果WHERE条件使用快照读，可能找不到最新插入的记录
```

---

## 七、总结

### 核心要点

```
1. 快照读（Snapshot Read）：
   - 定义：读取历史版本数据（MVCC）
   - 典型操作：普通SELECT
   - 特点：不加锁，高并发
   - 适用场景：普通查询、报表统计

2. 当前读（Current Read）：
   - 定义：读取最新版本数据（加锁）
   - 典型操作：SELECT ... FOR UPDATE、UPDATE、DELETE、INSERT
   - 特点：加锁，强一致性
   - 适用场景：写操作、秒杀、转账

3. UPDATE和DELETE：
   - ✅ 都是当前读
   - ✅ 必须读取最新数据
   - ✅ 必须加锁
   - ✅ 保证数据一致性
```

### 记忆口诀

```
普通SELECT快照读，历史版本不加锁
FOR UPDATE当前读，最新数据要加锁
UPDATE DELETE都当前，避免丢失更新错
INSERT也是当前读，唯一约束要检查
快照读取高并发，当前读取强一致
根据场景来选择，性能一致两兼顾
```

### 决策树

```
需要读取数据？
├─ 只是查询，不修改
│  ├─ 需要最新数据？
│  │  ├─ 是 → SELECT ... FOR UPDATE（当前读）
│  │  └─ 否 → SELECT（快照读）
│  └─ 高并发场景 → SELECT（快照读）
│
└─ 需要修改数据
   ├─ UPDATE → 当前读（自动加锁）
   ├─ DELETE → 当前读（自动加锁）
   └─ INSERT → 当前读（自动加锁）
```

**最终答案：UPDATE和DELETE都是当前读，必须读取最新版本的数据并加锁，以保证数据一致性，避免丢失更新。**
