# ziplist 压缩列表详解

> **核心问题**：为什么 ziplist 能节省 60%-90% 的内存？它是如何做到的？

## 一、为什么需要 ziplist？

### 问题 1：传统 hashtable 的内存浪费在哪里？

假设我们要存储一个简单的用户信息：`name="Tom", age=25`

**使用 hashtable 的内存开销：**

```
┌─────────────────────────────────────────────────────────────┐
│                    redisObject (16 字节)                     │
├─────────────────────────────────────────────────────────────┤
│                      dict (124 字节)                         │
│  - dictType*: 8 字节                                         │
│  - privdata*: 8 字节                                         │
│  - dictht[2]: 96 字节                                        │
│  - rehashidx: 8 字节                                         │
│  - iterators: 4 字节                                         │
├─────────────────────────────────────────────────────────────┤
│                   dictEntry #1 (24 字节)                     │
│  key* → SDS("name", 9字节) → "Tom" (8字节)                   │
├─────────────────────────────────────────────────────────────┤
│                   dictEntry #2 (24 字节)                     │
│  key* → SDS("age", 8字节) → "25" (8字节)                     │
├─────────────────────────────────────────────────────────────┤
│                  哈希表数组 (32 字节)                         │
└─────────────────────────────────────────────────────────────┘

总计：16 + 124 + 48 + 33 + 32 = 253 字节
```

**问题分析：**
- ❌ **指针开销巨大**：每个 dictEntry 有 3 个指针（key、value、next），每个 8 字节 = 24 字节
- ❌ **结构体开销**：dict、dictht、dictEntry 等结构体本身占用大量空间
- ❌ **SDS 头部开销**：每个字符串都有 5-9 字节的头部（len、alloc、flags）
- ❌ **内存对齐**：结构体需要内存对齐，浪费空间

**核心矛盾**：存储 2 个字段（实际数据 < 20 字节），却需要 253 字节！

### 问题 2：能否用连续内存块代替指针？

**答案：可以！这就是 ziplist 的核心思想**

```
ziplist 存储同样的数据：
┌────────┬────────┬────────┬──────┬─────┬─────┬────┬────────┐
│zlbytes │zltail  │ zllen  │ name │ Tom │ age │ 25 │ zlend  │
└────────┴────────┴────────┴──────┴─────┴─────┴────┴────────┘
  4字节    4字节    2字节    6字节  5字节  5字节 3字节  1字节

总计：30 字节

节省：(253 - 30) / 253 = 88.1%
```

**关键优势：**
- ✅ **无指针**：连续内存，不需要指针
- ✅ **无结构体开销**：只有必要的元数据
- ✅ **紧凑编码**：整数直接存储，不转字符串
- ✅ **按需分配**：根据数据大小动态调整

---

## 二、ziplist 的内存布局

### 问题 3：ziplist 如何组织数据？

```
ziplist 整体结构（连续内存块）
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│ zlbytes │ zltail  │  zllen  │ entry1  │ entry2  │   ...   │  zlend  │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
  4字节      4字节     2字节      变长      变长                1字节
  
  总字节数   尾节点    节点      第一个    第二个              结束标记
            偏移量    数量      节点      节点                (0xFF)
```

**字段详解：**

| 字段 | 大小 | 作用 | 为什么需要？ |
|------|------|------|-------------|
| `zlbytes` | 4字节 | 记录整个 ziplist 的字节数 | 内存重分配时需要知道总大小 |
| `zltail` | 4字节 | 记录到尾节点的偏移量 | 支持 O(1) 定位尾部（RPUSH、RPOP） |
| `zllen` | 2字节 | 记录节点数量（最大 65535） | 快速获取长度（HLEN） |
| `entry` | 变长 | 实际存储的数据节点 | 存储 key-value |
| `zlend` | 1字节 | 结束标记（固定 0xFF） | 标识 ziplist 结束 |

**实际示例：**

```c
存储 Hash：name="Alice", age=25, city="Beijing"

ziplist 内存布局：
┌────┬────┬────┬──────┬───────┬─────┬────┬──────┬─────────┬────┐
│ 47 │ 36 │ 6  │ name │ Alice │ age │ 25 │ city │ Beijing │0xFF│
└────┴────┴────┴──────┴───────┴─────┴────┴──────┴─────────┴────┘
 总47  尾36  6个   key1   val1   key2  val2  key3    val3    结束
 字节  偏移  节点

说明：
- zlbytes = 47：整个 ziplist 占 47 字节
- zltail = 36：从起始位置偏移 36 字节到达尾节点（"Beijing"）
- zllen = 6：共 6 个节点（3 个 key + 3 个 value）
```

---

## 三、entry 节点的精妙设计

### 问题 4：如何在连续内存中实现双向遍历？

**挑战**：数组只能单向遍历，如何支持从后向前遍历（如 RPOP）？

**解决方案**：每个节点记录前一个节点的长度！

```
单个 entry 节点结构
┌──────────────────┬──────────────┬──────────────┐
│ previous_entry   │   encoding   │   content    │
│     _length      │              │              │
└──────────────────┴──────────────┴──────────────┘
   1-5字节             1-5字节         变长

① previous_entry_length：前一个节点的长度（用于反向遍历）
② encoding：编码类型和长度信息
③ content：实际存储的数据
```

**为什么这样设计？**

```
正向遍历：
当前位置 + encoding长度 + content长度 = 下一个节点位置

反向遍历：
当前位置 - previous_entry_length = 前一个节点位置

示例：
┌────┬────┬──────┬────┬────┬─────┐
│ 0  │ 1  │ name │ 6  │ 1  │ Tom │
└────┴────┴──────┴────┴────┴─────┘
 prev enc content  prev enc content
  ↑                 ↑
  第1个节点          第2个节点

从第2个节点反向遍历：
- 读取 previous_entry_length = 6
- 当前位置 - 6 = 第1个节点位置
```

### 问题 5：previous_entry_length 为什么是 1-5 字节？

**核心思想：按需分配，节省空间**

```c
情况 1：前一个节点 < 254 字节（大多数情况）
┌────┐
│ 50 │  ← 1 字节就够了
└────┘
previous_entry_length = 0x32（50 的十六进制）

情况 2：前一个节点 >= 254 字节（少数情况）
┌────┬────┬────┬────┬────┐
│0xFE│0x2C│0x01│0x00│0x00│  ← 需要 5 字节
└────┴────┴────┴────┴────┘
  标识  实际长度（小端序）= 300

为什么是 254 而不是 255？
- 0xFF 被用作 ziplist 结束标记
- 0xFE 被用作 "长度需要 5 字节" 的标识符
- 所以 0-253 用 1 字节，254+ 用 5 字节
```

**优化效果：**

```
假设 100 个节点，每个节点 < 254 字节：

hashtable 方式：
- 每个 dictEntry 有 next 指针：8 字节
- 总开销：100 × 8 = 800 字节

ziplist 方式：
- 每个节点 previous_entry_length：1 字节
- 总开销：100 × 1 = 100 字节

节省：(800 - 100) / 800 = 87.5%
```

### 问题 6：encoding 如何实现极致压缩？

**核心技巧：根据数据类型和大小选择最优编码**

#### 技巧 1：整数不转字符串，直接存储

```
hashtable 方式存储 age=25：
┌─────────────────────────────┐
│ SDS header (5字节)           │
│ content: "25" (2字节)        │  ← 字符串形式
└─────────────────────────────┘
总计：7 字节

ziplist 方式存储 age=25：
┌────┬────┐
│0xFE│ 25 │  ← 直接存储整数
└────┴────┘
 enc  value
总计：2 字节

节省：(7 - 2) / 7 = 71.4%
```

**整数编码表：**

| 编码值 | 类型 | 大小 | 范围 | 实际案例 |
|--------|------|------|------|----------|
| `11111110` | int8_t | 1字节 | -128 ~ 127 | age: 25, status: 1 |
| `11000000` | int16_t | 2字节 | -32768 ~ 32767 | score: 8500 |
| `11110000` | int24_t | 3字节 | -8388608 ~ 8388607 | price: 999999 |
| `11010000` | int32_t | 4字节 | -2^31 ~ 2^31-1 | count: 1000000 |
| `11100000` | int64_t | 8字节 | -2^63 ~ 2^63-1 | timestamp: 1642838400 |
| `1111xxxx` | 4位整数 | **0字节** | 0 ~ 12 | flag: 5（直接存在 encoding 中！） |

**极致优化**：0-12 的整数直接存储在 encoding 字节中，content 为空！

```
存储 flag=5：
┌────────┐
│11110101│  ← encoding = 0xF5，后 4 位 0101 = 5
└────────┘
总计：1 字节（包含 previous_entry_length）

hashtable 存储同样的数据：24 + 9 + 6 = 39 字节
节省：97.4%！
```

#### 技巧 2：字符串按长度分级编码

**为什么需要分级？**

```
如果所有字符串都用 5 字节存储长度：
- 存储 "Tom"（3 字节）需要 5 字节头部 → 浪费
- 存储 10000 字节的文本需要 5 字节头部 → 合理

解决方案：根据字符串长度选择编码
```

**字符串编码表：**

| 编码格式 | 长度范围 | 头部大小 | 适用场景 | 示例 |
|---------|---------|---------|---------|------|
| `00xxxxxx` | ≤ 63 字节 | 1字节 | 短字符串（名字、城市） | "Tom", "Beijing" |
| `01xxxxxx xxxxxxxx` | ≤ 16383 字节 | 2字节 | 中等字符串（描述） | 商品描述 |
| `10xxxxxx` + 4字节 | ≤ 4GB | 5字节 | 长字符串（文章） | 博客内容 |

**实际案例：**

```
存储 "Tom"（3 字节）：
┌────────┬───┬───┬───┐
│00000011│ T │ o │ m │  ← encoding = 0x03（长度 3）
└────────┴───┴───┴───┘
   1字节   3字节
总计：4 字节

存储 "Beijing"（7 字节）：
┌────────┬───┬───┬───┬───┬───┬───┬───┐
│00000111│ B │ e │ i │ j │ i │ n │ g │  ← encoding = 0x07
└────────┴───┴───┴───┴───┴───┴───┴───┘
   1字节   7字节
总计：8 字节

hashtable 存储 "Tom"：24 + 9 + 3 = 36 字节
ziplist 存储 "Tom"：4 字节
节省：88.9%
```

### 问题 7：完整示例 - 如何存储一个 Hash？

**场景**：存储 `HSET user:1 name "Alice" age "25" city "Beijing"`

#### 步骤 1：分析数据类型

```
name: "Alice" → 字符串，5 字节
age: "25" → 可以转为整数 25
city: "Beijing" → 字符串，7 字节
```

#### 步骤 2：选择最优编码

```
entry1: "name" (key)
- previous_entry_length: 0（第一个节点）
- encoding: 0x04（字符串长度 4）
- content: "name"
- 总大小：1 + 1 + 4 = 6 字节

entry2: "Alice" (value)
- previous_entry_length: 6（前一个节点 6 字节）
- encoding: 0x05（字符串长度 5）
- content: "Alice"
- 总大小：1 + 1 + 5 = 7 字节

entry3: "age" (key)
- previous_entry_length: 7
- encoding: 0x03（字符串长度 3）
- content: "age"
- 总大小：1 + 1 + 3 = 5 字节

entry4: 25 (value，整数优化！)
- previous_entry_length: 5
- encoding: 0xFE（int8_t）
- content: 25
- 总大小：1 + 1 + 1 = 3 字节  ← 注意：不是 "25" 字符串！

entry5: "city" (key)
- previous_entry_length: 3
- encoding: 0x04
- content: "city"
- 总大小：1 + 1 + 4 = 6 字节

entry6: "Beijing" (value)
- previous_entry_length: 6
- encoding: 0x07
- content: "Beijing"
- 总大小：1 + 1 + 7 = 9 字节
```

#### 步骤 3：完整内存布局

```
┌────┬────┬────┬──────────┬───────────┬─────────┬────────┬──────────┬───────────┬────┐
│zlby│zltl│zlln│  entry1  │  entry2   │ entry3  │ entry4 │  entry5  │  entry6   │zlnd│
│tes │    │    │          │           │         │        │          │           │    │
├────┼────┼────┼──────────┼───────────┼─────────┼────────┼──────────┼───────────┼────┤
│ 47 │ 36 │ 6  │0│4│name  │6│5│Alice  │7│3│age  │5│FE│25 │3│4│city  │6│7│Beijing│0xFF│
└────┴────┴────┴──────────┴───────────┴─────────┴────────┴──────────┴───────────┴────┘
  4B  4B  2B     6B          7B          5B        3B        6B          9B       1B

总计：4 + 4 + 2 + (6+7+5+3+6+9) + 1 = 47 字节
```

**对比 hashtable：**

```
hashtable 存储同样的数据：
- redisObject: 16 字节
- dict: 124 字节
- dictEntry × 3: 72 字节
- key SDS × 3: 27 字节
- value SDS × 3: 27 字节
- 哈希表数组: 32 字节
总计：298 字节

ziplist: 47 字节

节省：(298 - 47) / 298 = 84.2%
```

## 三、Hash 在 ziplist 中的存储方式

### 3.1 存储规则

Hash 的 key-value 对在 ziplist 中**紧邻存储**：

```
存储顺序：key1, value1, key2, value2, key3, value3, ...
```

### 3.2 实际示例

```bash
HSET user:1 name "Alice" age "25" city "Beijing"
```

**ziplist 内存布局：**

```
┌────────┬────────┬────────┬──────┬────────┬────────┬────────┬────────┬────────┬────────┬────────┐
│ header │  name  │ Alice  │ age  │   25   │  city  │Beijing │  ...   │  zlend │
└────────┴────────┴────────┴──────┴────────┴────────┴────────┴────────┴────────┴────────┴────────┘
  zlbytes  entry1   entry2  entry3  entry4   entry5   entry6
  zltail    key1    value1   key2   value2    key3    value3
  zllen
```

**详细分析：**

```
entry1: "name"
  - previous_entry_length = 0（第一个）
  - encoding = 0x04（字符串长度 4）
  - content = "name"
  - 总大小：1 + 1 + 4 = 6 字节

entry2: "Alice"
  - previous_entry_length = 6（前一个节点 6 字节）
  - encoding = 0x05（字符串长度 5）
  - content = "Alice"
  - 总大小：1 + 1 + 5 = 7 字节

entry3: "age"
  - previous_entry_length = 7
  - encoding = 0x03
  - content = "age"
  - 总大小：1 + 1 + 3 = 5 字节

entry4: 25（整数）
  - previous_entry_length = 5
  - encoding = 0xFE（int8_t）
  - content = 25
  - 总大小：1 + 1 + 1 = 3 字节

entry5: "city"
  - previous_entry_length = 3
  - encoding = 0x04
  - content = "city"
  - 总大小：1 + 1 + 4 = 6 字节

entry6: "Beijing"
  - previous_entry_length = 6
  - encoding = 0x07
  - content = "Beijing"
  - 总大小：1 + 1 + 7 = 9 字节
```

### 3.3 查找过程

```bash
HGET user:1 city
```

**查找步骤：**
1. 从 ziplist 头部开始遍历
2. 读取 entry1（"name"），不匹配，跳过 entry2
3. 读取 entry3（"age"），不匹配，跳过 entry4
4. 读取 entry5（"city"），**匹配**！
5. 返回 entry6（"Beijing"）

**时间复杂度：O(N)**，N 为字段数量

---

## 五、ziplist 的代价：性能权衡

### 4.1 核心原因

#### 1. 连续内存，无指针开销

```
hashtable 方式：
┌──────────┐    ┌──────────┐    ┌──────────┐
│ dictEntry│───→│   SDS    │───→│  value   │
│  24字节  │    │  9字节   │    │  6字节   │
└──────────┘    └──────────┘    └──────────┘
总计：24 + 9 + 6 = 39 字节（仅存储一个 key-value）

ziplist 方式：
┌──────────────────────────┐
│  key(7字节) + value(7字节) │
└──────────────────────────┘
总计：14 字节（存储一个 key-value）

节省：(39 - 14) / 39 = 64%
```

#### 2. 紧凑编码，按需分配

```
存储整数 25：

hashtable：
  - dictEntry: 24 字节
  - SDS header: 9 字节
  - content: "25"（2 字节）
  - 总计：35 字节

ziplist：
  - previous_entry_length: 1 字节
  - encoding: 1 字节（int8_t）
  - content: 1 字节
  - 总计：3 字节

节省：(35 - 3) / 35 = 91%
```

#### 3. 无额外结构开销

```
hashtable 需要的额外结构：
  - dictEntry: 24 字节
    - key 指针: 8 字节
    - value 指针: 8 字节
    - next 指针: 8 字节
  - SDS header: 9 字节
    - len: 4 字节
    - alloc: 4 字节
    - flags: 1 字节

ziplist 无需额外结构：
  - 只有必要的 previous_entry_length 和 encoding
  - 总开销：2-10 字节（根据数据大小）
```

### 4.2 详细对比

存储 3 个字段的 Hash：`name="Alice", age="25", city="Beijing"`

#### hashtable 方式

```
redisObject: 16 字节
dict: 96 字节
  - dictht[2]: 48 字节
  - rehashidx: 8 字节
  - iterators: 8 字节
  - 其他: 32 字节

dictEntry × 3: 72 字节
  - dictEntry: 24 × 3 = 72 字节

key SDS × 3: 27 字节
  - "name": 9 字节
  - "age": 9 字节
  - "city": 9 字节

value SDS × 3: 27 字节
  - "Alice": 9 字节
  - "25": 9 字节
  - "Beijing": 9 字节

总计：16 + 96 + 72 + 27 + 27 = 238 字节
```

#### ziplist 方式

```
redisObject: 16 字节
ziplist header: 11 字节
  - zlbytes: 4 字节
  - zltail: 4 字节
  - zllen: 2 字节
  - zlend: 1 字节

entries × 6: 36 字节
  - "name": 6 字节
  - "Alice": 7 字节
  - "age": 5 字节
  - "25": 3 字节
  - "city": 6 字节
  - "Beijing": 9 字节

总计：16 + 11 + 36 = 63 字节
```

**节省比例：(238 - 63) / 238 = 73.5%**

### 问题 10：ziplist 有什么缺点？

天下没有免费的午餐，ziplist 节省内存的代价是什么？

#### 缺点 1：查询慢 - O(N) 复杂度

**场景**：`HGET user:1 city`

```
hashtable 查询：
1. 计算 hash("city") = 0x1234
2. 定位桶：index = 0x1234 & sizemask
3. 遍历链表（通常只有 1-2 个节点）
4. 找到返回

时间复杂度：O(1)

ziplist 查询：
1. 从头部开始遍历
2. 读取 entry1："name" → 不匹配，跳过 "Alice"
3. 读取 entry3："age" → 不匹配，跳过 "25"
4. 读取 entry5："city" → 匹配！返回 "Beijing"

时间复杂度：O(N)，N 为字段数
```

**性能影响：**

| 字段数 | ziplist | hashtable | 差异 |
|-------|---------|-----------|------|
| 10 | 0.05ms | 0.01ms | **5倍** |
| 50 | 0.25ms | 0.01ms | **25倍** |
| 100 | 0.50ms | 0.01ms | **50倍** |
| 500 | 2.50ms | 0.01ms | **250倍** |

**结论**：字段数越多，ziplist 性能下降越明显！

#### 缺点 2：更新慢 - 需要移动内存

**场景**：`HSET user:1 email "tom@example.com"`（插入新字段）

```
hashtable 更新：
1. 计算 hash("email")
2. 分配 dictEntry(24B) + SDS(9B) + SDS(20B)
3. 插入链表头部

时间复杂度：O(1)
内存操作：只分配新内存

ziplist 更新：
1. 计算新节点大小：20B
2. realloc 扩展 ziplist：47B → 67B
3. 移动后续所有节点（如果插入中间）
4. 写入新数据
5. 更新 zlbytes、zltail、zllen

时间复杂度：O(N)
内存操作：需要 memmove！
```

**性能影响：**

| 操作 | ziplist | hashtable | 差异 |
|------|---------|-----------|------|
| HSET（头部） | 0.10ms | 0.02ms | **5個** |
| HSET（尾部） | 0.05ms | 0.02ms | **2.5個** |
| HDEL（头部） | 0.15ms | 0.02ms | **7.5個** |
| HDEL（中间） | 0.20ms | 0.02ms | **10個** |

#### 缺点 3：连锁更新风险

**什么是连锁更新？**

```
场景：插入一个 254 字节的节点

原始 ziplist：
┌────┬────┬────┬────┐
│ 50 │ 50 │ 50 │ 50 │  ← 每个节点 50 字节
└────┴────┴────┴────┘
  prev_len = 1 字节

插入 254 字节节点后：
┌─────┬────┬────┬────┬────┐
│ 254 │ 50 │ 50 │ 50 │ 50 │
└─────┴────┴────┴────┴────┘
         ↑
   prev_len 需要从 1 字节扩展到 5 字节
   导致该节点从 50 字节变成 54 字节
         ↓
   触发下一个节点的 prev_len 扩展
         ↓
   连锁反应...

最坏情况：O(N²) 复杂度
```

**实际影响：**
- 触发概率低：需要多个节点恰好在 250-253 字节
- Redis 默认 entries < 512，影响有限
- 即使触发，实际耗时 < 10ms

### 问题 11：何时使用 ziplist？

**决策树：**

```
内存紧张？
  ↓ 是
字段数 < 100？
  ↓ 是
值大小 < 64字节？
  ↓ 是
QPS < 5000？
  ↓ 是
读多写少？
  ↓ 是
【选择 ziplist】
  ↓ 否
【选择 hashtable】
```

**适用场景：**

| 场景 | 是否适合 | 原因 |
|------|---------|------|
| 用户基本信息 | ✅ 非常适合 | 字段少、值小、读多写少 |
| 商品属性 | ✅ 非常适合 | 字段少、值小、读多写少 |
| 配置信息 | ✅ 适合 | 字段少、读多写少 |
| 购物车 | ❌ 不适合 | 字段动态增长、频繁更新 |
| 会话数据 | ❌ 不适合 | 字段多、值大 |
| 用户画像 | ❌ 不适合 | 字段多（标签） |

---

## 六、总结与最佳实践

### 核心要点

| 优点 | 说明 | 收益 |
|------|------|------|
| **内存占用低** | 连续内存，无指针 | 节省 60%-90% |
| **缓存友好** | 连续内存，CPU 缓存命中率高 | 提升 20%-30% 性能 |
| **简单高效** | 结构简单，易于实现 | 代码维护成本低 |

### 性能权衡

| 缺点 | 说明 | 影响 |
|------|------|------|
| **查询慢** | O(N) 遍历 | 字段多时性能差 |
| **更新慢** | 需要移动内存 | 频繁更新时性能差 |
| **连锁更新** | 可能触发多次内存重分配 | 极端情况下性能抖动 |

### 最佳实践

```
1. 控制字段数量
   - 建议 < 100 个字段
   - 超过 512 会自动转 hashtable

2. 控制值大小
   - 建议 < 64 字节
   - 超过 64 会自动转 hashtable

3. 避免频繁更新
   - 读多写少场景
   - 批量更新而非逐个更新

4. 监控编码转换
   - 定期检查 OBJECT ENCODING
   - 发现异常及时处理
```

### 连锁更新问题

```
场景：插入一个 254 字节的节点

原始 ziplist：
┌────┬────┬────┬────┐
│ 50 │ 50 │ 50 │ 50 │  ← 每个节点 50 字节
└────┴────┴────┴────┘
  prev_len = 1 字节

插入 254 字节节点后：
┌─────┬────┬────┬────┬────┐
│ 254 │ 50 │ 50 │ 50 │ 50 │
└─────┴────┴────┴────┴────┘
         ↑
   prev_len 需要从 1 字节扩展到 5 字节
   导致该节点从 50 字节变成 54 字节
         ↓
   触发下一个节点的 prev_len 扩展
         ↓
   连锁反应...

最坏情况：所有节点都需要扩展，O(N²) 复杂度
```

**Redis 的优化：**
- 默认配置下很少触发（字段数 < 512）
- 即使触发，影响也有限（节点数量少）

### 关键数据

```
内存节省：60%-90%
平均节省：80%
查询性能：O(N) vs O(1)
更新性能：2-10 倍差异
适用场景：小对象、读多写少
```
