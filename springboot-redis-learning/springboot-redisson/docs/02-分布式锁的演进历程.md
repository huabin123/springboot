# 02-分布式锁的演进历程

## 一、数据库实现分布式锁

### 问题1：如何用数据库实现分布式锁？

数据库是最容易想到的分布式锁实现方案，因为它天然支持事务和唯一约束。

#### 方案1：基于唯一索引

**表结构设计**：

```sql
CREATE TABLE `distributed_lock` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `lock_key` varchar(64) NOT NULL COMMENT '锁的唯一标识',
  `lock_value` varchar(64) NOT NULL COMMENT '锁持有者标识',
  `expire_time` datetime NOT NULL COMMENT '过期时间',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_lock_key` (`lock_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**加锁实现**：

```java
public class DatabaseLock {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    /**
     * 尝试获取锁
     */
    public boolean tryLock(String lockKey, String lockValue, int expireSeconds) {
        String sql = "INSERT INTO distributed_lock (lock_key, lock_value, expire_time) " +
                     "VALUES (?, ?, DATE_ADD(NOW(), INTERVAL ? SECOND))";
        try {
            int rows = jdbcTemplate.update(sql, lockKey, lockValue, expireSeconds);
            return rows > 0;
        } catch (DuplicateKeyException e) {
            // 锁已被占用
            return false;
        }
    }
    
    /**
     * 释放锁
     */
    public boolean unlock(String lockKey, String lockValue) {
        String sql = "DELETE FROM distributed_lock WHERE lock_key = ? AND lock_value = ?";
        int rows = jdbcTemplate.update(sql, lockKey, lockValue);
        return rows > 0;
    }
    
    /**
     * 清理过期锁（定时任务）
     */
    @Scheduled(fixedRate = 5000)
    public void cleanExpiredLocks() {
        String sql = "DELETE FROM distributed_lock WHERE expire_time < NOW()";
        jdbcTemplate.update(sql);
    }
}
```

**优点**：
- ✅ 简单易懂，不需要引入额外组件
- ✅ 利用数据库事务保证原子性
- ✅ 利用唯一索引保证互斥性

**缺点**：
- ❌ 性能差：每次加锁都要写数据库
- ❌ 单点故障：数据库挂了锁服务就不可用
- ❌ 死锁风险：需要定时任务清理过期锁
- ❌ 不支持阻塞等待：只能轮询尝试

---

#### 方案2：基于悲观锁（FOR UPDATE）

```java
public class DatabasePessimisticLock {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Transactional
    public void executeWithLock(String lockKey, Runnable task) {
        // 1. 查询并锁定记录
        String sql = "SELECT * FROM distributed_lock WHERE lock_key = ? FOR UPDATE";
        jdbcTemplate.queryForMap(sql, lockKey);
        
        try {
            // 2. 执行业务逻辑
            task.run();
        } finally {
            // 3. 事务提交后自动释放锁
        }
    }
}
```

**优点**：
- ✅ 利用数据库行锁，自动释放
- ✅ 不需要手动清理

**缺点**：
- ❌ 必须在事务中使用
- ❌ 长事务会导致锁持有时间过长
- ❌ 性能更差（需要维护事务）

---

### 问题2：数据库锁的性能瓶颈在哪里？

**压测对比**：

```
场景：1000个并发请求获取锁
数据库锁：
  - TPS: 500-1000
  - 平均响应时间: 50-100ms
  - 数据库CPU: 80%+

Redis锁：
  - TPS: 10000-50000
  - 平均响应时间: 1-5ms
  - Redis CPU: 20%
```

**瓶颈分析**：

1. **磁盘IO**：数据库写操作需要刷盘
2. **锁竞争**：数据库本身的锁机制（表锁、行锁）
3. **网络开销**：数据库协议比Redis协议重
4. **事务开销**：ACID 保证需要额外开销

---

## 二、Zookeeper 实现分布式锁

### 问题3：Zookeeper 如何实现分布式锁？

Zookeeper 基于**临时顺序节点**实现分布式锁，是一种天然支持分布式协调的方案。

#### 核心原理

```
/locks
  ├── lock_0000000001  (临时顺序节点，客户端A创建)
  ├── lock_0000000002  (临时顺序节点，客户端B创建)
  └── lock_0000000003  (临时顺序节点，客户端C创建)

规则：
1. 序号最小的节点持有锁
2. 其他节点监听前一个节点的删除事件
3. 节点删除时，下一个节点获得锁
```

#### 实现代码

```java
public class ZookeeperLock {
    
    private final CuratorFramework client;
    private final String lockPath = "/locks/my_lock";
    
    public ZookeeperLock(String zkAddress) {
        this.client = CuratorFrameworkFactory.builder()
                .connectString(zkAddress)
                .retryPolicy(new ExponentialBackoffRetry(1000, 3))
                .build();
        this.client.start();
    }
    
    /**
     * 获取锁（阻塞）
     */
    public void lock() throws Exception {
        // 创建临时顺序节点
        String nodePath = client.create()
                .creatingParentsIfNeeded()
                .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
                .forPath(lockPath + "/lock_");
        
        while (true) {
            // 获取所有子节点
            List<String> children = client.getChildren().forPath(lockPath);
            Collections.sort(children);
            
            // 判断当前节点是否是最小的
            String currentNode = nodePath.substring(nodePath.lastIndexOf("/") + 1);
            if (currentNode.equals(children.get(0))) {
                // 获取锁成功
                return;
            }
            
            // 找到前一个节点
            int index = children.indexOf(currentNode);
            String prevNode = children.get(index - 1);
            
            // 监听前一个节点的删除事件
            CountDownLatch latch = new CountDownLatch(1);
            client.getData()
                    .usingWatcher((Watcher) event -> {
                        if (event.getType() == Watcher.Event.EventType.NodeDeleted) {
                            latch.countDown();
                        }
                    })
                    .forPath(lockPath + "/" + prevNode);
            
            // 等待前一个节点释放锁
            latch.await();
        }
    }
    
    /**
     * 释放锁
     */
    public void unlock(String nodePath) throws Exception {
        client.delete().forPath(nodePath);
    }
}
```

**使用示例**：

```java
ZookeeperLock lock = new ZookeeperLock("localhost:2181");
String nodePath = null;
try {
    nodePath = lock.lock();
    // 执行业务逻辑
    System.out.println("获取锁成功，执行业务");
} finally {
    if (nodePath != null) {
        lock.unlock(nodePath);
    }
}
```

---

### 问题4：Zookeeper 锁的优缺点是什么？

#### 优点

1. **强一致性**
   - 基于 ZAB 协议（类似 Paxos）
   - 保证数据的强一致性
   - 适合对一致性要求极高的场景

2. **自动释放**
   - 临时节点在客户端断开连接后自动删除
   - 天然防死锁

3. **公平锁**
   - 基于顺序节点，先到先得
   - 避免饥饿问题

4. **事件通知**
   - Watch 机制，锁释放时主动通知
   - 避免无效的轮询

#### 缺点

1. **性能一般**
   ```
   Zookeeper 单机 TPS: 1万左右
   Redis 单机 TPS: 10万+
   ```

2. **复杂度高**
   - 需要部署 Zookeeper 集群（至少3个节点）
   - 运维成本高

3. **网络开销大**
   - 每次加锁都要创建节点
   - Watch 机制需要维护长连接

4. **不适合高频场景**
   - 秒杀、抢购等高并发场景性能不足

---

### 问题5：Zookeeper vs 数据库，如何选择？

| 维度 | Zookeeper | 数据库 |
|------|-----------|--------|
| **性能** | 中等（1万 TPS） | 差（1千 TPS） |
| **一致性** | 强一致性 | 强一致性 |
| **可用性** | 高（集群部署） | 中（主从复制） |
| **复杂度** | 高 | 低 |
| **自动释放** | 支持（临时节点） | 需要定时任务 |
| **公平性** | 支持（顺序节点） | 不支持 |
| **适用场景** | 配置中心、服务发现 | 简单业务场景 |

**选择建议**：
- 如果已经使用了 Zookeeper（如 Dubbo），可以复用
- 如果对一致性要求极高，选择 Zookeeper
- 如果追求性能，选择 Redis

---

## 三、Redis 实现分布式锁

### 问题6：Redis 分布式锁的演进过程是怎样的？

#### 版本1：SETNX + EXPIRE（错误示范）

```java
public class RedisLockV1 {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public boolean lock(String key, String value, int expireSeconds) {
        // 步骤1：尝试设置key
        Boolean success = redisTemplate.opsForValue().setIfAbsent(key, value);
        if (Boolean.TRUE.equals(success)) {
            // 步骤2：设置过期时间
            redisTemplate.expire(key, expireSeconds, TimeUnit.SECONDS);
            return true;
        }
        return false;
    }
}
```

**问题**：两步操作不是原子的

```
时刻T1: SETNX 成功
时刻T2: 进程崩溃（EXPIRE 未执行）
结果: 锁永远不会过期 → 死锁
```

---

#### 版本2：SET NX EX（基本可用）

```java
public class RedisLockV2 {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    public boolean lock(String key, String value, int expireSeconds) {
        // 原子操作：SET key value NX EX seconds
        Boolean success = redisTemplate.opsForValue()
                .setIfAbsent(key, value, expireSeconds, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
    
    public void unlock(String key) {
        redisTemplate.delete(key);
    }
}
```

**问题1**：可能删除别人的锁

```
时刻T1: 客户端A获取锁，设置30秒过期
时刻T2: 客户端A执行业务，耗时35秒
时刻T3: 锁过期，客户端B获取锁
时刻T4: 客户端A执行完毕，删除锁（删除了B的锁！）
```

**问题2**：不支持可重入

```java
public void methodA() {
    lock("my_lock", "uuid", 30);
    methodB(); // 无法再次获取锁
    unlock("my_lock");
}

public void methodB() {
    lock("my_lock", "uuid", 30); // 失败！
    // ...
    unlock("my_lock");
}
```

---

#### 版本3：Lua 脚本 + UUID（改进）

```java
public class RedisLockV3 {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    /**
     * 加锁
     */
    public boolean lock(String key, String value, int expireSeconds) {
        Boolean success = redisTemplate.opsForValue()
                .setIfAbsent(key, value, expireSeconds, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
    
    /**
     * 解锁（Lua脚本保证原子性）
     */
    public boolean unlock(String key, String value) {
        String script = 
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "    return redis.call('del', KEYS[1]) " +
            "else " +
            "    return 0 " +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(script);
        redisScript.setResultType(Long.class);
        
        Long result = redisTemplate.execute(
                redisScript,
                Collections.singletonList(key),
                value
        );
        
        return result != null && result > 0;
    }
}
```

**使用示例**：

```java
String lockKey = "product:123";
String lockValue = UUID.randomUUID().toString();

try {
    if (lock(lockKey, lockValue, 30)) {
        // 执行业务逻辑
        deductStock();
    }
} finally {
    unlock(lockKey, lockValue);
}
```

**改进点**：
- ✅ 使用 UUID 标识锁的持有者
- ✅ 解锁时先判断是否是自己的锁
- ✅ Lua 脚本保证判断和删除的原子性

**仍存在的问题**：
- ❌ 不支持可重入
- ❌ 锁过期时间固定，业务未完成可能过期
- ❌ 没有自动续期机制

---

#### 版本4：Redisson（生产级方案）

```java
public class RedisLockV4 {
    
    @Autowired
    private RedissonClient redissonClient;
    
    public void executeWithLock(String lockKey, Runnable task) {
        RLock lock = redissonClient.getLock(lockKey);
        try {
            // 尝试加锁，最多等待10秒，锁30秒后自动释放
            boolean locked = lock.tryLock(10, 30, TimeUnit.SECONDS);
            if (locked) {
                task.run();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            // 释放锁（如果是当前线程持有）
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

**Redisson 解决了什么问题？**

1. **可重入锁**
   ```java
   RLock lock = redissonClient.getLock("my_lock");
   lock.lock();
   lock.lock(); // 可以再次加锁
   lock.unlock();
   lock.unlock(); // 需要解锁两次
   ```

2. **自动续期（WatchDog）**
   ```java
   lock.lock(); // 不指定过期时间
   // WatchDog 每10秒自动续期到30秒
   // 业务执行完毕后释放锁
   ```

3. **公平锁**
   ```java
   RLock fairLock = redissonClient.getFairLock("my_lock");
   // 按请求顺序获取锁
   ```

4. **红锁（RedLock）**
   ```java
   RLock lock1 = redisson1.getLock("lock");
   RLock lock2 = redisson2.getLock("lock");
   RLock lock3 = redisson3.getLock("lock");
   RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);
   // 多数节点加锁成功才算成功
   ```

---

### 问题7：为什么 Redisson 比手写 Redis 命令好？

| 特性 | 手写 Redis 命令 | Redisson |
|------|----------------|----------|
| **可重入** | ❌ 不支持 | ✅ 支持（Hash结构） |
| **自动续期** | ❌ 需要手动实现 | ✅ WatchDog机制 |
| **公平锁** | ❌ 需要手动实现 | ✅ 基于List实现 |
| **红锁** | ❌ 需要手动实现 | ✅ 开箱即用 |
| **读写锁** | ❌ 需要手动实现 | ✅ 开箱即用 |
| **信号量** | ❌ 需要手动实现 | ✅ 开箱即用 |
| **代码量** | 多（需要处理各种边界情况） | 少（一行代码搞定） |
| **可靠性** | 低（容易出bug） | 高（经过大量生产验证） |

---

## 四、方案对比与选型

### 问题8：数据库、Zookeeper、Redis 如何选择？

#### 性能对比

```
┌─────────────┬──────────┬──────────┬──────────┐
│   方案      │   TPS    │  延迟    │  资源    │
├─────────────┼──────────┼──────────┼──────────┤
│  数据库     │  1千     │  50ms    │  高      │
│  Zookeeper  │  1万     │  10ms    │  中      │
│  Redis      │  10万    │  1ms     │  低      │
└─────────────┴──────────┴──────────┴──────────┘
```

#### 可靠性对比

```
┌─────────────┬──────────┬──────────┬──────────┐
│   方案      │  一致性  │  可用性  │  防死锁  │
├─────────────┼──────────┼──────────┼──────────┤
│  数据库     │  强      │  中      │  需定时  │
│  Zookeeper  │  强      │  高      │  自动    │
│  Redis      │  弱      │  高      │  自动    │
└─────────────┴──────────┴──────────┴──────────┘
```

#### 功能对比

```
┌─────────────┬──────────┬──────────┬──────────┐
│   方案      │  可重入  │  公平锁  │  红锁    │
├─────────────┼──────────┼──────────┼──────────┤
│  数据库     │  ❌      │  ❌      │  ❌      │
│  Zookeeper  │  ❌      │  ✅      │  ❌      │
│  Redis      │  ✅      │  ✅      │  ✅      │
└─────────────┴──────────┴──────────┴──────────┘
```

---

### 问题9：实际项目中如何选型？

#### 场景1：电商秒杀

**需求**：
- 高并发（10万+ QPS）
- 低延迟（毫秒级）
- 允许短暂不一致

**选择**：Redis + Redisson

**理由**：
- 性能最优
- 支持可重入锁
- WatchDog 自动续期

---

#### 场景2：分布式任务调度

**需求**：
- 保证同一时刻只有一个节点执行任务
- 强一致性
- 并发量不高

**选择**：Zookeeper

**理由**：
- 强一致性保证
- 临时节点自动释放
- 适合配置中心场景

---

#### 场景3：简单的库存扣减

**需求**：
- 并发量低（几百 QPS）
- 不想引入额外组件
- 已有数据库

**选择**：数据库悲观锁

**理由**：
- 简单易懂
- 不需要额外组件
- 性能满足需求

---

## 五、总结：分布式锁的演进之路

### 技术演进图

```
数据库锁（2000年代）
    ↓
优点：简单、事务支持
缺点：性能差、单点故障
    ↓
Zookeeper锁（2010年代）
    ↓
优点：强一致性、自动释放
缺点：复杂度高、性能一般
    ↓
Redis锁（2015年+）
    ↓
优点：高性能、简单易用
缺点：需要处理各种边界情况
    ↓
Redisson（2016年+）
    ↓
优点：生产级方案、开箱即用
缺点：需要学习成本
```

### 核心要点

1. **性能优先**：Redis > Zookeeper > 数据库
2. **一致性优先**：Zookeeper > 数据库 > Redis
3. **简单优先**：数据库 > Redis > Zookeeper
4. **功能丰富**：Redisson > 其他

### 最佳实践

```java
// ❌ 不推荐：手写 Redis 命令
redisTemplate.opsForValue().setIfAbsent("lock", "value", 30, TimeUnit.SECONDS);

// ✅ 推荐：使用 Redisson
RLock lock = redissonClient.getLock("lock");
lock.lock();
try {
    // 业务逻辑
} finally {
    lock.unlock();
}
```

---

## 六、思考题

1. **如果 Redis 主从切换时丢失了锁怎么办？**
   - 提示：RedLock 方案

2. **Redisson 的 WatchDog 机制会不会导致锁永远不释放？**
   - 提示：业务代码异常、finally 块

3. **为什么 Zookeeper 适合做配置中心，而 Redis 适合做缓存？**
   - 提示：CAP 理论

---

**下一篇**：[03-Redisson分布式锁核心原理.md](./03-Redisson分布式锁核心原理.md) - 深入剖析 Redisson 的工作原理和 Lua 脚本实现
