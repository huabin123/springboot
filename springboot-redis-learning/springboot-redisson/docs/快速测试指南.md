# 快速测试指南

## 一、环境准备

### 1. 启动 Redis

```bash
# 使用 Docker 启动
docker run -d --name redis -p 6379:6379 redis:latest

# 或使用本地 Redis
redis-server
```

### 2. 启动应用

```bash
cd springboot-redisson
mvn spring-boot:run
```

---

## 二、基础功能测试

### 1. 基础加锁测试

```bash
curl http://localhost:8080/demo/basic-lock
```

**预期结果**：
```
基础加锁演示完成
```

**Redis 数据观察**：
```bash
redis-cli
> KEYS *
1) "basicLock"

> TYPE basicLock
hash

> HGETALL basicLock
1) "uuid:threadId"
2) "1"
```

---

### 2. tryLock 测试

```bash
curl http://localhost:8080/demo/try-lock
```

**预期结果**：
```
tryLock 演示完成
```

---

### 3. WatchDog 自动续期测试

```bash
curl http://localhost:8080/demo/watch-dog
```

**预期结果**：
- 业务执行60秒
- 锁会自动续期，不会过期

**观察方法**：
```bash
# 在另一个终端观察锁的过期时间
redis-cli
> TTL lockWithWatchDog
(integer) 28  # 会在20-30秒之间波动，说明在自动续期
```

---

### 4. 可重入锁测试

```bash
curl http://localhost:8080/demo/reentrant
```

**预期结果**：
```
可重入锁演示完成
```

**控制台输出**：
```
Thread-1 第1次加锁成功，持有次数: 1
Thread-1 第2次加锁成功，持有次数: 2
Thread-1 第3次加锁成功，持有次数: 3
执行业务逻辑
Thread-1 第3次解锁，持有次数: 2
Thread-1 第2次解锁，持有次数: 1
Thread-1 第1次解锁，持有次数: 0
```

---

### 5. 方法嵌套调用测试

```bash
curl http://localhost:8080/demo/nested-method
```

**预期结果**：
```
方法嵌套调用演示完成
```

**控制台输出**：
```
methodA 获取锁，持有次数: 1
methodB 获取锁（重入），持有次数: 2
methodC 获取锁（重入），持有次数: 3
执行核心业务逻辑
methodC 释放锁
methodB 释放锁
methodA 释放锁
```

---

## 三、实际项目场景测试

### 1. 秒杀场景测试

#### 步骤1：初始化库存

```bash
curl -X POST "http://localhost:8080/demo/seckill/init?productId=1001&stock=100"
```

**预期结果**：
```json
{
  "success": true,
  "message": "库存初始化成功",
  "productId": 1001,
  "stock": 100
}
```

#### 步骤2：单次秒杀

```bash
curl -X POST "http://localhost:8080/demo/seckill/buy?productId=1001&userId=1"
```

**预期结果**：
```json
{
  "success": true,
  "message": "秒杀成功",
  "remainStock": 99
}
```

#### 步骤3：并发秒杀测试

```bash
curl -X POST "http://localhost:8080/demo/seckill/concurrent-test?productId=1001&threadCount=100"
```

**预期结果**：
```json
{
  "success": true,
  "threadCount": 100,
  "successCount": 10,
  "failCount": 90,
  "remainStock": 0,
  "costTime": "1234ms"
}
```

**验证点**：
- ✅ 成功次数 = 初始库存（10）
- ✅ 剩余库存 = 0
- ✅ 没有超卖

---

### 2. 库存扣减场景测试

#### 步骤1：初始化库存

```bash
curl -X POST "http://localhost:8080/demo/inventory/init?productId=2001&stock=50"
```

#### 步骤2：扣减库存

```bash
curl -X POST "http://localhost:8080/demo/inventory/deduct?productId=2001&quantity=5"
```

**预期结果**：
```json
{
  "success": true,
  "message": "库存扣减成功",
  "remainStock": 45
}
```

#### 步骤3：查询库存

```bash
curl "http://localhost:8080/demo/inventory/query?productId=2001"
```

**预期结果**：
```json
{
  "success": true,
  "productId": 2001,
  "stock": 45
}
```

#### 步骤4：批量扣减库存

```bash
# 先初始化多个商品的库存
curl -X POST "http://localhost:8080/demo/inventory/init?productId=3001&stock=100"
curl -X POST "http://localhost:8080/demo/inventory/init?productId=3002&stock=100"

# 批量扣减
curl -X POST "http://localhost:8080/demo/inventory/batch-deduct?productIds=3001,3002&quantities=10,20"
```

**预期结果**：
```json
{
  "success": true,
  "message": "批量库存扣减成功"
}
```

---

### 3. 订单创建场景测试

```bash
curl -X POST "http://localhost:8080/demo/order/create?userId=1&productId=4001&quantity=2"
```

**预期结果**：
```json
{
  "success": true,
  "message": "订单创建成功",
  "orderNo": "ORDER_1705383456789_abc12345",
  "remainStock": 98
}
```

---

## 四、压力测试

### 1. 使用 Apache Bench (ab)

```bash
# 安装 ab
# macOS: brew install httpd
# Ubuntu: sudo apt-get install apache2-utils

# 压测秒杀接口（1000个请求，100并发）
ab -n 1000 -c 100 -p post.txt -T application/x-www-form-urlencoded \
   http://localhost:8080/demo/seckill/buy?productId=1001&userId=1
```

### 2. 使用 JMeter

1. 创建线程组：100个线程
2. 添加 HTTP 请求：POST /demo/seckill/buy
3. 添加监听器：查看结果树、聚合报告
4. 运行测试

**关注指标**：
- TPS（每秒事务数）
- 平均响应时间
- 错误率

---

## 五、Redis 数据观察

### 1. 观察锁的数据结构

```bash
redis-cli

# 查看所有key
> KEYS *

# 查看锁的类型
> TYPE myLock
hash

# 查看锁的内容
> HGETALL myLock
1) "uuid:threadId"
2) "1"

# 查看锁的过期时间
> TTL myLock
(integer) 28

# 查看库存
> GET product:stock:1001
"100"
```

### 2. 监控 Redis 命令

```bash
redis-cli MONITOR
```

**观察到的命令**：
```
1705383456.123456 [0 127.0.0.1:12345] "EVAL" "if (redis.call('exists', KEYS[1]) == 0) then ..."
1705383456.234567 [0 127.0.0.1:12345] "PEXPIRE" "myLock" "30000"
1705383456.345678 [0 127.0.0.1:12345] "PUBLISH" "redisson_lock__channel:{myLock}" "0"
```

---

## 六、常见问题排查

### 问题1：连接 Redis 失败

**错误信息**：
```
Unable to connect to Redis
```

**解决方案**：
1. 检查 Redis 是否启动：`redis-cli ping`
2. 检查配置文件：`application.yml` 中的 Redis 地址和端口
3. 检查防火墙设置

---

### 问题2：获取锁超时

**错误信息**：
```
获取锁失败，等待超时
```

**解决方案**：
1. 检查是否有其他线程持有锁
2. 使用 Redis 客户端查看锁的状态：`HGETALL lockKey`
3. 增加等待时间或减少业务执行时间

---

### 问题3：库存超卖

**现象**：
- 初始库存10，但卖出了11件

**排查步骤**：
1. 检查是否使用了分布式锁
2. 检查锁的粒度是否正确（按商品ID加锁）
3. 检查是否有异常导致锁未释放

---

## 七、性能测试报告模板

### 测试环境

- CPU: 4核
- 内存: 8GB
- Redis: 单机模式
- 应用实例: 1个

### 测试场景：秒杀

| 并发数 | 总请求数 | 成功数 | 失败数 | TPS | 平均响应时间 | 最大响应时间 |
|--------|----------|--------|--------|-----|--------------|--------------|
| 10     | 100      | 10     | 90     | 50  | 200ms        | 500ms        |
| 50     | 500      | 10     | 490    | 200 | 250ms        | 800ms        |
| 100    | 1000     | 10     | 990    | 300 | 333ms        | 1200ms       |

### 结论

1. 分布式锁有效防止了超卖
2. 随着并发增加，响应时间略有上升
3. 系统在100并发下表现稳定

---

## 八、学习建议

### 初学者

1. 按顺序测试所有基础功能
2. 观察 Redis 中的数据变化
3. 理解每个测试的预期结果

### 进阶学习

1. 修改代码，观察行为变化
2. 尝试不同的锁配置（等待时间、过期时间）
3. 进行压力测试，观察性能表现

### 深入研究

1. 使用 Redis MONITOR 观察命令执行
2. 阅读 Redisson 源码，理解实现细节
3. 对比不同方案的性能差异

---

**提示**：所有测试都应该先阅读对应的文档，理解原理后再进行测试，这样才能更好地理解测试结果。
