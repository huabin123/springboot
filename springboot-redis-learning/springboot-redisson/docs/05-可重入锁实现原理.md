# 05-可重入锁实现原理

## 一、什么是可重入锁？

### 问题1：为什么需要可重入锁？

#### 场景重现

```java
public class OrderService {
    
    private final RLock lock = redissonClient.getLock("orderLock");
    
    /**
     * 创建订单
     */
    public void createOrder() {
        lock.lock();
        try {
            // 1. 生成订单号
            String orderNo = generateOrderNo();
            
            // 2. 扣减库存（需要再次获取锁）
            deductStock();
            
            // 3. 保存订单
            saveOrder(orderNo);
        } finally {
            lock.unlock();
        }
    }
    
    /**
     * 扣减库存
     */
    private void deductStock() {
        lock.lock(); // 同一个线程再次获取锁
        try {
            // 扣减库存逻辑
            System.out.println("扣减库存");
        } finally {
            lock.unlock();
        }
    }
}
```

**如果不支持可重入会怎样？**

```
线程A调用 createOrder()
    ↓
获取锁成功
    ↓
调用 deductStock()
    ↓
尝试再次获取锁
    ↓
❌ 失败！（锁已被自己持有）
    ↓
死锁！（自己等待自己释放锁）
```

---

### 问题2：JDK 中的可重入锁是如何实现的？

#### ReentrantLock 实现原理

```java
public class ReentrantLock implements Lock {
    
    private final Sync sync;
    
    abstract static class Sync extends AbstractQueuedSynchronizer {
        
        // 当前持有锁的线程
        private transient Thread exclusiveOwnerThread;
        
        // 重入次数（state）
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState(); // 获取重入次数
            
            if (c == 0) {
                // 锁未被持有
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            } else if (current == getExclusiveOwnerThread()) {
                // 当前线程已持有锁，重入
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
        
        protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            
            boolean free = false;
            if (c == 0) {
                // 完全释放锁
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
    }
}
```

**核心思想**：
1. 记录持有锁的线程
2. 记录重入次数（state）
3. 加锁时判断是否是当前线程
4. 解锁时重入次数-1，为0时完全释放

---

## 二、Redisson 可重入锁的实现

### 问题3：Redisson 如何在 Redis 中实现可重入？

#### 数据结构设计

**为什么使用 Hash 而不是 String？**

```
方案1：String（不支持可重入）
myLock → "uuid:threadId"

问题：
- 无法记录重入次数
- 无法区分不同线程

方案2：Hash（支持可重入）
myLock (Hash)
  ├─ uuid:threadId-1 → 3  (线程1重入3次)
  └─ uuid:threadId-2 → 1  (线程2重入1次)

优点：
- field 存储线程标识
- value 存储重入次数
- 支持多线程
```

---

### 问题4：加锁的 Lua 脚本如何实现可重入？

#### 完整的加锁 Lua 脚本

```lua
-- KEYS[1]: 锁的key，例如 "myLock"
-- ARGV[1]: 锁的过期时间（毫秒），例如 30000
-- ARGV[2]: 锁的唯一标识，例如 "uuid:threadId"

-- 判断锁是否存在
if (redis.call('exists', KEYS[1]) == 0) then
    -- 锁不存在，直接加锁
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;

-- 锁存在，判断是否是当前线程持有（可重入判断）
if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then
    -- 是当前线程，重入次数+1
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;

-- 锁被其他线程持有，返回锁的剩余过期时间
return redis.call('pttl', KEYS[1]);
```

#### 脚本执行示例

**场景1：首次加锁**

```bash
# 执行前
> EXISTS myLock
(integer) 0

# 执行脚本
EVAL "..." 1 myLock 30000 "uuid:thread-1"

# 执行后
> HGETALL myLock
1) "uuid:thread-1"
2) "1"

> TTL myLock
(integer) 30
```

**场景2：重入加锁**

```bash
# 执行前
> HGETALL myLock
1) "uuid:thread-1"
2) "1"

# 执行脚本（同一线程再次加锁）
EVAL "..." 1 myLock 30000 "uuid:thread-1"

# 执行后
> HGETALL myLock
1) "uuid:thread-1"
2) "2"  ← 重入次数+1
```

**场景3：其他线程尝试加锁**

```bash
# 执行前
> HGETALL myLock
1) "uuid:thread-1"
2) "2"

# 执行脚本（不同线程）
EVAL "..." 1 myLock 30000 "uuid:thread-2"

# 返回值
(integer) 29850  ← 锁的剩余过期时间（毫秒）
```

---

### 问题5：解锁的 Lua 脚本如何处理重入？

#### 完整的解锁 Lua 脚本

```lua
-- KEYS[1]: 锁的key
-- KEYS[2]: 发布订阅的channel
-- ARGV[1]: 发布的消息（0表示锁释放）
-- ARGV[2]: 锁的过期时间
-- ARGV[3]: 锁的唯一标识

-- 判断锁是否存在
if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then
    -- 锁不存在，返回 nil
    return nil;
end;

-- 重入次数-1
local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1);

-- 判断重入次数是否大于0
if (counter > 0) then
    -- 还有重入，刷新过期时间
    redis.call('pexpire', KEYS[1], ARGV[2]);
    return 0;
else
    -- 完全释放锁
    redis.call('del', KEYS[1]);
    -- 发布锁释放消息
    redis.call('publish', KEYS[2], ARGV[1]);
    return 1;
end;

return nil;
```

#### 脚本执行示例

**场景：重入3次后逐步解锁**

```bash
# 初始状态
> HGETALL myLock
1) "uuid:thread-1"
2) "3"

# 第1次解锁
EVAL "..." 2 myLock channel 0 30000 "uuid:thread-1"
返回值: 0（锁未完全释放）

> HGETALL myLock
1) "uuid:thread-1"
2) "2"  ← 重入次数-1

# 第2次解锁
EVAL "..." 2 myLock channel 0 30000 "uuid:thread-1"
返回值: 0

> HGETALL myLock
1) "uuid:thread-1"
2) "1"

# 第3次解锁
EVAL "..." 2 myLock channel 0 30000 "uuid:thread-1"
返回值: 1（锁完全释放）

> EXISTS myLock
(integer) 0  ← 锁已删除
```

---

## 三、源码实现细节

### 问题6：getLockName() 如何生成唯一标识？

```java
public class RedissonLock extends RedissonExpirable implements RLock {
    
    // UUID，每个 RedissonClient 实例唯一
    private final UUID id;
    
    public RedissonLock(CommandAsyncExecutor commandExecutor, String name) {
        super(commandExecutor, name);
        this.commandExecutor = commandExecutor;
        this.id = commandExecutor.getConnectionManager().getId();
        this.internalLockLeaseTime = commandExecutor.getConnectionManager()
                .getCfg().getLockWatchdogTimeout();
    }
    
    /**
     * 获取锁的唯一标识
     * 格式：uuid:threadId
     */
    protected String getLockName(long threadId) {
        return id + ":" + threadId;
    }
}
```

**为什么需要 UUID + ThreadId？**

```
场景：多个应用实例，多个线程

实例1：
  ├─ UUID: 550e8400-e29b-41d4-a716-446655440000
  ├─ 线程1: 550e8400-e29b-41d4-a716-446655440000:1
  └─ 线程2: 550e8400-e29b-41d4-a716-446655440000:2

实例2：
  ├─ UUID: 660e8400-e29b-41d4-a716-446655440000
  ├─ 线程1: 660e8400-e29b-41d4-a716-446655440000:1
  └─ 线程2: 660e8400-e29b-41d4-a716-446655440000:2

保证：
- 不同实例的线程标识不同（UUID不同）
- 同一实例的不同线程标识不同（ThreadId不同）
- 同一线程的标识始终相同（可重入）
```

---

### 问题7：如何保证加锁和重入计数的原子性？

#### 为什么必须使用 Lua 脚本？

**错误示范：多条命令**

```java
// ❌ 错误：不是原子操作
public boolean lock(String key, String field) {
    // 步骤1：判断锁是否存在
    Boolean exists = redisTemplate.hasKey(key);
    
    if (!exists) {
        // 步骤2：创建锁
        redisTemplate.opsForHash().put(key, field, "1");
        return true;
    }
    
    // 步骤3：判断是否是当前线程
    Boolean hexists = redisTemplate.opsForHash().hasKey(key, field);
    if (hexists) {
        // 步骤4：重入次数+1
        redisTemplate.opsForHash().increment(key, field, 1);
        return true;
    }
    
    return false;
}
```

**问题**：

```
时刻T1: 线程A判断锁不存在
时刻T2: 线程B判断锁不存在
时刻T3: 线程A创建锁，field=thread-A, value=1
时刻T4: 线程B创建锁，field=thread-B, value=1
结果: 两个线程都认为自己获取了锁！
```

**正确做法：Lua 脚本**

```lua
-- 所有操作在一个脚本中完成
-- Redis 保证 Lua 脚本的原子执行
if (redis.call('exists', KEYS[1]) == 0) then
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;
-- ...
```

---

## 四、可重入锁的边界情况

### 问题8：重入次数有上限吗？

#### 源码分析

```lua
-- 加锁时
redis.call('hincrby', KEYS[1], ARGV[2], 1);

-- hincrby 的返回值是 long 类型
-- Redis 中 long 的范围：-9223372036854775808 到 9223372036854775807
```

**理论上限**：9223372036854775807 次

**实际情况**：
- 正常业务不会重入这么多次
- 如果重入次数过多，说明代码设计有问题

**异常检测**：

```java
public void detectReentrantDepth() {
    RLock lock = redissonClient.getLock("myLock");
    
    int depth = 0;
    while (depth < 10000) {
        lock.lock();
        depth++;
    }
    
    // ⚠️ 警告：重入深度过大，可能存在死循环
    System.err.println("重入深度：" + depth);
    
    // 释放所有锁
    for (int i = 0; i < depth; i++) {
        lock.unlock();
    }
}
```

---

### 问题9：解锁次数超过加锁次数会怎样？

#### 场景

```java
RLock lock = redissonClient.getLock("myLock");

lock.lock();  // 加锁1次
lock.unlock(); // 解锁1次
lock.unlock(); // 解锁2次（超过加锁次数）
```

#### 源码处理

```java
@Override
public void unlock() {
    try {
        get(unlockAsync(Thread.currentThread().getId()));
    } catch (RedisException e) {
        if (e.getCause() instanceof IllegalMonitorStateException) {
            // 抛出异常
            throw (IllegalMonitorStateException) e.getCause();
        } else {
            throw e;
        }
    }
}
```

#### Lua 脚本返回值

```lua
-- 判断锁是否存在
if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then
    -- 锁不存在，返回 nil
    return nil;
end;
```

**结果**：抛出 `IllegalMonitorStateException`

```
Exception in thread "main" java.lang.IllegalMonitorStateException: 
attempt to unlock lock, not locked by current thread by node id: xxx thread-id: 1
```

---

### 问题10：不同线程能否解锁？

#### 场景

```java
RLock lock = redissonClient.getLock("myLock");

// 线程A加锁
new Thread(() -> {
    lock.lock();
    System.out.println("线程A加锁成功");
}).start();

Thread.sleep(1000);

// 线程B尝试解锁
new Thread(() -> {
    lock.unlock(); // ❌ 失败
}).start();
```

#### Lua 脚本判断

```lua
-- 判断锁是否被当前线程持有
if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then
    -- 不是当前线程持有，返回 nil
    return nil;
end;
```

**结果**：抛出 `IllegalMonitorStateException`

---

## 五、可重入锁的性能优化

### 问题11：可重入锁的性能开销如何？

#### 性能对比

```
普通锁（String）：
- 加锁：SET key value NX PX 30000
- 解锁：DEL key
- 内存：约50字节

可重入锁（Hash）：
- 加锁：HINCRBY + PEXPIRE（Lua脚本）
- 解锁：HINCRBY + DEL/PEXPIRE（Lua脚本）
- 内存：约100字节（Hash结构）

性能差异：
- 加锁：可重入锁慢约10%（Lua脚本开销）
- 解锁：可重入锁慢约10%
- 内存：可重入锁多约50字节
```

#### 压测数据

```
场景：10000次加锁/解锁

普通锁：
- 总耗时：500ms
- 平均延迟：0.05ms

可重入锁：
- 总耗时：550ms
- 平均延迟：0.055ms

结论：性能差异可以忽略不计
```

---

### 问题12：如何减少重入次数？

#### 优化建议

**❌ 不推荐：过度重入**

```java
public void processOrder() {
    lock.lock();
    try {
        step1(); // 内部又加锁
        step2(); // 内部又加锁
        step3(); // 内部又加锁
    } finally {
        lock.unlock();
    }
}

private void step1() {
    lock.lock(); // 重入
    try {
        // ...
    } finally {
        lock.unlock();
    }
}
```

**✅ 推荐：减少重入**

```java
public void processOrder() {
    lock.lock();
    try {
        step1Internal(); // 不加锁
        step2Internal(); // 不加锁
        step3Internal(); // 不加锁
    } finally {
        lock.unlock();
    }
}

private void step1Internal() {
    // 直接执行业务逻辑，不加锁
}
```

---

## 六、总结

### 核心要点

1. **可重入的必要性**
   - 避免自己等待自己（死锁）
   - 支持方法嵌套调用
   - 提高代码灵活性

2. **实现原理**
   - Hash 结构存储锁信息
   - field 存储线程标识
   - value 存储重入次数

3. **加锁流程**
   - 锁不存在 → 创建锁，重入次数=1
   - 锁存在且是当前线程 → 重入次数+1
   - 锁存在但不是当前线程 → 加锁失败

4. **解锁流程**
   - 重入次数-1
   - 重入次数>0 → 刷新过期时间
   - 重入次数=0 → 删除锁，发布消息

5. **线程标识**
   - UUID + ThreadId
   - 保证全局唯一性
   - 支持多实例、多线程

### 关键数据结构

```
Redis 中的数据：
myLock (Hash)
  ├─ uuid1:thread-1 → 3  (实例1的线程1，重入3次)
  ├─ uuid1:thread-2 → 1  (实例1的线程2，重入1次)
  └─ uuid2:thread-1 → 2  (实例2的线程1，重入2次)

注意：
- 同一时刻只有一个 field 存在（互斥性）
- 上面的示例是错误的，仅用于说明数据结构
- 实际上，锁被一个线程持有时，其他线程无法加锁
```

### 最佳实践

```java
// ✅ 推荐：使用 try-finally 保证解锁
RLock lock = redissonClient.getLock("myLock");
lock.lock();
try {
    // 业务逻辑
} finally {
    lock.unlock();
}

// ❌ 不推荐：忘记解锁
lock.lock();
// 业务逻辑
// 忘记 unlock() → 重入次数永远不会归零

// ⚠️ 注意：加锁和解锁次数必须匹配
lock.lock();
lock.lock();
lock.unlock();
lock.unlock(); // 必须解锁两次
```

---

## 七、思考题

1. **为什么 Redisson 使用 Hash 而不是多个 String？**
   - 提示：原子性、内存效率

2. **如果重入次数溢出会怎样？**
   - 提示：Long.MAX_VALUE

3. **可重入锁能否跨进程？**
   - 提示：UUID 的作用

4. **如何检测锁的重入深度？**
   - 提示：HGET 命令

---

**下一篇**：[06-公平锁与红锁实现.md](./06-公平锁与红锁实现.md) - 深入剖析高级锁机制
