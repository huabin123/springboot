# Redisson 分布式锁学习内容总结

## 📚 已完成内容清单

### 一、理论文档（6篇）

#### ✅ 01-为什么需要分布式锁.md
**核心内容**：
- 从单机并发问题到分布式环境的演进
- 分布式锁的五大核心诉求（互斥性、防死锁、容错性、可重入、性能）
- 为什么选择 Redis 实现分布式锁
- Redis vs 数据库 vs Zookeeper 的技术选型

**关键知识点**：
- synchronized 和 ReentrantLock 在分布式环境下失效的原因
- 分布式锁需要解决的核心问题
- Redis 的性能优势（10万+ QPS）

---

#### ✅ 02-分布式锁的演进历程.md
**核心内容**：
- 数据库实现分布式锁（唯一索引、FOR UPDATE）
- Zookeeper 实现分布式锁（临时顺序节点）
- Redis 分布式锁的演进（SETNX+EXPIRE → SET NX EX → Lua脚本 → Redisson）
- 各方案的性能对比和适用场景

**关键知识点**：
- 数据库锁的性能瓶颈（500-1000 TPS）
- Zookeeper 的强一致性保证
- Redis 锁演进的每个阶段存在的问题
- 为什么 Redisson 比手写 Redis 命令好

---

#### ✅ 03-Redisson分布式锁核心原理.md
**核心内容**：
- Redisson 的整体架构（应用层、核心层、通信层）
- 加锁和解锁的完整流程图
- 加锁和解锁的 Lua 脚本详解
- 发布订阅机制的工作原理
- Hash 结构支持可重入的设计

**关键知识点**：
- 为什么必须使用 Lua 脚本（原子性保证）
- Hash 结构：field 存储线程标识，value 存储重入次数
- 发布订阅机制避免无效轮询
- Semaphore 阻塞等待机制

**核心 Lua 脚本**：
```lua
-- 加锁
if (redis.call('exists', KEYS[1]) == 0) then
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;
```

---

#### ✅ 04-锁续期机制WatchDog源码分析.md
**核心内容**：
- 固定过期时间的锁存在的问题
- WatchDog 的完整工作流程
- WatchDog 的启动和取消时机
- 续期 Lua 脚本的实现
- ExpirationEntry 的作用

**关键知识点**：
- 为什么续期间隔是过期时间的 1/3（容错性考虑）
- WatchDog 不会导致锁永远不释放（finally 保证、进程崩溃30秒后自动过期）
- 可重入锁的 WatchDog 处理（只启动一次，完全释放后取消）

**时间线示例**：
```
T0:   加锁，设置30秒过期
T10:  WatchDog第1次续期 → 过期时间延长到 T40
T20:  WatchDog第2次续期 → 过期时间延长到 T50
T30:  WatchDog第3次续期 → 过期时间延长到 T60
T35:  业务执行完毕，unlock()
```

---

#### ✅ 05-可重入锁实现原理.md
**核心内容**：
- 为什么需要可重入锁（避免自己等待自己）
- Redisson 如何在 Redis 中实现可重入
- 为什么使用 Hash 而不是 String
- 加锁和解锁的 Lua 脚本如何处理重入
- 线程标识的生成（UUID + ThreadId）

**关键知识点**：
- Hash 结构的设计：`myLock (Hash) → uuid:threadId → 重入次数`
- 加锁流程：锁不存在 → 创建；锁存在且是当前线程 → 重入次数+1
- 解锁流程：重入次数-1；为0时删除锁
- 重入次数的上限（Long.MAX_VALUE）

---

#### ✅ 07-实战使用与踩坑指南.md
**核心内容**：
- 如何正确使用 Redisson 分布式锁（标准模板）
- lock() vs tryLock() 的选择
- 常见踩坑场景和解决方案
- 锁粒度的设计原则
- 如何避免死锁
- 性能优化实践
- 监控和告警方案

**关键知识点**：
- 必须使用 tryLock 而不是 lock（避免无限等待）
- 必须在 finally 中释放锁
- 锁粒度设计：按业务维度加锁（用户锁、商品锁）
- 死锁预防：锁排序、MultiLock
- 性能优化：缩小锁范围、锁分段

**最佳实践模板**：
```java
RLock lock = redissonClient.getLock(lockKey);
try {
    boolean locked = lock.tryLock(10, 30, TimeUnit.SECONDS);
    if (locked) {
        try {
            // 业务逻辑
        } finally {
            lock.unlock();
        }
    }
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}
```

---

### 二、演示代码（2个类）

#### ✅ BasicLockDemo.java
**包含示例**：
1. 基础加锁（不推荐）
2. 指定过期时间的加锁
3. 尝试加锁（推荐）
4. 使用 WatchDog 自动续期
5. 判断锁的状态
6. 强制解锁（慎用）

**学习价值**：
- 理解不同加锁方式的区别
- 掌握 tryLock 的正确用法
- 理解 WatchDog 的启动条件

---

#### ✅ ReentrantLockDemo.java
**包含示例**：
1. 可重入锁基础演示
2. 方法嵌套调用（典型场景）
3. 错误示例（加锁解锁次数不匹配）
4. 正确示例（使用 try-finally）
5. 多线程场景（不同线程无法重入）
6. 检测重入深度

**学习价值**：
- 理解可重入的必要性
- 掌握正确的加锁解锁配对
- 理解重入次数的管理

---

### 三、实际项目代码（3个服务类）

#### ✅ SecKillService.java
**业务场景**：商品秒杀，防止超卖

**包含方法**：
1. `secKillWithoutLock()` - 无锁版本（演示问题）
2. `secKillWithLock()` - 分布式锁版本（防止超卖）
3. `secKillOptimized()` - 优化版本（使用 Lua 脚本）
4. `secKillWithUserLock()` - 防止重复购买

**学习价值**：
- 理解秒杀场景的并发问题
- 掌握分布式锁的实际应用
- 学习性能优化技巧（Lua 脚本、异步处理）

---

#### ✅ InventoryService.java
**业务场景**：库存管理，防止超卖

**包含方法**：
1. `deductStock()` - 扣减库存
2. `batchDeductStock()` - 批量扣减（使用 MultiLock）
3. `rollbackStock()` - 回滚库存
4. `reserveStock()` - 预占库存
5. `releaseReservedStock()` - 释放预占库存

**学习价值**：
- 理解库存扣减的并发问题
- 掌握 MultiLock 的使用（同时锁定多个资源）
- 学习预占库存的设计模式

---

#### ✅ OrderService.java
**业务场景**：订单管理，防止重复下单

**包含方法**：
1. `createOrder()` - 创建订单（防止重复下单）
2. `cancelOrder()` - 取消订单（回滚库存）
3. `payOrder()` - 支付订单

**学习价值**：
- 理解订单创建的并发问题
- 掌握用户级别锁的使用
- 学习异常处理和事务回滚

---

### 四、接口控制器（1个类）

#### ✅ DemoController.java
**提供接口**：
1. 基础演示接口（6个）
   - `/demo/basic-lock` - 基础加锁
   - `/demo/try-lock` - tryLock 演示
   - `/demo/watch-dog` - WatchDog 演示
   - `/demo/reentrant` - 可重入锁演示
   - `/demo/nested-method` - 方法嵌套调用

2. 秒杀接口（3个）
   - `/demo/seckill/init` - 初始化库存
   - `/demo/seckill/buy` - 单次秒杀
   - `/demo/seckill/concurrent-test` - 并发秒杀测试

3. 库存接口（4个）
   - `/demo/inventory/init` - 初始化库存
   - `/demo/inventory/deduct` - 扣减库存
   - `/demo/inventory/batch-deduct` - 批量扣减
   - `/demo/inventory/query` - 查询库存

4. 订单接口（1个）
   - `/demo/order/create` - 创建订单

**学习价值**：
- 快速测试各种功能
- 理解接口设计
- 进行压力测试

---

### 五、配置和文档

#### ✅ README.md（项目根目录）
**内容**：
- 项目结构说明
- 学习目标和路径
- 快速开始指南
- 核心知识点总结
- 实际应用场景
- 常见问题解答

#### ✅ docs/README.md（文档总览）
**内容**：
- 完整的学习路径
- 文档导航
- 核心知识图谱
- 环境准备
- 快速开始

#### ✅ 快速测试指南.md
**内容**：
- 环境准备步骤
- 基础功能测试（5个场景）
- 实际项目测试（3个场景）
- 压力测试方法
- Redis 数据观察
- 常见问题排查
- 性能测试报告模板

---

## 🎯 学习成果

通过本项目的学习，你已经掌握：

### 理论层面
- ✅ 分布式锁的必要性和核心诉求
- ✅ 各种分布式锁方案的优缺点
- ✅ Redisson 的架构和实现原理
- ✅ Lua 脚本的作用和实现
- ✅ WatchDog 自动续期机制
- ✅ 可重入锁的实现原理

### 实践层面
- ✅ 正确使用 Redisson 分布式锁
- ✅ 避免常见的踩坑场景
- ✅ 在实际项目中应用分布式锁
- ✅ 性能优化和监控

### 代码层面
- ✅ 6个演示方法（BasicLockDemo）
- ✅ 6个演示方法（ReentrantLockDemo）
- ✅ 4个业务方法（SecKillService）
- ✅ 5个业务方法（InventoryService）
- ✅ 3个业务方法（OrderService）
- ✅ 14个测试接口（DemoController）

---

## 📊 内容统计

| 类型 | 数量 | 说明 |
|------|------|------|
| **理论文档** | 6篇 | 约3万字 |
| **演示代码** | 2个类 | 12个方法 |
| **项目代码** | 3个服务类 | 12个业务方法 |
| **接口控制器** | 1个类 | 14个接口 |
| **配置文档** | 3个文件 | README、快速测试指南等 |
| **代码行数** | 约2000行 | 包含注释和文档 |

---

## 🚀 下一步学习建议

### 已完成的核心内容
1. ✅ 基础理论（为什么需要、如何演进）
2. ✅ 核心原理（Lua 脚本、WatchDog、可重入）
3. ✅ 实战应用（秒杀、库存、订单）
4. ✅ 最佳实践（踩坑指南）

### 可选的进阶内容
1. ⏸️ 公平锁与红锁实现（06-公平锁与红锁实现.md）
2. ⏸️ 源码中的设计精髓（08-源码中的设计精髓.md）
3. ⏸️ 读写锁的使用场景
4. ⏸️ 信号量和限流器

### 深入学习方向
1. **阅读 Redisson 源码**
   - `RedissonLock.java` - 锁的核心实现
   - `CommandExecutor.java` - 命令执行器
   - `LockPubSub.java` - 发布订阅机制

2. **性能调优**
   - 锁粒度优化
   - 连接池配置
   - Lua 脚本优化

3. **高可用方案**
   - Redis 主从切换时的锁丢失问题
   - RedLock 算法的实现和争议
   - 集群模式下的分布式锁

4. **实际项目应用**
   - 结合自己的业务场景
   - 设计适合的锁方案
   - 制定团队规范

---

## 💡 学习心得建议

### 理论学习
1. **先理解问题，再学习方案**
   - 不要直接学习 Redisson，先理解为什么需要分布式锁
   - 理解单机锁在分布式环境下失效的原因

2. **对比不同方案**
   - 数据库、Zookeeper、Redis 各有优缺点
   - 根据业务场景选择合适的方案

### 实践学习
1. **动手实践，观察现象**
   - 运行演示代码，使用 Redis 客户端观察数据变化
   - 修改代码参数，观察行为变化

2. **压力测试**
   - 进行并发测试，验证分布式锁的有效性
   - 观察性能指标，找出瓶颈

### 源码学习
1. **结合文档阅读源码**
   - 先阅读文档理解原理，再看源码验证
   - 重点关注 Lua 脚本的实现

2. **调试源码**
   - 在关键位置打断点
   - 观察变量的变化

---

## 🎉 总结

本项目以**问题驱动**的方式，系统地讲解了 Redisson 分布式锁的：
- ✅ 理论基础（为什么需要、如何演进）
- ✅ 核心原理（架构、Lua 脚本、WatchDog、可重入）
- ✅ 实战应用（秒杀、库存、订单）
- ✅ 最佳实践（正确用法、踩坑指南、性能优化）

通过学习本项目，你已经具备了：
- 理解分布式锁的原理和实现
- 在实际项目中正确使用分布式锁
- 避免常见的踩坑场景
- 进行性能优化和监控

**继续加油！** 🚀

---

**最后更新时间**：2026-01-16

**作者**：huabin

**版本**：v1.0
