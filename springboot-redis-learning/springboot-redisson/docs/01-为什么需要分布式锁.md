# 01-为什么需要分布式锁

## 一、从一个真实场景说起

### 问题1：单机环境下的并发问题是什么？

假设我们有一个电商系统的库存扣减场景：

```java
public class InventoryService {
    private int stock = 100; // 库存数量
    
    public boolean deductStock() {
        if (stock > 0) {
            // 模拟业务处理耗时
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            stock--;
            System.out.println("扣减成功，剩余库存：" + stock);
            return true;
        }
        return false;
    }
}
```

**会出现什么问题？**

当多个线程同时调用 `deductStock()` 时：
1. 线程A读取 stock=100，判断 > 0
2. 线程B读取 stock=100，判断 > 0
3. 线程A执行 stock--，stock=99
4. 线程B执行 stock--，stock=98

**结果**：两个请求都成功了，但库存只减了2，实际应该减1。这就是典型的**并发安全问题**。

---

### 问题2：单机环境下如何解决并发问题？

#### 方案1：使用 synchronized 关键字

```java
public class InventoryService {
    private int stock = 100;
    
    public synchronized boolean deductStock() {
        if (stock > 0) {
            stock--;
            System.out.println("扣减成功，剩余库存：" + stock);
            return true;
        }
        return false;
    }
}
```

**原理**：synchronized 基于 JVM 的监视器锁（Monitor），同一时刻只允许一个线程进入同步方法。

#### 方案2：使用 ReentrantLock

```java
public class InventoryService {
    private int stock = 100;
    private final ReentrantLock lock = new ReentrantLock();
    
    public boolean deductStock() {
        lock.lock();
        try {
            if (stock > 0) {
                stock--;
                System.out.println("扣减成功，剩余库存：" + stock);
                return true;
            }
            return false;
        } finally {
            lock.unlock();
        }
    }
}
```

**原理**：ReentrantLock 基于 AQS（AbstractQueuedSynchronizer），提供了更灵活的锁机制。

#### 方案3：使用原子类 AtomicInteger

```java
public class InventoryService {
    private AtomicInteger stock = new AtomicInteger(100);
    
    public boolean deductStock() {
        while (true) {
            int current = stock.get();
            if (current <= 0) {
                return false;
            }
            if (stock.compareAndSet(current, current - 1)) {
                System.out.println("扣减成功，剩余库存：" + stock.get());
                return true;
            }
        }
    }
}
```

**原理**：基于 CAS（Compare-And-Swap）操作，利用 CPU 的原子指令保证并发安全。

---

## 二、分布式环境下的新挑战

### 问题3：为什么单机锁在分布式环境下失效了？

假设我们的系统部署了3个实例：

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  服务实例1   │     │  服务实例2   │     │  服务实例3   │
│  JVM-1      │     │  JVM-2      │     │  JVM-3      │
│  stock=100  │     │  stock=100  │     │  stock=100  │
└─────────────┘     └─────────────┘     └─────────────┘
       ↑                   ↑                   ↑
       └───────────────────┴───────────────────┘
                    负载均衡器
                         ↑
                    用户请求
```

**问题分析**：

1. **锁的作用域仅限于单个JVM**
   - synchronized 和 ReentrantLock 都是基于 JVM 内存的锁
   - 只能保证同一个 JVM 进程内的线程安全
   - 无法跨 JVM 进程协调

2. **数据不共享**
   - 每个实例都有自己的 stock 变量副本
   - 实例1扣减库存，实例2和实例3感知不到

3. **并发问题升级**
   ```
   时刻T1: 用户A请求 → 实例1 → stock=100，扣减成功，stock=99
   时刻T1: 用户B请求 → 实例2 → stock=100，扣减成功，stock=99
   时刻T1: 用户C请求 → 实例3 → stock=100，扣减成功，stock=99
   ```
   
   **结果**：3个请求都成功了，但实际库存应该是97，每个实例都认为是99。

---

### 问题4：分布式环境下的并发问题有多严重？

#### 场景1：电商秒杀超卖

```
库存：100件
请求：10000个并发请求，分布在10台服务器
结果：可能卖出1000件（超卖900件）
```

**后果**：
- 用户投诉、退款
- 商家损失
- 平台信誉受损

#### 场景2：优惠券重复领取

```
规则：每个用户只能领取1张
实际：用户通过并发请求领取了多张
```

**后果**：
- 营销成本失控
- 薅羊毛行为泛滥

#### 场景3：订单号重复生成

```
订单号生成规则：时间戳 + 自增序列
多实例同时生成：可能产生相同订单号
```

**后果**：
- 数据库主键冲突
- 订单数据混乱

---

## 三、分布式锁的核心诉求

### 问题5：分布式锁需要解决哪些核心问题？

基于上述场景，我们总结出分布式锁的核心诉求：

#### 1. 互斥性（Mutual Exclusion）
**问题**：如何保证在分布式环境下，同一时刻只有一个客户端持有锁？

**要求**：
- 跨 JVM 进程的互斥
- 跨服务器节点的互斥
- 全局唯一性

#### 2. 防死锁（Deadlock Free）
**问题**：如果持有锁的客户端崩溃了怎么办？

**场景**：
```
1. 客户端A获取锁
2. 客户端A执行业务逻辑
3. 客户端A突然宕机（未释放锁）
4. 其他客户端永远无法获取锁 → 死锁
```

**要求**：
- 锁必须有过期时间（TTL）
- 即使客户端崩溃，锁也能自动释放

#### 3. 容错性（Fault Tolerance）
**问题**：如果锁服务器宕机了怎么办？

**要求**：
- 高可用性
- 故障转移能力
- 数据一致性

#### 4. 可重入性（Reentrant）
**问题**：同一个线程能否多次获取同一把锁？

**场景**：
```java
public void methodA() {
    lock.lock();
    try {
        methodB(); // 需要再次获取同一把锁
    } finally {
        lock.unlock();
    }
}

public void methodB() {
    lock.lock();
    try {
        // 业务逻辑
    } finally {
        lock.unlock();
    }
}
```

**要求**：
- 支持同一客户端多次加锁
- 记录加锁次数
- 完全释放后才真正解锁

#### 5. 性能要求（Performance）
**问题**：锁的获取和释放要足够快

**要求**：
- 低延迟（毫秒级）
- 高吞吐（支持高并发）
- 资源占用少

---

## 四、为什么选择 Redis 实现分布式锁？

### 问题6：实现分布式锁有哪些技术选型？

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **数据库** | 简单易懂，事务支持 | 性能差，高并发下压力大 | 低并发场景 |
| **Zookeeper** | 强一致性，天然支持临时节点 | 复杂度高，性能一般 | 对一致性要求极高的场景 |
| **Redis** | 性能高，实现简单 | 需要考虑主从切换时的一致性 | 高并发场景 |
| **Etcd** | 强一致性，云原生 | 生态相对较小 | 云原生应用 |

### 问题7：Redis 实现分布式锁的优势是什么？

#### 1. 性能优势
```
Redis 单机 QPS：10万+
MySQL 单机 QPS：几千
Zookeeper 单机 QPS：1万+
```

#### 2. 简单易用
```bash
# 加锁
SET lock_key unique_value NX PX 30000

# 解锁
DEL lock_key
```

#### 3. 原子操作支持
- SET NX（不存在才设置）
- Lua 脚本保证原子性
- 过期时间自动管理

#### 4. 丰富的数据结构
- String：基础锁
- Hash：可重入锁
- List：公平锁队列
- Sorted Set：延迟队列

---

## 五、Redis 分布式锁的演进之路

### 问题8：为什么不直接用 Redis 命令，而要用 Redisson？

#### 阶段1：SETNX + EXPIRE（有问题）

```bash
# 加锁
SETNX lock_key value
EXPIRE lock_key 30

# 问题：两条命令不是原子的
# 如果 SETNX 成功后，EXPIRE 执行前进程崩溃
# 锁永远不会过期 → 死锁
```

**问题**：加锁和设置过期时间不是原子操作

#### 阶段2：SET NX PX（基本可用）

```bash
# 加锁（原子操作）
SET lock_key unique_value NX PX 30000

# 解锁
DEL lock_key
```

**问题**：
1. 可能删除别人的锁（A的锁过期，B获取锁，A删除了B的锁）
2. 不支持可重入
3. 锁过期时间固定，业务未执行完锁就过期了

#### 阶段3：Lua 脚本 + UUID（改进）

```lua
-- 加锁
if redis.call('exists', KEYS[1]) == 0 then
    redis.call('set', KEYS[1], ARGV[1], 'PX', ARGV[2])
    return 1
end
return 0

-- 解锁（判断是否是自己的锁）
if redis.call('get', KEYS[1]) == ARGV[1] then
    return redis.call('del', KEYS[1])
end
return 0
```

**问题**：
1. 仍不支持可重入
2. 没有自动续期机制
3. 需要自己实现很多细节

#### 阶段4：Redisson（生产级方案）

**Redisson 解决了什么问题？**

1. **可重入锁**：基于 Hash 结构，记录加锁次数
2. **自动续期**：WatchDog 机制，业务未完成自动延长锁时间
3. **公平锁**：基于 List 实现 FIFO 队列
4. **红锁**：多节点加锁，提高可靠性
5. **读写锁**：支持读写分离场景
6. **信号量**：支持限流场景

---

## 六、总结：为什么需要分布式锁？

### 核心问题回顾

```
单机并发问题
    ↓
使用 JVM 锁（synchronized、ReentrantLock）
    ↓
分布式部署后 JVM 锁失效
    ↓
需要跨 JVM 的全局锁
    ↓
分布式锁诞生
    ↓
技术选型（数据库、Zookeeper、Redis、Etcd）
    ↓
选择 Redis（高性能、简单易用）
    ↓
Redis 原生命令不够完善
    ↓
Redisson 提供生产级解决方案
```

### 关键要点

1. **本质问题**：分布式环境下的资源竞争
2. **核心诉求**：互斥性、防死锁、容错性、可重入、高性能
3. **技术选型**：Redis 在高并发场景下性能最优
4. **最佳实践**：使用 Redisson 而非手写 Redis 命令

---

## 七、思考题

1. **如果不用分布式锁，还有其他方案吗？**
   - 提示：乐观锁、数据库唯一索引、消息队列串行化

2. **分布式锁一定能保证数据一致性吗？**
   - 提示：主从切换、网络分区、时钟漂移

3. **什么场景下不应该使用分布式锁？**
   - 提示：性能要求极高、可以容忍短暂不一致

---

**下一篇**：[02-分布式锁的演进历程.md](./02-分布式锁的演进历程.md) - 深入对比各种分布式锁实现方案
