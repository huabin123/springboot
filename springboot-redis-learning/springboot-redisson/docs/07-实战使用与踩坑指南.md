# 07-实战使用与踩坑指南

## 一、基础使用最佳实践

### 问题1：如何正确使用 Redisson 分布式锁？

#### 标准模板

```java
@Service
public class OrderService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    /**
     * 创建订单（标准模板）
     */
    public void createOrder(String userId, String productId) {
        String lockKey = "order:lock:" + userId;
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            // 尝试获取锁：等待10秒，锁30秒后自动释放
            boolean locked = lock.tryLock(10, 30, TimeUnit.SECONDS);
            
            if (!locked) {
                throw new BusinessException("系统繁忙，请稍后再试");
            }
            
            try {
                // 执行业务逻辑
                doCreateOrder(userId, productId);
            } finally {
                // 释放锁（必须在 finally 中）
                lock.unlock();
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new BusinessException("操作被中断");
        }
    }
    
    private void doCreateOrder(String userId, String productId) {
        // 实际业务逻辑
    }
}
```

**关键点**：
1. ✅ 使用 `tryLock` 而不是 `lock`（避免无限等待）
2. ✅ 设置等待时间和过期时间
3. ✅ 判断是否获取锁成功
4. ✅ 在 finally 中释放锁
5. ✅ 处理 InterruptedException

---

### 问题2：lock() vs tryLock() 如何选择？

#### 对比分析

```java
// 方式1：lock()（不推荐）
lock.lock();
try {
    // 业务逻辑
} finally {
    lock.unlock();
}

// 问题：
// - 如果锁被占用，会一直等待
// - 可能导致线程饥饿
// - 用户体验差（无限等待）

// 方式2：tryLock()（推荐）
boolean locked = lock.tryLock(10, 30, TimeUnit.SECONDS);
if (locked) {
    try {
        // 业务逻辑
    } finally {
        lock.unlock();
    }
} else {
    // 获取锁失败的处理
    throw new BusinessException("系统繁忙");
}

// 优点：
// - 有超时机制
// - 可以快速失败
// - 用户体验好
```

#### 使用场景

| 场景 | 推荐方式 | 理由 |
|------|----------|------|
| **Web请求** | tryLock | 避免用户长时间等待 |
| **定时任务** | tryLock | 任务执行失败可以下次重试 |
| **消息消费** | tryLock | 消息可以重新入队 |
| **后台任务** | lock | 必须执行完成 |

---

## 二、常见踩坑场景

### 问题3：忘记释放锁会怎样？

#### 错误示例

```java
// ❌ 错误：没有 finally
public void badExample() {
    RLock lock = redissonClient.getLock("myLock");
    lock.lock();
    
    // 业务逻辑
    processOrder();
    
    lock.unlock(); // 如果 processOrder() 抛异常，这行不会执行
}
```

**后果**：

```
场景1：指定了过期时间
- 锁会在过期时间后自动释放
- 影响：短期内其他线程无法获取锁

场景2：未指定过期时间（启用WatchDog）
- WatchDog 会一直续期
- 影响：锁永远不会释放（死锁）
```

#### 正确示例

```java
// ✅ 正确：使用 finally
public void goodExample() {
    RLock lock = redissonClient.getLock("myLock");
    lock.lock();
    
    try {
        processOrder();
    } finally {
        lock.unlock(); // 一定会执行
    }
}
```

---

### 问题4：锁的粒度如何设计？

#### 粒度过大的问题

```java
// ❌ 错误：锁粒度过大
public void badExample() {
    // 所有用户共用一把锁
    RLock lock = redissonClient.getLock("order:lock");
    lock.lock();
    try {
        createOrder(userId, productId);
    } finally {
        lock.unlock();
    }
}

// 问题：
// - 用户A创建订单时，用户B也无法创建
// - 并发性能极差
```

#### 粒度过小的问题

```java
// ❌ 错误：锁粒度过小
public void badExample() {
    // 每个订单一把锁
    RLock lock = redissonClient.getLock("order:lock:" + orderId);
    lock.lock();
    try {
        deductStock(productId); // 库存扣减没有锁保护
    } finally {
        lock.unlock();
    }
}

// 问题：
// - 不同订单可能扣减同一商品库存
// - 无法防止超卖
```

#### 正确的粒度设计

```java
// ✅ 正确：按业务维度加锁
public void goodExample() {
    // 方案1：按用户加锁（防止重复下单）
    String userLockKey = "order:user:lock:" + userId;
    RLock userLock = redissonClient.getLock(userLockKey);
    
    // 方案2：按商品加锁（防止库存超卖）
    String productLockKey = "product:stock:lock:" + productId;
    RLock productLock = redissonClient.getLock(productLockKey);
    
    // 方案3：使用 MultiLock（同时锁定多个资源）
    RLock multiLock = redissonClient.getMultiLock(userLock, productLock);
    
    multiLock.lock();
    try {
        createOrder(userId, productId);
    } finally {
        multiLock.unlock();
    }
}
```

---

### 问题5：锁超时时间如何设置？

#### 常见错误

```java
// ❌ 错误1：时间过短
lock.tryLock(1, 5, TimeUnit.SECONDS);
// 问题：业务可能需要10秒，锁5秒就过期了

// ❌ 错误2：时间过长
lock.tryLock(60, 300, TimeUnit.SECONDS);
// 问题：客户端崩溃后，锁5分钟才释放

// ❌ 错误3：不设置过期时间
lock.lock();
// 问题：依赖 WatchDog，如果业务死循环，锁永远不释放
```

#### 正确设置

```java
// ✅ 推荐：根据业务场景设置

// 场景1：快速操作（库存扣减）
lock.tryLock(3, 10, TimeUnit.SECONDS);

// 场景2：普通操作（创建订单）
lock.tryLock(10, 30, TimeUnit.SECONDS);

// 场景3：耗时操作（批量导入）
lock.tryLock(30, 60, TimeUnit.SECONDS);

// 场景4：不确定耗时（使用 WatchDog）
boolean locked = lock.tryLock(10, TimeUnit.SECONDS);
// 不指定 leaseTime，自动启用 WatchDog
```

**经验公式**：

```
等待时间 = 预估业务时间 × 2
过期时间 = 预估业务时间 × 3

例如：
业务预估10秒
等待时间 = 20秒
过期时间 = 30秒
```

---

### 问题6：如何避免死锁？

#### 死锁场景1：循环等待

```java
// ❌ 错误：可能导致死锁
public void transfer(String fromUser, String toUser, int amount) {
    RLock lock1 = redissonClient.getLock("account:" + fromUser);
    RLock lock2 = redissonClient.getLock("account:" + toUser);
    
    lock1.lock();
    try {
        lock2.lock(); // 如果另一个线程先锁定 lock2，就死锁了
        try {
            // 转账逻辑
        } finally {
            lock2.unlock();
        }
    } finally {
        lock1.unlock();
    }
}
```

**问题分析**：

```
线程A：transfer("user1", "user2", 100)
  ├─ 获取 lock("account:user1")
  └─ 等待 lock("account:user2")

线程B：transfer("user2", "user1", 50)
  ├─ 获取 lock("account:user2")
  └─ 等待 lock("account:user1")

结果：死锁！
```

#### 解决方案1：锁排序

```java
// ✅ 正确：按固定顺序加锁
public void transfer(String fromUser, String toUser, int amount) {
    // 按字典序排序
    String first = fromUser.compareTo(toUser) < 0 ? fromUser : toUser;
    String second = fromUser.compareTo(toUser) < 0 ? toUser : fromUser;
    
    RLock lock1 = redissonClient.getLock("account:" + first);
    RLock lock2 = redissonClient.getLock("account:" + second);
    
    lock1.lock();
    try {
        lock2.lock();
        try {
            // 转账逻辑
        } finally {
            lock2.unlock();
        }
    } finally {
        lock1.unlock();
    }
}
```

#### 解决方案2：使用 MultiLock

```java
// ✅ 正确：使用 MultiLock（原子获取多个锁）
public void transfer(String fromUser, String toUser, int amount) {
    RLock lock1 = redissonClient.getLock("account:" + fromUser);
    RLock lock2 = redissonClient.getLock("account:" + toUser);
    
    RLock multiLock = redissonClient.getMultiLock(lock1, lock2);
    
    multiLock.lock();
    try {
        // 转账逻辑
    } finally {
        multiLock.unlock();
    }
}
```

---

### 问题7：如何处理锁释放失败？

#### 场景

```java
public void processOrder() {
    RLock lock = redissonClient.getLock("myLock");
    lock.lock();
    
    try {
        // 业务逻辑
    } finally {
        lock.unlock(); // 如果 Redis 宕机，unlock 会失败
    }
}
```

#### 处理方案

```java
// ✅ 推荐：捕获异常，记录日志
public void processOrder() {
    RLock lock = redissonClient.getLock("myLock");
    lock.lock();
    
    try {
        // 业务逻辑
    } finally {
        try {
            lock.unlock();
        } catch (Exception e) {
            // 记录日志，但不影响业务
            log.error("释放锁失败，lockKey={}", "myLock", e);
            // 锁会在过期时间后自动释放
        }
    }
}
```

---

## 三、性能优化实践

### 问题8：如何减少锁竞争？

#### 优化1：缩小锁范围

```java
// ❌ 不推荐：锁范围过大
public void badExample() {
    RLock lock = redissonClient.getLock("myLock");
    lock.lock();
    try {
        // 1. 查询数据库（不需要锁）
        Order order = orderMapper.selectById(orderId);
        
        // 2. 业务逻辑（需要锁）
        order.setStatus("PAID");
        
        // 3. 更新数据库（不需要锁）
        orderMapper.updateById(order);
    } finally {
        lock.unlock();
    }
}

// ✅ 推荐：只锁关键代码
public void goodExample() {
    // 1. 查询数据库（不加锁）
    Order order = orderMapper.selectById(orderId);
    
    // 2. 加锁执行关键逻辑
    RLock lock = redissonClient.getLock("order:lock:" + orderId);
    lock.lock();
    try {
        order.setStatus("PAID");
    } finally {
        lock.unlock();
    }
    
    // 3. 更新数据库（不加锁）
    orderMapper.updateById(order);
}
```

#### 优化2：锁分段

```java
// ❌ 不推荐：所有商品共用一把锁
public void deductStock(String productId, int quantity) {
    RLock lock = redissonClient.getLock("stock:lock");
    lock.lock();
    try {
        // 扣减库存
    } finally {
        lock.unlock();
    }
}

// ✅ 推荐：每个商品一把锁
public void deductStock(String productId, int quantity) {
    RLock lock = redissonClient.getLock("stock:lock:" + productId);
    lock.lock();
    try {
        // 扣减库存
    } finally {
        lock.unlock();
    }
}

// ✅ 更优：分段锁（类似 ConcurrentHashMap）
public void deductStock(String productId, int quantity) {
    // 将商品ID哈希到16个分段中
    int segment = Math.abs(productId.hashCode() % 16);
    RLock lock = redissonClient.getLock("stock:lock:segment:" + segment);
    
    lock.lock();
    try {
        // 扣减库存
    } finally {
        lock.unlock();
    }
}
```

---

### 问题9：如何监控锁的使用情况？

#### 监控指标

```java
@Component
public class LockMonitor {
    
    private static final Logger log = LoggerFactory.getLogger(LockMonitor.class);
    
    /**
     * 监控锁的获取情况
     */
    public <T> T executeWithLockMonitor(String lockKey, Supplier<T> supplier) {
        RLock lock = redissonClient.getLock(lockKey);
        
        long startTime = System.currentTimeMillis();
        boolean locked = false;
        
        try {
            locked = lock.tryLock(10, 30, TimeUnit.SECONDS);
            long waitTime = System.currentTimeMillis() - startTime;
            
            if (!locked) {
                // 记录获取锁失败
                log.warn("获取锁失败, lockKey={}, waitTime={}ms", lockKey, waitTime);
                throw new BusinessException("系统繁忙");
            }
            
            // 记录获取锁成功
            log.info("获取锁成功, lockKey={}, waitTime={}ms", lockKey, waitTime);
            
            try {
                long execStartTime = System.currentTimeMillis();
                T result = supplier.get();
                long execTime = System.currentTimeMillis() - execStartTime;
                
                // 记录业务执行时间
                log.info("业务执行完成, lockKey={}, execTime={}ms", lockKey, execTime);
                
                // 告警：业务执行时间过长
                if (execTime > 10000) {
                    log.warn("业务执行时间过长, lockKey={}, execTime={}ms", lockKey, execTime);
                }
                
                return result;
            } finally {
                lock.unlock();
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new BusinessException("操作被中断");
        }
    }
}
```

#### 使用示例

```java
@Service
public class OrderService {
    
    @Autowired
    private LockMonitor lockMonitor;
    
    public void createOrder(String userId, String productId) {
        String lockKey = "order:lock:" + userId;
        
        lockMonitor.executeWithLockMonitor(lockKey, () -> {
            // 业务逻辑
            doCreateOrder(userId, productId);
            return null;
        });
    }
}
```

---

## 四、高级使用场景

### 问题10：如何实现分布式限流？

```java
@Service
public class RateLimiterService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    /**
     * 限流：每秒最多10个请求
     */
    public boolean tryAcquire(String userId) {
        RRateLimiter rateLimiter = redissonClient.getRateLimiter("rate:limiter:" + userId);
        
        // 设置速率：每秒10个令牌
        rateLimiter.trySetRate(RateType.OVERALL, 10, 1, RateIntervalUnit.SECONDS);
        
        // 尝试获取1个令牌
        return rateLimiter.tryAcquire(1);
    }
    
    /**
     * 使用示例
     */
    public void handleRequest(String userId) {
        if (!tryAcquire(userId)) {
            throw new BusinessException("请求过于频繁，请稍后再试");
        }
        
        // 处理请求
        processRequest(userId);
    }
}
```

---

### 问题11：如何实现分布式信号量？

```java
@Service
public class SemaphoreService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    /**
     * 限制并发数：最多3个线程同时执行
     */
    public void executeWithSemaphore(Runnable task) {
        RSemaphore semaphore = redissonClient.getSemaphore("my:semaphore");
        
        try {
            // 设置许可数量
            semaphore.trySetPermits(3);
            
            // 获取许可
            boolean acquired = semaphore.tryAcquire(10, TimeUnit.SECONDS);
            if (!acquired) {
                throw new BusinessException("系统繁忙");
            }
            
            try {
                task.run();
            } finally {
                semaphore.release();
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 五、总结

### 核心要点

1. **使用 tryLock 而不是 lock**
   - 设置合理的等待时间
   - 快速失败，提升用户体验

2. **必须在 finally 中释放锁**
   - 保证锁一定会被释放
   - 避免死锁

3. **合理设计锁粒度**
   - 不要过大（影响并发）
   - 不要过小（无法保护资源）

4. **设置合理的过期时间**
   - 根据业务场景调整
   - 使用 WatchDog 处理不确定场景

5. **避免死锁**
   - 锁排序
   - 使用 MultiLock

6. **监控锁的使用**
   - 记录获取锁的时间
   - 记录业务执行时间
   - 及时发现性能问题

### 常见错误清单

| 错误 | 后果 | 解决方案 |
|------|------|----------|
| 忘记释放锁 | 死锁 | 使用 finally |
| 锁粒度过大 | 性能差 | 按业务维度加锁 |
| 不设置超时 | 无限等待 | 使用 tryLock |
| 循环等待 | 死锁 | 锁排序或 MultiLock |
| 业务时间过长 | 锁过期 | 使用 WatchDog |

---

**下一篇**：[08-源码中的设计精髓.md](./08-源码中的设计精髓.md) - 可借鉴的编码技巧
