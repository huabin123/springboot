# 限流熔断实战案例

## 目录
- [案例1：电商秒杀系统](#案例1电商秒杀系统)
- [案例2：微服务调用链保护](#案例2微服务调用链保护)
- [案例3：第三方API限流](#案例3第三方api限流)
- [案例4：动态限流策略](#案例4动态限流策略)
- [案例5：分布式限流实现](#案例5分布式限流实现)

---

## 案例1：电商秒杀系统

### 业务场景

某电商平台的秒杀活动：
- 商品数量：100件
- 预期流量：10万人同时抢购
- 系统容量：1000 QPS
- 要求：保证系统稳定，公平分配

### 问题分析

```
挑战：
1. 瞬时流量是系统容量的100倍
2. 99%的请求注定失败
3. 如何快速失败，避免资源浪费
4. 如何防止黄牛刷单
```

### 解决方案

#### 1. 多层限流

```java
@RestController
@RequestMapping("/seckill")
public class SeckillController {
    
    // 第1层：IP限流（防刷）
    @RateLimiter(key = "#request.remoteAddr", qps = 10, duration = 60)
    // 第2层：用户限流（防刷）
    @RateLimiter(key = "#userId", qps = 1, duration = 60)
    // 第3层：接口限流（保护系统）
    @RateLimiter(key = "seckill:create", qps = 1000)
    @PostMapping("/create")
    public Result seckill(@RequestParam Long productId, 
                         @RequestParam Long userId,
                         HttpServletRequest request) {
        return seckillService.createOrder(productId, userId);
    }
}
```

#### 2. 预热限流

```java
@Configuration
public class RateLimiterConfig {
    
    @Bean
    public RateLimiter seckillLimiter() {
        // 预热60秒，从100 QPS逐渐增加到1000 QPS
        // 避免冷启动时被瞬间打垮
        return RateLimiter.create(1000, 60, TimeUnit.SECONDS);
    }
}
```

#### 3. 令牌桶 + Redis预扣库存

```java
@Service
public class SeckillService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private RateLimiter rateLimiter;
    
    public Result createOrder(Long productId, Long userId) {
        // 1. 限流检查
        if (!rateLimiter.tryAcquire(100, TimeUnit.MILLISECONDS)) {
            return Result.fail("系统繁忙，请稍后再试");
        }
        
        // 2. Redis预扣库存（原子操作）
        String key = "seckill:stock:" + productId;
        Long stock = redisTemplate.opsForValue().decrement(key);
        
        if (stock < 0) {
            // 库存不足，回滚
            redisTemplate.opsForValue().increment(key);
            return Result.fail("商品已售罄");
        }
        
        // 3. 异步创建订单（避免阻塞）
        CompletableFuture.runAsync(() -> {
            try {
                orderService.createOrder(productId, userId);
            } catch (Exception e) {
                // 创建失败，回滚库存
                redisTemplate.opsForValue().increment(key);
                log.error("订单创建失败", e);
            }
        });
        
        return Result.success("抢购成功，订单生成中...");
    }
}
```

#### 4. 前端限流

```javascript
// 防止重复点击
let clicking = false;
let lastClickTime = 0;

function seckill() {
    const now = Date.now();
    
    // 1秒内只能点击一次
    if (now - lastClickTime < 1000) {
        alert('点击过于频繁，请稍后再试');
        return;
    }
    
    if (clicking) {
        alert('请勿重复提交');
        return;
    }
    
    clicking = true;
    lastClickTime = now;
    
    // 发送请求
    fetch('/seckill/create', {
        method: 'POST',
        body: JSON.stringify({productId, userId})
    })
    .then(response => response.json())
    .then(data => {
        alert(data.message);
    })
    .finally(() => {
        clicking = false;
    });
}
```

#### 5. Nginx限流

```nginx
# 限制每个IP每秒10个请求
limit_req_zone $binary_remote_addr zone=seckill:10m rate=10r/s;

server {
    location /seckill/ {
        # 允许突发20个请求，超过的直接拒绝
        limit_req zone=seckill burst=20 nodelay;
        
        # 返回友好的错误信息
        limit_req_status 429;
        
        proxy_pass http://backend;
    }
}
```

### 效果

```
优化前：
- 系统崩溃，无法访问
- 用户体验极差

优化后：
- 系统稳定，QPS控制在1000以内
- 99%的请求在100ms内返回（快速失败）
- 100件商品在3秒内售罄
- CPU使用率 < 60%
```

---

## 案例2：微服务调用链保护

### 业务场景

订单服务调用链：
```
订单服务 → 库存服务
        → 优惠券服务
        → 积分服务
        → 物流服务
```

问题：库存服务响应慢（3秒），导致订单服务线程池耗尽

### 问题分析

```
调用链路：
用户 → 订单服务 → 库存服务（3秒）
                → 优惠券服务（正常）
                → 积分服务（正常）
                → 物流服务（正常）

问题：
1. 库存服务慢，占用订单服务线程
2. 订单服务线程池（200个）很快耗尽
3. 其他正常服务也无法调用
4. 整个订单服务不可用
```

### 解决方案

#### 1. 熔断保护

```java
@Service
public class OrderService {
    
    @Autowired
    private StockService stockService;
    
    @Autowired
    private CouponService couponService;
    
    // 库存服务熔断配置
    @SentinelResource(
        value = "order:create",
        blockHandler = "handleBlock",
        fallback = "handleFallback"
    )
    public Result createOrder(OrderDTO orderDTO) {
        // 1. 检查库存（可能慢）
        Stock stock = stockService.checkStock(orderDTO.getProductId());
        
        // 2. 检查优惠券（正常）
        Coupon coupon = couponService.checkCoupon(orderDTO.getCouponId());
        
        // 3. 创建订单
        Order order = buildOrder(orderDTO, stock, coupon);
        orderRepository.save(order);
        
        return Result.success(order);
    }
    
    // 熔断降级方法
    public Result handleFallback(OrderDTO orderDTO, Throwable ex) {
        log.error("订单创建失败，降级处理", ex);
        
        // 降级策略：使用缓存的库存信息
        Stock cachedStock = stockCache.get(orderDTO.getProductId());
        if (cachedStock != null && cachedStock.getStock() > 0) {
            // 创建预订单，异步处理
            PreOrder preOrder = createPreOrder(orderDTO);
            return Result.success("订单已提交，请稍后查看");
        }
        
        return Result.fail("系统繁忙，请稍后再试");
    }
    
    // 限流处理
    public Result handleBlock(OrderDTO orderDTO, BlockException ex) {
        return Result.fail("当前订单量过大，请稍后再试");
    }
}
```

#### 2. 熔断规则配置

```java
@Configuration
public class SentinelConfig {
    
    @PostConstruct
    public void initRules() {
        // 熔断规则
        List<DegradeRule> rules = new ArrayList<>();
        
        // 规则1：慢调用比例
        DegradeRule slowCallRule = new DegradeRule("order:create")
            .setGrade(RuleConstant.DEGRADE_GRADE_RT)
            .setCount(1000)           // 响应时间超过1秒
            .setTimeWindow(10)        // 熔断10秒
            .setMinRequestAmount(5)   // 最少5个请求
            .setSlowRatioThreshold(0.5); // 慢调用比例50%
        
        // 规则2：异常比例
        DegradeRule exceptionRule = new DegradeRule("order:create")
            .setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO)
            .setCount(0.5)            // 异常率50%
            .setTimeWindow(10)        // 熔断10秒
            .setMinRequestAmount(5);  // 最少5个请求
        
        rules.add(slowCallRule);
        rules.add(exceptionRule);
        
        DegradeRuleManager.loadRules(rules);
        
        // 限流规则
        List<FlowRule> flowRules = new ArrayList<>();
        FlowRule flowRule = new FlowRule("order:create")
            .setCount(100)            // QPS 100
            .setGrade(RuleConstant.FLOW_GRADE_QPS);
        flowRules.add(flowRule);
        
        FlowRuleManager.loadRules(flowRules);
    }
}
```

#### 3. 线程池隔离

```java
@Configuration
public class ThreadPoolConfig {
    
    // 为每个下游服务配置独立的线程池
    @Bean("stockThreadPool")
    public ThreadPoolTaskExecutor stockThreadPool() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("stock-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    @Bean("couponThreadPool")
    public ThreadPoolTaskExecutor couponThreadPool() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(50);
        executor.setThreadNamePrefix("coupon-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

@Service
public class StockService {
    
    @Autowired
    @Qualifier("stockThreadPool")
    private ThreadPoolTaskExecutor stockThreadPool;
    
    public Stock checkStock(Long productId) {
        // 使用独立线程池，隔离故障
        CompletableFuture<Stock> future = CompletableFuture.supplyAsync(
            () -> stockClient.getStock(productId),
            stockThreadPool
        );
        
        try {
            // 超时控制
            return future.get(1, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            // 超时，取消任务
            future.cancel(true);
            throw new ServiceException("库存服务超时");
        }
    }
}
```

### 效果

```
优化前：
- 库存服务慢，拖垮整个订单服务
- 订单服务不可用
- 影响所有用户

优化后：
- 库存服务慢，只影响库存相关功能
- 订单服务整体可用
- 其他服务正常运行
- 熔断后使用缓存降级，用户体验良好
```

---

## 案例3：第三方API限流

### 业务场景

调用第三方短信API：
- 限制：每秒10次，每天1000次
- 超过限制：账号被封
- 要求：精确控制调用频率

### 解决方案

#### 1. 多级限流

```java
@Service
public class SmsService {
    
    // 秒级限流
    private RateLimiter secondLimiter = RateLimiter.create(10);
    
    // 天级限流
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public boolean sendSms(String phone, String content) {
        // 1. 秒级限流
        if (!secondLimiter.tryAcquire(100, TimeUnit.MILLISECONDS)) {
            log.warn("短信发送过快，触发秒级限流");
            return false;
        }
        
        // 2. 天级限流
        String dayKey = "sms:day:" + LocalDate.now();
        Long count = redisTemplate.opsForValue().increment(dayKey);
        
        if (count == 1) {
            // 第一次，设置过期时间
            redisTemplate.expire(dayKey, 1, TimeUnit.DAYS);
        }
        
        if (count > 1000) {
            log.warn("短信发送达到日限额");
            return false;
        }
        
        // 3. 调用第三方API
        try {
            smsClient.send(phone, content);
            return true;
        } catch (Exception e) {
            // 失败，回滚计数
            redisTemplate.opsForValue().decrement(dayKey);
            log.error("短信发送失败", e);
            return false;
        }
    }
}
```

#### 2. 优先级队列

```java
@Service
public class PrioritySmsService {
    
    // 高优先级队列（验证码、告警）
    private BlockingQueue<SmsTask> highPriorityQueue = new LinkedBlockingQueue<>(100);
    
    // 低优先级队列（营销短信）
    private BlockingQueue<SmsTask> lowPriorityQueue = new LinkedBlockingQueue<>(1000);
    
    @PostConstruct
    public void init() {
        // 启动消费线程
        new Thread(this::consume).start();
    }
    
    public void sendSms(String phone, String content, Priority priority) {
        SmsTask task = new SmsTask(phone, content);
        
        try {
            if (priority == Priority.HIGH) {
                highPriorityQueue.put(task);
            } else {
                lowPriorityQueue.put(task);
            }
        } catch (InterruptedException e) {
            log.error("短信任务入队失败", e);
        }
    }
    
    private void consume() {
        RateLimiter limiter = RateLimiter.create(10); // 每秒10条
        
        while (true) {
            try {
                // 优先消费高优先级队列
                SmsTask task = highPriorityQueue.poll();
                if (task == null) {
                    task = lowPriorityQueue.poll(1, TimeUnit.SECONDS);
                }
                
                if (task != null) {
                    limiter.acquire(); // 限流
                    smsClient.send(task.getPhone(), task.getContent());
                }
            } catch (Exception e) {
                log.error("短信发送失败", e);
            }
        }
    }
}
```

#### 3. 熔断保护

```java
@Service
public class SmsServiceWithCircuitBreaker {
    
    @Autowired
    private SmsClient smsClient;
    
    @SentinelResource(
        value = "sms:send",
        blockHandler = "handleBlock",
        fallback = "handleFallback"
    )
    public boolean sendSms(String phone, String content) {
        return smsClient.send(phone, content);
    }
    
    // 降级方法：保存到数据库，稍后重试
    public boolean handleFallback(String phone, String content, Throwable ex) {
        log.error("短信发送失败，保存到数据库", ex);
        
        SmsTask task = new SmsTask(phone, content);
        task.setStatus(TaskStatus.PENDING);
        task.setRetryCount(0);
        smsTaskRepository.save(task);
        
        return false;
    }
    
    // 限流处理
    public boolean handleBlock(String phone, String content, BlockException ex) {
        log.warn("短信发送触发限流");
        return false;
    }
}

// 定时重试任务
@Component
public class SmsRetryTask {
    
    @Scheduled(fixedRate = 60000) // 每分钟执行一次
    public void retry() {
        List<SmsTask> tasks = smsTaskRepository.findPendingTasks();
        
        for (SmsTask task : tasks) {
            if (task.getRetryCount() >= 3) {
                // 重试3次失败，标记为失败
                task.setStatus(TaskStatus.FAILED);
                smsTaskRepository.save(task);
                continue;
            }
            
            boolean success = smsService.sendSms(task.getPhone(), task.getContent());
            if (success) {
                task.setStatus(TaskStatus.SUCCESS);
            } else {
                task.setRetryCount(task.getRetryCount() + 1);
            }
            smsTaskRepository.save(task);
        }
    }
}
```

---

## 案例4：动态限流策略

### 业务场景

根据系统负载动态调整限流阈值：
- CPU < 50%：放宽限流
- CPU 50-80%：正常限流
- CPU > 80%：收紧限流

### 解决方案

```java
@Component
public class DynamicRateLimiter {
    
    private volatile int currentQps = 1000; // 当前QPS阈值
    
    private RateLimiter rateLimiter = RateLimiter.create(currentQps);
    
    @Autowired
    private SystemMonitor systemMonitor;
    
    // 每5秒调整一次
    @Scheduled(fixedRate = 5000)
    public void adjustRateLimit() {
        double cpuUsage = systemMonitor.getCpuUsage();
        double memoryUsage = systemMonitor.getMemoryUsage();
        int activeThreads = systemMonitor.getActiveThreads();
        
        int newQps = calculateQps(cpuUsage, memoryUsage, activeThreads);
        
        if (newQps != currentQps) {
            log.info("动态调整限流阈值：{} -> {}", currentQps, newQps);
            currentQps = newQps;
            rateLimiter.setRate(newQps);
        }
    }
    
    private int calculateQps(double cpuUsage, double memoryUsage, int activeThreads) {
        // 基准QPS
        int baseQps = 1000;
        
        // CPU因子
        double cpuFactor;
        if (cpuUsage < 50) {
            cpuFactor = 1.5;  // CPU充足，放宽限流
        } else if (cpuUsage < 80) {
            cpuFactor = 1.0;  // CPU正常
        } else {
            cpuFactor = 0.5;  // CPU过高，收紧限流
        }
        
        // 内存因子
        double memoryFactor;
        if (memoryUsage < 70) {
            memoryFactor = 1.0;
        } else if (memoryUsage < 85) {
            memoryFactor = 0.8;
        } else {
            memoryFactor = 0.5;
        }
        
        // 线程因子
        double threadFactor;
        int maxThreads = 200;
        if (activeThreads < maxThreads * 0.7) {
            threadFactor = 1.0;
        } else if (activeThreads < maxThreads * 0.9) {
            threadFactor = 0.8;
        } else {
            threadFactor = 0.5;
        }
        
        // 综合计算
        int newQps = (int) (baseQps * cpuFactor * memoryFactor * threadFactor);
        
        // 限制范围：100-2000
        return Math.max(100, Math.min(2000, newQps));
    }
    
    public boolean tryAcquire() {
        return rateLimiter.tryAcquire();
    }
}
```

---

## 案例5：分布式限流实现

### 业务场景

3台服务器，总限流1000 QPS，如何精确控制？

### 解决方案

#### 方案1：Redis + Lua（精确）

```lua
-- 滑动窗口限流
-- KEYS[1]: 限流key
-- ARGV[1]: 限流阈值
-- ARGV[2]: 窗口大小（秒）
-- ARGV[3]: 当前时间戳（毫秒）

local key = KEYS[1]
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local now = tonumber(ARGV[3])

-- 移除窗口外的数据
redis.call('ZREMRANGEBYSCORE', key, 0, now - window * 1000)

-- 获取当前窗口内的请求数
local count = redis.call('ZCARD', key)

if count < limit then
    -- 未超限，添加当前请求
    redis.call('ZADD', key, now, now .. math.random())
    redis.call('EXPIRE', key, window + 1)
    return 1
else
    -- 超限
    return 0
end
```

```java
@Component
public class RedisRateLimiter {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private RedisScript<Long> rateLimitScript;
    
    public boolean tryAcquire(String key, int limit, int window) {
        List<String> keys = Collections.singletonList(key);
        Long result = redisTemplate.execute(
            rateLimitScript,
            keys,
            String.valueOf(limit),
            String.valueOf(window),
            String.valueOf(System.currentTimeMillis())
        );
        
        return result != null && result == 1;
    }
}

@Configuration
public class RedisConfig {
    
    @Bean
    public RedisScript<Long> rateLimitScript() {
        DefaultRedisScript<Long> script = new DefaultRedisScript<>();
        script.setScriptText(loadScript());
        script.setResultType(Long.class);
        return script;
    }
    
    private String loadScript() {
        // 加载上面的Lua脚本
        return "...";
    }
}
```

#### 方案2：令牌桶 + Redis（高性能）

```java
@Component
public class TokenBucketRateLimiter {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    /**
     * 令牌桶算法
     * @param key 限流key
     * @param capacity 桶容量
     * @param rate 令牌生成速率（每秒）
     * @param tokens 需要的令牌数
     * @return 是否获取成功
     */
    public boolean tryAcquire(String key, int capacity, int rate, int tokens) {
        String script = 
            "local capacity = tonumber(ARGV[1])\n" +
            "local rate = tonumber(ARGV[2])\n" +
            "local tokens = tonumber(ARGV[3])\n" +
            "local now = tonumber(ARGV[4])\n" +
            "\n" +
            "local bucket = redis.call('HMGET', KEYS[1], 'tokens', 'last_time')\n" +
            "local last_tokens = tonumber(bucket[1]) or capacity\n" +
            "local last_time = tonumber(bucket[2]) or now\n" +
            "\n" +
            "-- 计算新增的令牌数\n" +
            "local delta = math.max(0, now - last_time)\n" +
            "local new_tokens = math.min(capacity, last_tokens + delta * rate / 1000)\n" +
            "\n" +
            "if new_tokens >= tokens then\n" +
            "    -- 令牌足够，扣除令牌\n" +
            "    redis.call('HMSET', KEYS[1], 'tokens', new_tokens - tokens, 'last_time', now)\n" +
            "    redis.call('EXPIRE', KEYS[1], 60)\n" +
            "    return 1\n" +
            "else\n" +
            "    -- 令牌不足\n" +
            "    redis.call('HMSET', KEYS[1], 'tokens', new_tokens, 'last_time', now)\n" +
            "    redis.call('EXPIRE', KEYS[1], 60)\n" +
            "    return 0\n" +
            "end";
        
        List<String> keys = Collections.singletonList(key);
        Long result = (Long) redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            keys,
            String.valueOf(capacity),
            String.valueOf(rate),
            String.valueOf(tokens),
            String.valueOf(System.currentTimeMillis())
        );
        
        return result != null && result == 1;
    }
}
```

#### 方案3：Sentinel集群限流（推荐）

```java
// 1. 配置Token Server
@Configuration
public class SentinelClusterConfig {
    
    @PostConstruct
    public void init() {
        // 配置Token Server地址
        ClusterClientConfig config = new ClusterClientConfig();
        config.setServerHost("token-server-host");
        config.setServerPort(8719);
        ClusterClientConfigManager.applyNewConfig(config);
        
        // 配置集群限流规则
        List<FlowRule> rules = new ArrayList<>();
        FlowRule rule = new FlowRule("resource")
            .setCount(1000)  // 集群总限流1000 QPS
            .setGrade(RuleConstant.FLOW_GRADE_QPS)
            .setClusterMode(true)  // 开启集群模式
            .setClusterConfig(new ClusterFlowConfig()
                .setThresholdType(ClusterFlowConfig.FLOW_THRESHOLD_GLOBAL));
        
        rules.add(rule);
        FlowRuleManager.loadRules(rules);
    }
}

// 2. 使用
@Service
public class OrderService {
    
    @SentinelResource(value = "createOrder", blockHandler = "handleBlock")
    public Result createOrder(OrderDTO orderDTO) {
        // 业务逻辑
        return Result.success();
    }
    
    public Result handleBlock(OrderDTO orderDTO, BlockException ex) {
        return Result.fail("系统繁忙");
    }
}
```

### 性能对比

| 方案 | 精确度 | 性能 | 复杂度 | 推荐度 |
|------|--------|------|--------|--------|
| Redis + Lua | 100% | 中 | 中 | ⭐⭐⭐⭐ |
| 令牌桶 + Redis | 95% | 高 | 高 | ⭐⭐⭐⭐⭐ |
| Sentinel集群 | 98% | 高 | 低 | ⭐⭐⭐⭐⭐ |

---

## 总结

### 关键要点

1. **分层防护**：前端 → 网关 → 应用 → 服务
2. **快速失败**：避免资源浪费
3. **优雅降级**：提供备选方案
4. **动态调整**：根据负载自适应
5. **监控告警**：及时发现问题

### 最佳实践

```java
// 完整的限流熔断模板
@Service
public class BestPracticeService {
    
    // 1. 限流器
    private RateLimiter rateLimiter = RateLimiter.create(100);
    
    // 2. 熔断 + 降级
    @SentinelResource(
        value = "bestPractice",
        blockHandler = "handleBlock",
        fallback = "handleFallback"
    )
    public Result process(Request request) {
        // 3. 限流检查
        if (!rateLimiter.tryAcquire(100, TimeUnit.MILLISECONDS)) {
            throw new RateLimitException("请求过于频繁");
        }
        
        // 4. 参数校验
        validate(request);
        
        // 5. 业务逻辑
        return doProcess(request);
    }
    
    // 6. 降级方法
    public Result handleFallback(Request request, Throwable ex) {
        log.error("业务处理失败，降级处理", ex);
        return getCachedResult(request);
    }
    
    // 7. 限流处理
    public Result handleBlock(Request request, BlockException ex) {
        log.warn("触发限流");
        return Result.fail("系统繁忙，请稍后再试");
    }
}
```
