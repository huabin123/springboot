# MySQL和Spring事务学习指南

## 一、学习路径

### 1.1 学习顺序

```
第一阶段：MySQL基础
├── 01-MySQL锁机制.md
│   ├── 表级锁、行级锁
│   ├── 共享锁、排他锁
│   ├── 乐观锁、悲观锁
│   └── 死锁分析
│
├── 02-MVCC机制.md
│   ├── 隐藏字段
│   ├── Undo Log版本链
│   ├── Read View
│   └── 快照读vs当前读
│
└── 03-Redo和Undo日志.md
    ├── Redo Log原理
    ├── Undo Log原理
    ├── WAL机制
    └── 两阶段提交

第二阶段：Spring事务
├── 04-Spring事务原理.md
│   ├── @Transactional原理
│   ├── AOP代理机制
│   ├── 事务传播行为
│   └── 事务隔离级别
│
└── 05-事务失效场景分析.md
    ├── 12种常见失效场景
    ├── 原因分析
    └── 解决方案
```

### 1.2 预计学习时间

- **MySQL锁机制**：2-3小时
- **MVCC机制**：2-3小时
- **Redo和Undo日志**：2-3小时
- **Spring事务原理**：3-4小时
- **事务失效场景**：2-3小时
- **实战练习**：5-8小时

**总计**：16-24小时

## 二、环境准备

### 2.1 启动MySQL容器

```bash
cd /Users/huabin/workspace/playground/my-github/springboot/doc/env/mysql
docker compose up -d
```

### 2.2 初始化数据库

```bash
# 连接MySQL
mysql -h 127.0.0.1 -P 3306 -u root -p

# 执行初始化脚本
source /path/to/springboot-transaction-learning/src/main/resources/sql/init.sql
```

或者使用MySQL客户端工具（如Navicat、DBeaver）执行`init.sql`脚本。

### 2.3 启动应用

```bash
cd springboot-transaction-learning
mvn spring-boot:run
```

访问：http://localhost:8080

## 三、实战练习

### 3.1 行锁练习

#### 练习1：排他锁（FOR UPDATE）

**目标**：理解排他锁的阻塞特性

**步骤**：
1. 打开两个MySQL客户端窗口
2. 窗口1执行：
```sql
BEGIN;
SELECT * FROM account WHERE id = 1 FOR UPDATE;
-- 不要提交，保持事务
```

3. 窗口2执行：
```sql
BEGIN;
SELECT * FROM account WHERE id = 1 FOR UPDATE;
-- 会被阻塞，等待窗口1释放锁
```

4. 窗口1提交：
```sql
COMMIT;
-- 窗口2立即获得锁
```

**思考**：
- 为什么窗口2会被阻塞？
- 如果窗口2使用普通SELECT会怎样？

#### 练习2：共享锁（LOCK IN SHARE MODE）

**步骤**：
1. 窗口1执行：
```sql
BEGIN;
SELECT * FROM account WHERE id = 1 LOCK IN SHARE MODE;
```

2. 窗口2执行：
```sql
BEGIN;
SELECT * FROM account WHERE id = 1 LOCK IN SHARE MODE;
-- 不会被阻塞，可以同时持有共享锁
```

3. 窗口2尝试更新：
```sql
UPDATE account SET balance = 2000 WHERE id = 1;
-- 会被阻塞，因为窗口1持有共享锁
```

**思考**：
- 共享锁和排他锁的区别是什么？
- 什么场景下使用共享锁？

#### 练习3：死锁演示

**步骤**：
1. 窗口1执行：
```sql
BEGIN;
SELECT * FROM account WHERE id = 1 FOR UPDATE;
-- 等待5秒
SELECT * FROM account WHERE id = 2 FOR UPDATE;
```

2. 窗口2执行（在窗口1等待期间）：
```sql
BEGIN;
SELECT * FROM account WHERE id = 2 FOR UPDATE;
-- 等待5秒
SELECT * FROM account WHERE id = 1 FOR UPDATE;
-- 死锁！MySQL会自动回滚其中一个事务
```

3. 查看死锁信息：
```sql
SHOW ENGINE INNODB STATUS;
```

**思考**：
- 如何避免死锁？
- MySQL如何检测死锁？

### 3.2 间隙锁练习

#### 练习1：间隙锁的产生

**当前数据**：age = 10, 20, 30, 50

**步骤**：
1. 窗口1执行：
```sql
BEGIN;
SELECT * FROM user WHERE age BETWEEN 20 AND 30 FOR UPDATE;
-- 产生间隙锁：(10,20), (20,30), (30,50)
```

2. 窗口2尝试插入：
```sql
BEGIN;
INSERT INTO user (age, name, email) VALUES (15, 'test', 'test@test.com');
-- 被阻塞，因为15在间隙(10,20)中
```

3. 窗口2尝试插入：
```sql
INSERT INTO user (age, name, email) VALUES (25, 'test', 'test@test.com');
-- 被阻塞，因为25在间隙(20,30)中
```

4. 窗口2尝试插入：
```sql
INSERT INTO user (age, name, email) VALUES (60, 'test', 'test@test.com');
-- 成功，因为60不在锁定的间隙中
```

**思考**：
- 间隙锁的作用是什么？
- 如何避免间隙锁？

### 3.3 MVCC练习

#### 练习1：READ COMMITTED vs REPEATABLE READ

**步骤**：
1. 设置隔离级别为READ COMMITTED：
```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

2. 窗口1执行：
```sql
BEGIN;
SELECT balance FROM account WHERE id = 1;  -- 假设结果是1000
-- 不要提交
```

3. 窗口2执行：
```sql
BEGIN;
UPDATE account SET balance = 2000 WHERE id = 1;
COMMIT;
```

4. 窗口1再次查询：
```sql
SELECT balance FROM account WHERE id = 1;  -- 结果是2000（不可重复读）
COMMIT;
```

5. 改为REPEATABLE READ：
```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

6. 重复步骤2-4：
```sql
-- 窗口1
BEGIN;
SELECT balance FROM account WHERE id = 1;  -- 1000
-- 窗口2修改并提交
SELECT balance FROM account WHERE id = 1;  -- 仍然是1000（可重复读）
COMMIT;
```

**思考**：
- 两种隔离级别的区别是什么？
- 什么场景下使用READ COMMITTED？

#### 练习2：快照读vs当前读

**步骤**：
```sql
-- 窗口1
BEGIN;
SELECT balance FROM account WHERE id = 1;  -- 快照读：1000

-- 窗口2
BEGIN;
UPDATE account SET balance = 2000 WHERE id = 1;
COMMIT;

-- 窗口1
SELECT balance FROM account WHERE id = 1;  -- 快照读：1000
SELECT balance FROM account WHERE id = 1 FOR UPDATE;  -- 当前读：2000
COMMIT;
```

**思考**：
- 快照读和当前读的区别是什么？
- 什么时候使用当前读？

### 3.4 Spring事务练习

#### 练习1：事务传播行为

**使用API测试**：

1. **REQUIRED测试**：
```bash
curl -X POST http://localhost:8080/transaction/propagation/required
```

2. **REQUIRES_NEW测试**：
```bash
# 不抛异常
curl -X POST http://localhost:8080/transaction/propagation/requires-new?throwException=false

# 抛异常（观察日志是否保存）
curl -X POST http://localhost:8080/transaction/propagation/requires-new?throwException=true
```

3. **NESTED测试**：
```bash
# 内层异常，外层正常
curl -X POST "http://localhost:8080/transaction/propagation/nested?innerException=true&outerException=false"

# 外层异常
curl -X POST "http://localhost:8080/transaction/propagation/nested?innerException=false&outerException=true"
```

**思考**：
- REQUIRES_NEW和NESTED的区别是什么？
- 什么场景下使用REQUIRES_NEW？

#### 练习2：事务失效场景

1. **自调用失效**：
```bash
curl -X POST http://localhost:8080/transaction/failure/self-invocation
```

查看日志，观察事务是否回滚。

2. **异常被捕获**：
```bash
curl -X POST http://localhost:8080/transaction/failure/exception-caught
```

查看数据库，数据是否被修改。

**思考**：
- 如何解决自调用问题？
- 如何正确处理异常？

### 3.5 综合练习：转账场景

#### 练习1：实现安全的转账

**需求**：
- 从账户A转账到账户B
- 保证原子性（要么都成功，要么都失败）
- 防止并发问题（使用锁）

**实现**：
```java
@Transactional(rollbackFor = Exception.class)
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    // 1. 锁定转出账户
    Account from = accountMapper.selectByIdForUpdate(fromId);
    
    // 2. 检查余额
    if (from.getBalance().compareTo(amount) < 0) {
        throw new RuntimeException("余额不足");
    }
    
    // 3. 锁定转入账户
    Account to = accountMapper.selectByIdForUpdate(toId);
    
    // 4. 执行转账
    accountMapper.deductBalance(fromId, amount);
    accountMapper.addBalance(toId, amount);
    
    // 5. 记录日志（使用REQUIRES_NEW，即使转账失败也要记录）
    logService.insertLog("TRANSFER", "转账：" + fromId + " -> " + toId);
}
```

**测试**：
```bash
curl -X POST "http://localhost:8080/transaction/row-lock/exclusive?fromId=1&toId=2&amount=100"
```

**思考**：
- 为什么要使用FOR UPDATE？
- 如何避免死锁？
- 日志应该使用什么传播行为？

#### 练习2：高并发转账测试

**使用JMeter或编写多线程测试**：

```java
@Test
public void concurrentTransferTest() throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(10);
    
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            try {
                transferService.transfer(1L, 2L, new BigDecimal("10"));
            } finally {
                latch.countDown();
            }
        }).start();
    }
    
    latch.await();
    
    // 验证账户余额是否正确
    Account account1 = accountMapper.selectById(1L);
    Account account2 = accountMapper.selectById(2L);
    
    // 断言余额
}
```

**思考**：
- 并发情况下，余额是否正确？
- 如何提高并发性能？

## 四、常见问题

### 4.1 MySQL相关

**Q1：如何查看当前的锁情况？**
```sql
-- 查看当前事务
SELECT * FROM information_schema.innodb_trx;

-- 查看锁等待
SELECT * FROM performance_schema.data_lock_waits;

-- 查看锁信息
SELECT * FROM performance_schema.data_locks;
```

**Q2：如何查看隔离级别？**
```sql
-- 查看全局隔离级别
SELECT @@global.transaction_isolation;

-- 查看会话隔离级别
SELECT @@session.transaction_isolation;
```

**Q3：如何避免长事务？**
- 及时提交事务
- 避免在事务中执行耗时操作
- 使用合理的超时时间

### 4.2 Spring事务相关

**Q1：如何判断当前是否在事务中？**
```java
boolean isActive = TransactionSynchronizationManager.isActualTransactionActive();
```

**Q2：如何手动回滚事务？**
```java
TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
```

**Q3：如何在事务提交后执行操作？**
```java
TransactionSynchronizationManager.registerSynchronization(
    new TransactionSynchronizationAdapter() {
        @Override
        public void afterCommit() {
            // 事务提交后执行
        }
    }
);
```

## 五、进阶学习

### 5.1 分布式事务

- **两阶段提交（2PC）**
- **三阶段提交（3PC）**
- **TCC（Try-Confirm-Cancel）**
- **Saga模式**
- **本地消息表**
- **MQ事务消息**

### 5.2 性能优化

- **批量操作**
- **读写分离**
- **分库分表**
- **缓存策略**
- **异步处理**

### 5.3 监控和排查

- **慢查询分析**
- **死锁分析**
- **事务监控**
- **性能分析**

## 六、参考资料

### 6.1 官方文档

- [MySQL官方文档](https://dev.mysql.com/doc/)
- [Spring Transaction文档](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction)

### 6.2 推荐书籍

- 《高性能MySQL》
- 《MySQL技术内幕：InnoDB存储引擎》
- 《Spring实战》

### 6.3 在线资源

- [MySQL官方博客](https://mysqlserverteam.com/)
- [Spring官方博客](https://spring.io/blog)

## 七、学习建议

### 7.1 理论与实践结合

- 先阅读文档，理解原理
- 再动手实践，验证理解
- 遇到问题，查看日志和源码

### 7.2 循序渐进

- 不要一次学习太多内容
- 每个知识点都要理解透彻
- 多做练习，加深理解

### 7.3 总结归纳

- 学完一个章节，写总结
- 整理常见问题和解决方案
- 建立自己的知识体系

### 7.4 实战应用

- 在实际项目中应用所学知识
- 遇到问题，思考如何优化
- 分享经验，帮助他人

## 八、检查清单

### 8.1 MySQL锁机制
- [ ] 理解表级锁和行级锁的区别
- [ ] 掌握共享锁和排他锁的使用
- [ ] 理解间隙锁和临键锁
- [ ] 能够分析和解决死锁问题
- [ ] 掌握乐观锁和悲观锁的应用场景

### 8.2 MVCC机制
- [ ] 理解MVCC的实现原理
- [ ] 掌握Read View的可见性判断
- [ ] 理解快照读和当前读的区别
- [ ] 掌握不同隔离级别的特点

### 8.3 Redo和Undo日志
- [ ] 理解Redo Log的作用
- [ ] 理解Undo Log的作用
- [ ] 掌握WAL机制
- [ ] 理解两阶段提交

### 8.4 Spring事务
- [ ] 理解@Transactional的原理
- [ ] 掌握7种事务传播行为
- [ ] 掌握事务隔离级别的设置
- [ ] 能够识别和解决事务失效问题
- [ ] 掌握编程式事务的使用

## 九、下一步

完成本模块学习后，可以继续学习：

1. **分布式事务**：Seata、TCC、Saga
2. **数据库优化**：索引优化、查询优化
3. **高并发处理**：缓存、消息队列、限流
4. **微服务架构**：Spring Cloud、Dubbo

祝学习顺利！🎉
