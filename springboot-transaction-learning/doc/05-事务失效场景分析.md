# Spring事务失效场景分析

## 一、概述

Spring事务是基于AOP代理实现的，在某些场景下，事务可能会失效。本文档详细分析常见的事务失效场景及解决方案。

## 二、常见失效场景

### 场景1：方法不是public

#### 问题描述
```java
@Service
public class UserService {
    
    @Transactional
    private void updateUser() {  // private方法
        // 事务不会生效
    }
    
    @Transactional
    protected void deleteUser() {  // protected方法
        // 事务不会生效
    }
}
```

#### 原因分析
- Spring AOP默认只代理public方法
- CGLIB代理可以代理protected方法，但Spring默认不这样做
- private方法无法被代理

#### 解决方案
```java
@Service
public class UserService {
    
    @Transactional
    public void updateUser() {  // 改为public
        // 事务生效
    }
}
```

### 场景2：方法被final修饰

#### 问题描述
```java
@Service
public class UserService {
    
    @Transactional
    public final void updateUser() {  // final方法
        // 使用CGLIB代理时，事务不会生效
    }
}
```

#### 原因分析
- CGLIB通过继承目标类创建代理
- final方法不能被重写
- 代理无法拦截final方法

#### 解决方案
```java
@Service
public class UserService {
    
    @Transactional
    public void updateUser() {  // 去掉final
        // 事务生效
    }
}
```

### 场景3：同一个类中方法调用（自调用）

#### 问题描述
```java
@Service
public class UserService {
    
    public void outerMethod() {
        // 直接调用，不经过代理
        this.innerMethod();  // 事务不会生效
    }
    
    @Transactional
    public void innerMethod() {
        // 事务不会生效
    }
}
```

#### 原因分析
```
调用流程：
outerMethod() -> this.innerMethod()
              ↑
              直接调用，不经过代理对象
```

Spring事务是基于代理实现的：
```
客户端 -> 代理对象 -> 目标对象
```

自调用时：
```
目标对象 -> this.innerMethod()
         ↑
         跳过了代理对象
```

#### 解决方案

##### 方案1：注入自己
```java
@Service
public class UserService {
    
    @Autowired
    private UserService self;  // 注入自己
    
    public void outerMethod() {
        self.innerMethod();  // 通过代理对象调用
    }
    
    @Transactional
    public void innerMethod() {
        // 事务生效
    }
}
```

##### 方案2：使用AopContext
```java
@Service
public class UserService {
    
    public void outerMethod() {
        UserService proxy = (UserService) AopContext.currentProxy();
        proxy.innerMethod();  // 通过代理对象调用
    }
    
    @Transactional
    public void innerMethod() {
        // 事务生效
    }
}
```

需要开启expose-proxy：
```java
@EnableAspectJAutoProxy(exposeProxy = true)
```

##### 方案3：拆分到不同的Service
```java
@Service
public class UserService {
    
    @Autowired
    private UserInnerService innerService;
    
    public void outerMethod() {
        innerService.innerMethod();  // 调用另一个Service
    }
}

@Service
public class UserInnerService {
    
    @Transactional
    public void innerMethod() {
        // 事务生效
    }
}
```

### 场景4：异常被捕获未抛出

#### 问题描述
```java
@Service
public class UserService {
    
    @Transactional
    public void updateUser() {
        try {
            // 数据库操作
            userMapper.update(...);
            
            // 抛出异常
            throw new RuntimeException("error");
            
        } catch (Exception e) {
            // 异常被捕获，事务不会回滚
            log.error("error", e);
        }
    }
}
```

#### 原因分析
- Spring事务通过捕获异常来判断是否回滚
- 异常被捕获后，Spring无法感知到异常
- 事务正常提交

#### 解决方案

##### 方案1：重新抛出异常
```java
@Transactional
public void updateUser() {
    try {
        userMapper.update(...);
        throw new RuntimeException("error");
    } catch (Exception e) {
        log.error("error", e);
        throw e;  // 重新抛出
    }
}
```

##### 方案2：手动回滚
```java
@Transactional
public void updateUser() {
    try {
        userMapper.update(...);
        throw new RuntimeException("error");
    } catch (Exception e) {
        log.error("error", e);
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}
```

### 场景5：异常类型不匹配

#### 问题描述
```java
@Service
public class UserService {
    
    @Transactional  // 默认只回滚RuntimeException
    public void updateUser() throws Exception {
        userMapper.update(...);
        
        // 抛出受检异常，事务不会回滚
        throw new Exception("error");
    }
}
```

#### 原因分析
- @Transactional默认只回滚RuntimeException和Error
- 受检异常（Checked Exception）不会触发回滚

#### 解决方案
```java
@Transactional(rollbackFor = Exception.class)  // 指定回滚所有异常
public void updateUser() throws Exception {
    userMapper.update(...);
    throw new Exception("error");  // 会回滚
}
```

**推荐做法**：
```java
@Transactional(rollbackFor = Exception.class)  // 总是指定rollbackFor
```

### 场景6：数据库引擎不支持事务

#### 问题描述
```sql
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(50)
) ENGINE=MyISAM;  -- MyISAM不支持事务
```

#### 原因分析
- MyISAM存储引擎不支持事务
- 即使使用@Transactional，也无法回滚

#### 解决方案
```sql
-- 使用InnoDB引擎
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(50)
) ENGINE=InnoDB;

-- 修改现有表的引擎
ALTER TABLE user ENGINE=InnoDB;
```

### 场景7：未被Spring管理

#### 问题描述
```java
// 没有@Service注解
public class UserService {
    
    @Transactional
    public void updateUser() {
        // 事务不会生效
    }
}
```

#### 原因分析
- 类没有被Spring管理（没有@Service、@Component等注解）
- Spring无法为其创建代理对象

#### 解决方案
```java
@Service  // 添加@Service注解
public class UserService {
    
    @Transactional
    public void updateUser() {
        // 事务生效
    }
}
```

### 场景8：多线程调用

#### 问题描述
```java
@Service
public class UserService {
    
    @Transactional
    public void updateUser() {
        // 主线程操作
        userMapper.update(...);
        
        // 在新线程中操作
        new Thread(() -> {
            // 这里的操作不在同一个事务中
            orderMapper.insert(...);
        }).start();
        
        // 主线程抛出异常，只回滚主线程的操作
        throw new RuntimeException("error");
    }
}
```

#### 原因分析
- Spring事务是基于ThreadLocal实现的
- 不同线程有不同的事务上下文
- 子线程的操作不在父线程的事务中

#### 解决方案

##### 方案1：不使用多线程
```java
@Transactional
public void updateUser() {
    userMapper.update(...);
    orderMapper.insert(...);  // 在同一个线程中执行
}
```

##### 方案2：使用编程式事务
```java
@Autowired
private TransactionTemplate transactionTemplate;

public void updateUser() {
    // 主线程事务
    transactionTemplate.execute(status -> {
        userMapper.update(...);
        return null;
    });
    
    // 子线程事务
    new Thread(() -> {
        transactionTemplate.execute(status -> {
            orderMapper.insert(...);
            return null;
        });
    }).start();
}
```

### 场景9：传播行为设置错误

#### 问题描述
```java
@Service
public class UserService {
    
    @Transactional
    public void outerMethod() {
        userMapper.update(...);
        
        // 调用REQUIRES_NEW的方法
        innerService.innerMethod();
        
        // 外层事务回滚，但innerMethod已在独立事务中提交
        throw new RuntimeException("error");
    }
}

@Service
public class InnerService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void innerMethod() {
        orderMapper.insert(...);
        // 这个操作不会回滚
    }
}
```

#### 原因分析
- REQUIRES_NEW会创建新事务
- 新事务独立于外层事务
- 外层事务回滚不影响新事务

#### 解决方案

##### 方案1：使用REQUIRED（默认）
```java
@Transactional(propagation = Propagation.REQUIRED)
public void innerMethod() {
    // 加入外层事务，一起回滚
}
```

##### 方案2：使用NESTED
```java
@Transactional(propagation = Propagation.NESTED)
public void innerMethod() {
    // 嵌套事务，外层回滚时一起回滚
}
```

### 场景10：事务方法中使用了异步方法

#### 问题描述
```java
@Service
public class UserService {
    
    @Transactional
    public void updateUser() {
        userMapper.update(...);
        
        // 调用异步方法
        asyncService.sendEmail();  // 在新线程中执行
        
        throw new RuntimeException("error");
    }
}

@Service
public class AsyncService {
    
    @Async
    public void sendEmail() {
        // 这里的数据库操作不在同一个事务中
        emailMapper.insert(...);
    }
}
```

#### 原因分析
- @Async方法在新线程中执行
- 不在同一个事务上下文中

#### 解决方案
```java
@Transactional
public void updateUser() {
    userMapper.update(...);
    emailMapper.insert(...);  // 在同一个事务中执行
    
    // 事务提交后再发送邮件
}
```

### 场景11：数据源未配置事务管理器

#### 问题描述
```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        // 配置数据源
        return new HikariDataSource();
    }
    
    // 缺少事务管理器配置
}
```

#### 原因分析
- 没有配置PlatformTransactionManager
- Spring无法管理事务

#### 解决方案
```java
@Configuration
@EnableTransactionManagement
public class DataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

**Spring Boot会自动配置，通常不需要手动配置**

### 场景12：多数据源事务问题

#### 问题描述
```java
@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;  // 数据源1
    
    @Autowired
    private OrderMapper orderMapper;  // 数据源2
    
    @Transactional
    public void updateUserAndOrder() {
        userMapper.update(...);   // 数据源1
        orderMapper.insert(...);  // 数据源2
        
        // 只有一个数据源的操作会回滚
        throw new RuntimeException("error");
    }
}
```

#### 原因分析
- 单个事务管理器只能管理一个数据源
- 多数据源需要分布式事务

#### 解决方案

##### 方案1：使用分布式事务（JTA）
```java
@Configuration
@EnableTransactionManagement
public class JtaConfig {
    
    @Bean
    public JtaTransactionManager transactionManager() {
        return new JtaTransactionManager();
    }
}
```

##### 方案2：手动管理多个事务
```java
@Autowired
private PlatformTransactionManager txManager1;

@Autowired
private PlatformTransactionManager txManager2;

public void updateUserAndOrder() {
    TransactionStatus status1 = txManager1.getTransaction(new DefaultTransactionDefinition());
    TransactionStatus status2 = txManager2.getTransaction(new DefaultTransactionDefinition());
    
    try {
        userMapper.update(...);
        orderMapper.insert(...);
        
        txManager1.commit(status1);
        txManager2.commit(status2);
    } catch (Exception e) {
        txManager1.rollback(status1);
        txManager2.rollback(status2);
        throw e;
    }
}
```

## 三、事务失效检查清单

### 3.1 代码检查
- [ ] 方法是否为public
- [ ] 方法是否被final修饰
- [ ] 是否存在自调用
- [ ] 异常是否被捕获未抛出
- [ ] 异常类型是否匹配（是否指定rollbackFor）
- [ ] 类是否被Spring管理（是否有@Service等注解）
- [ ] 是否在多线程中调用
- [ ] 传播行为是否正确

### 3.2 配置检查
- [ ] 是否开启了@EnableTransactionManagement
- [ ] 是否配置了事务管理器
- [ ] 数据库引擎是否支持事务（InnoDB）
- [ ] 多数据源是否正确配置

### 3.3 运行时检查
```java
// 检查是否在事务中
boolean isActive = TransactionSynchronizationManager.isActualTransactionActive();
log.info("当前是否在事务中：{}", isActive);

// 检查是否是只读事务
boolean isReadOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
log.info("当前是否是只读事务：{}", isReadOnly);

// 获取当前事务名称
String txName = TransactionSynchronizationManager.getCurrentTransactionName();
log.info("当前事务名称：{}", txName);
```

## 四、最佳实践

### 4.1 推荐做法
```java
@Service
public class UserService {
    
    // 1. 使用public方法
    // 2. 指定rollbackFor
    // 3. 设置合理的超时时间
    @Transactional(rollbackFor = Exception.class, timeout = 30)
    public void updateUser(User user) {
        try {
            // 业务逻辑
            userMapper.update(user);
            
        } catch (Exception e) {
            log.error("更新用户失败", e);
            // 重新抛出异常，让Spring处理回滚
            throw e;
        }
    }
}
```

### 4.2 避免的做法
```java
// ❌ 不推荐
@Transactional
private void updateUser() { }  // private方法

@Transactional
public final void updateUser() { }  // final方法

@Transactional
public void updateUser() {
    this.innerMethod();  // 自调用
}

@Transactional
public void updateUser() {
    try {
        // ...
    } catch (Exception e) {
        // 异常被吞掉
    }
}
```

## 五、代码示例位置

- **事务失效场景演示**：`TransactionFailureService.java`
- **自调用问题**：`selfInvocationFailure()`
- **异常捕获问题**：`exceptionCaughtFailure()`
- **异常类型问题**：`wrongExceptionTypeFailure()`
- **多线程问题**：`multiThreadFailure()`
- **传播行为问题**：`propagationFailure()`

## 六、调试技巧

### 6.1 开启事务日志
```yaml
logging:
  level:
    org.springframework.jdbc.datasource.DataSourceTransactionManager: debug
    org.springframework.transaction: debug
```

### 6.2 查看事务状态
```java
@Transactional
public void method() {
    TransactionStatus status = TransactionAspectSupport.currentTransactionStatus();
    log.info("是否是新事务：{}", status.isNewTransaction());
    log.info("是否有保存点：{}", status.hasSavepoint());
    log.info("是否已完成：{}", status.isCompleted());
    log.info("是否只回滚：{}", status.isRollbackOnly());
}
```

### 6.3 使用AOP切面监控
```java
@Aspect
@Component
public class TransactionMonitorAspect {
    
    @Around("@annotation(org.springframework.transaction.annotation.Transactional)")
    public Object monitor(ProceedingJoinPoint pjp) throws Throwable {
        boolean isActive = TransactionSynchronizationManager.isActualTransactionActive();
        log.info("方法{}，事务是否激活：{}", pjp.getSignature(), isActive);
        
        return pjp.proceed();
    }
}
```
