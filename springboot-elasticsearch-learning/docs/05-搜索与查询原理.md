# 05-搜索与查询原理

## 引言

理解了倒排索引和分词后，接下来要掌握：**ES是如何执行搜索的？查询流程是什么样的？相关性评分如何计算？**

本文将深入剖析ES的搜索与查询原理。

---

## 问题1：ES的搜索流程是什么样的？

### 1.1 搜索的两个阶段

ES的搜索分为两个阶段：

```
┌─────────────────────────────────────────────────────┐
│              ES搜索流程（两阶段）                     │
├─────────────────────────────────────────────────────┤
│                                                      │
│  阶段1：Query Phase（查询阶段）                      │
│  ┌────────────────────────────────────────────┐    │
│  │ 1. 协调节点接收查询请求                    │    │
│  │ 2. 广播查询到所有相关分片                  │    │
│  │ 3. 各分片执行查询，计算评分                │    │
│  │ 4. 各分片返回文档ID和评分（Top N）         │    │
│  │ 5. 协调节点合并结果，排序                  │    │
│  └────────────────────────────────────────────┘    │
│                       ↓                              │
│  阶段2：Fetch Phase（获取阶段）                      │
│  ┌────────────────────────────────────────────┐    │
│  │ 1. 协调节点确定最终需要的文档ID            │    │
│  │ 2. 向相关分片请求完整文档                  │    │
│  │ 3. 各分片返回完整文档内容                  │    │
│  │ 4. 协调节点组装最终结果                    │    │
│  │ 5. 返回给客户端                            │    │
│  └────────────────────────────────────────────┘    │
│                                                      │
└─────────────────────────────────────────────────────┘
```

### 1.2 Query Phase详细流程

```
Query Phase流程图：

┌──────────┐
│ Client   │
│ 发起查询 │
└────┬─────┘
     │ 1. 查询请求
     ▼
┌─────────────────┐
│ Coordinating    │
│ Node            │
│ (协调节点)      │
└────┬────────────┘
     │ 2. 广播查询到所有分片
     ├──────────────┬──────────────┬──────────────┐
     ▼              ▼              ▼              ▼
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│Shard 0  │    │Shard 1  │    │Shard 2  │    │Shard 3  │
│(主或副本)│    │(主或副本)│    │(主或副本)│    │(主或副本)│
└────┬────┘    └────┬────┘    └────┬────┘    └────┬────┘
     │              │              │              │
     │ 3. 执行查询，计算评分，返回Top N的文档ID和评分
     │              │              │              │
     │ Doc1: 2.5    │ Doc5: 3.2    │ Doc9: 2.8    │ Doc13: 3.5
     │ Doc2: 2.3    │ Doc6: 2.9    │ Doc10: 2.6   │ Doc14: 3.1
     │ Doc3: 2.1    │ Doc7: 2.7    │ Doc11: 2.4   │ Doc15: 2.9
     │              │              │              │
     └──────┬───────┴──────────────┴──────────────┘
            ▼
     ┌─────────────────┐
     │ Coordinating    │
     │ Node            │
     │ 4. 合并结果     │
     │ 5. 全局排序     │
     │ 6. 选择Top N    │
     └────┬────────────┘
          │
          │ 最终Top 10:
          │ Doc13: 3.5
          │ Doc5: 3.2
          │ Doc14: 3.1
          │ ...
          ▼
     (进入Fetch Phase)

关键点：
- 每个分片只返回Top N的文档ID和评分
- 不返回完整文档内容（节省网络传输）
- 协调节点进行全局排序
```

### 1.3 Fetch Phase详细流程

```
Fetch Phase流程图：

┌─────────────────┐
│ Coordinating    │
│ Node            │
│ (已知需要的文档ID)│
└────┬────────────┘
     │ 1. 请求完整文档
     │    需要：Doc13, Doc5, Doc14, ...
     │
     ├──────────────┬──────────────┐
     ▼              ▼              ▼
┌─────────┐    ┌─────────┐    ┌─────────┐
│Shard 1  │    │Shard 2  │    │Shard 3  │
└────┬────┘    └────┬────┘    └────┬────┘
     │              │              │
     │ 2. 返回完整文档内容
     │              │              │
     │ Doc5:        │ Doc14:       │ Doc13:
     │ {            │ {            │ {
     │   title:..   │   title:..   │   title:..
     │   content:.. │   content:.. │   content:..
     │ }            │ }            │ }
     │              │              │
     └──────┬───────┴──────────────┘
            ▼
     ┌─────────────────┐
     │ Coordinating    │
     │ Node            │
     │ 3. 组装结果     │
     │ 4. 应用高亮     │
     │ 5. 返回客户端   │
     └────┬────────────┘
          ▼
     ┌──────────┐
     │ Client   │
     │ 收到结果 │
     └──────────┘

关键点：
- 只获取最终需要的文档
- 返回完整的文档内容
- 应用高亮等后处理
```

### 1.4 为什么要分两个阶段？

```
问题：为什么不在Query Phase就返回完整文档？

原因1：节省网络传输
假设：
- 3个分片，每个分片返回Top 10
- 如果返回完整文档：传输30个文档
- 实际只需要：Top 10个文档
- 浪费：20个文档的网络传输

原因2：减少内存占用
- 协调节点只需要存储文档ID和评分
- 不需要存储完整文档内容
- 内存占用小

原因3：提高性能
- Query Phase可以并行执行
- Fetch Phase只获取必要的文档
- 整体性能更好

示例对比：

一阶段方案（不推荐）：
- 3个分片各返回10个完整文档
- 网络传输：30个文档
- 内存占用：30个文档
- 实际使用：10个文档
- 浪费：66%

两阶段方案（ES采用）：
- Query Phase：传输30个文档ID（很小）
- Fetch Phase：传输10个完整文档
- 网络传输：10个文档 + 30个ID
- 内存占用：10个文档
- 浪费：0%
```

### 1.5 搜索类型

```
ES支持多种搜索类型：

1. Query Then Fetch（默认）
   - 两阶段搜索
   - 性能好，准确性高

2. DFS Query Then Fetch
   - 增加预查询阶段
   - 计算全局词频
   - 评分更准确，但性能略差

3. Count
   - 只返回匹配的文档数量
   - 不返回文档内容

4. Scroll
   - 用于大量数据的遍历
   - 维护搜索上下文
   - 适合导出数据

使用示例：
GET /products/_search?search_type=dfs_query_then_fetch
{
  "query": {
    "match": {
      "name": "手机"
    }
  }
}
```

---

## 问题2：Query和Filter有什么区别？

### 2.1 Query vs Filter

```
┌──────────────────────────────────────────────────────┐
│                Query vs Filter                        │
├──────────────────────────────────────────────────────┤
│                                                       │
│  Query（查询）                                        │
│  ┌─────────────────────────────────────────────┐    │
│  │ 特点：                                      │    │
│  │ - 计算相关性评分                            │    │
│  │ - 影响排序                                  │    │
│  │ - 不缓存                                    │    │
│  │                                              │    │
│  │ 使用场景：                                  │    │
│  │ - 全文搜索                                  │    │
│  │ - 需要相关性排序                            │    │
│  └─────────────────────────────────────────────┘    │
│                                                       │
│  Filter（过滤）                                       │
│  ┌─────────────────────────────────────────────┐    │
│  │ 特点：                                      │    │
│  │ - 不计算评分（评分为0）                     │    │
│  │ - 不影响排序                                │    │
│  │ - 可以缓存                                  │    │
│  │                                              │    │
│  │ 使用场景：                                  │    │
│  │ - 精确匹配                                  │    │
│  │ - 范围查询                                  │    │
│  │ - 布尔判断                                  │    │
│  └─────────────────────────────────────────────┘    │
│                                                       │
└──────────────────────────────────────────────────────┘
```

### 2.2 性能对比

```
场景：查询价格在1000-5000之间的手机

方式1：使用Query
{
  "query": {
    "bool": {
      "must": [
        {"match": {"name": "手机"}},
        {"range": {"price": {"gte": 1000, "lte": 5000}}}
      ]
    }
  }
}

问题：
- range查询会计算评分（没必要）
- 不能缓存
- 性能较差

方式2：使用Filter（推荐）
{
  "query": {
    "bool": {
      "must": [
        {"match": {"name": "手机"}}
      ],
      "filter": [
        {"range": {"price": {"gte": 1000, "lte": 5000}}}
      ]
    }
  }
}

优势：
- filter不计算评分
- 可以缓存
- 性能更好

性能对比：
- Query方式：100ms
- Filter方式：50ms（首次）
- Filter方式：10ms（缓存命中）
```

### 2.3 Filter缓存机制

```
Filter缓存原理：

1. 首次执行Filter
   - 执行查询
   - 生成Bitset（位图）
   - 缓存Bitset

2. 再次执行相同Filter
   - 直接从缓存读取Bitset
   - 无需重新查询
   - 速度极快

Bitset示例：
文档总数：10
Filter条件：price >= 1000

Bitset：[1, 0, 1, 1, 0, 0, 1, 0, 1, 1]
说明：
- 1表示匹配
- 0表示不匹配

优势：
- 内存占用小（1位表示1个文档）
- 查询速度快（位运算）
- 可以组合（AND、OR、NOT）
```

### 2.4 使用建议

```
使用Query的场景：
✓ 全文搜索
✓ 需要相关性评分
✓ 需要按评分排序

使用Filter的场景：
✓ 精确匹配（term查询）
✓ 范围查询（range查询）
✓ 存在性查询（exists查询）
✓ 布尔判断（是/否）

最佳实践：
1. 能用Filter就用Filter
2. Query和Filter结合使用
3. 将Filter放在外层（先过滤，再查询）

示例：
{
  "query": {
    "bool": {
      "must": [
        {"match": {"name": "手机"}}  // Query：需要评分
      ],
      "filter": [
        {"term": {"status": "active"}},  // Filter：不需要评分
        {"range": {"price": {"gte": 1000}}}  // Filter：不需要评分
      ]
    }
  }
}
```

---

## 问题3：相关性评分是如何计算的？

### 3.1 评分的作用

```
评分的作用：
1. 衡量文档与查询的相关程度
2. 决定搜索结果的排序
3. 影响用户体验

评分越高 → 相关性越高 → 排名越靠前
```

### 3.2 TF-IDF算法（ES 5.0之前）

#### TF（Term Frequency）- 词频

```
定义：
词在文档中出现的频率

公式：
TF(t, d) = 词t在文档d中出现的次数 / 文档d的总词数

示例：
文档1："手机 手机 很好用"
文档2："手机 很好用"

查询："手机"

TF(手机, 文档1) = 2 / 3 = 0.67
TF(手机, 文档2) = 1 / 2 = 0.5

结论：
文档1的TF更高 → 相关性更高
```

#### IDF（Inverse Document Frequency）- 逆文档频率

```
定义：
词的稀有程度

公式：
IDF(t) = log(文档总数 / 包含词t的文档数)

示例：
总文档数：1000
包含"手机"的文档：500
包含"iPhone"的文档：50

IDF(手机) = log(1000 / 500) = log(2) = 0.3
IDF(iPhone) = log(1000 / 50) = log(20) = 1.3

结论：
- "iPhone"更稀有 → IDF更高
- "手机"很常见 → IDF较低
- 稀有词的区分度更高
```

#### TF-IDF综合评分

```
公式：
Score = TF × IDF

示例：
查询："iPhone 手机"

文档1："iPhone 14 Pro 手机很好用"
- TF(iPhone) = 1/5 = 0.2
- IDF(iPhone) = 1.3
- TF(手机) = 1/5 = 0.2
- IDF(手机) = 0.3
- Score = (0.2 × 1.3) + (0.2 × 0.3) = 0.26 + 0.06 = 0.32

文档2："手机手机手机很好用"
- TF(iPhone) = 0
- IDF(iPhone) = 1.3
- TF(手机) = 3/4 = 0.75
- IDF(手机) = 0.3
- Score = (0 × 1.3) + (0.75 × 0.3) = 0 + 0.225 = 0.225

结论：
文档1评分更高（0.32 > 0.225）
虽然文档2的"手机"出现次数多，但缺少"iPhone"
```

### 3.3 BM25算法（ES 5.0+默认）

#### BM25的改进

```
TF-IDF的问题：
- TF线性增长，不合理
- 文档长度没有归一化

BM25的改进：
1. TF饱和度
   - TF不再线性增长
   - 达到一定值后增长变慢

2. 文档长度归一化
   - 考虑文档长度
   - 避免长文档占优势

3. 可调参数
   - k1：控制TF饱和度
   - b：控制长度归一化
```

#### BM25公式

```
简化公式：
Score(d, q) = Σ IDF(qi) × (f(qi, d) × (k1 + 1)) / (f(qi, d) + k1 × (1 - b + b × (|d| / avgdl)))

参数说明：
- qi：查询中的词
- f(qi, d)：词qi在文档d中的频率
- |d|：文档d的长度
- avgdl：平均文档长度
- k1：TF饱和度参数（默认1.2）
- b：长度归一化参数（默认0.75）

特点：
1. TF饱和
   - 词出现1次：权重增加很多
   - 词出现10次：权重增加不多
   - 词出现100次：权重几乎不增加

2. 长度归一化
   - 短文档：不会因为短而吃亏
   - 长文档：不会因为长而占优势
```

#### BM25 vs TF-IDF对比

```
场景：查询"手机"

文档1（短）："手机很好用"（4个词）
文档2（长）："这是一款非常好用的手机，手机的性能很强大，手机的价格也很合理"（20个词）

TF-IDF：
- 文档1：TF = 1/4 = 0.25
- 文档2：TF = 3/20 = 0.15
- 结论：文档1评分更高（合理）

但如果文档2是：
"手机手机手机手机手机手机手机手机手机手机手机手机手机手机手机手机手机手机手机手机"（20个手机）
- TF = 20/20 = 1.0
- 评分会非常高（不合理，堆砌关键词）

BM25：
- 文档1：Score ≈ 1.5
- 文档2（堆砌）：Score ≈ 2.0（增长有限）
- BM25的饱和机制避免了堆砌关键词的作弊
```

### 3.4 评分计算流程

```
评分计算流程图：

┌─────────────────┐
│ 1. 查询分词     │
│ "iPhone 手机"   │
│ → [iPhone, 手机]│
└────┬────────────┘
     ▼
┌─────────────────┐
│ 2. 查找倒排索引 │
│ iPhone → [Doc1] │
│ 手机 → [Doc1, Doc2]│
└────┬────────────┘
     ▼
┌─────────────────┐
│ 3. 计算每个词的评分│
│ Doc1:           │
│   iPhone: 1.3   │
│   手机: 0.3     │
│ Doc2:           │
│   手机: 0.3     │
└────┬────────────┘
     ▼
┌─────────────────┐
│ 4. 综合评分     │
│ Doc1: 1.6       │
│ Doc2: 0.3       │
└────┬────────────┘
     ▼
┌─────────────────┐
│ 5. 排序返回     │
│ [Doc1, Doc2]    │
└─────────────────┘
```

### 3.5 查看评分详情

```json
// 查看评分计算过程
GET /products/_search
{
  "explain": true,
  "query": {
    "match": {
      "name": "iPhone 手机"
    }
  }
}

// 返回结果包含详细的评分计算过程
{
  "hits": {
    "hits": [
      {
        "_score": 1.6,
        "_explanation": {
          "value": 1.6,
          "description": "sum of:",
          "details": [
            {
              "value": 1.3,
              "description": "weight(name:iphone)",
              "details": [...]
            },
            {
              "value": 0.3,
              "description": "weight(name:手机)",
              "details": [...]
            }
          ]
        }
      }
    ]
  }
}
```

---

## 问题4：常用的查询类型有哪些？

### 4.1 全文查询（Full Text Queries）

#### Match Query（匹配查询）

```json
// 最常用的查询
{
  "query": {
    "match": {
      "name": "苹果手机"
    }
  }
}

特点：
- 会分词
- 计算相关性评分
- 默认使用OR操作

分词过程：
"苹果手机" → ["苹果", "手机"]
匹配：包含"苹果"或"手机"的文档

指定AND操作：
{
  "query": {
    "match": {
      "name": {
        "query": "苹果手机",
        "operator": "and"
      }
    }
  }
}
```

#### Match Phrase Query（短语查询）

```json
// 要求词的顺序和位置
{
  "query": {
    "match_phrase": {
      "name": "苹果手机"
    }
  }
}

特点：
- 要求词连续出现
- 顺序必须一致

示例：
查询："苹果手机"
匹配："苹果手机很好用" ✓
不匹配："手机是苹果的" ✗（顺序不对）
不匹配："苹果的手机" ✗（不连续）

允许间隔：
{
  "query": {
    "match_phrase": {
      "name": {
        "query": "苹果手机",
        "slop": 1  // 允许间隔1个词
      }
    }
  }
}

匹配："苹果的手机" ✓（间隔1个词"的"）
```

#### Multi Match Query（多字段查询）

```json
// 在多个字段中搜索
{
  "query": {
    "multi_match": {
      "query": "iPhone",
      "fields": ["name", "description", "brand"]
    }
  }
}

字段权重：
{
  "query": {
    "multi_match": {
      "query": "iPhone",
      "fields": ["name^3", "description", "brand^2"]
    }
  }
}

说明：
- name字段权重3倍
- brand字段权重2倍
- description字段权重1倍
```

### 4.2 精确查询（Term Level Queries）

#### Term Query（精确匹配）

```json
// 不分词，精确匹配
{
  "query": {
    "term": {
      "status": "active"
    }
  }
}

特点：
- 不分词
- 精确匹配
- 适合keyword类型字段

注意：
// 错误示例
{
  "query": {
    "term": {
      "name": "iPhone 14"  // name是text类型，会被分词
    }
  }
}
// 不会匹配，因为索引中存储的是["iphone", "14"]

// 正确示例
{
  "query": {
    "term": {
      "name.keyword": "iPhone 14"  // 使用keyword字段
    }
  }
}
```

#### Terms Query（多值匹配）

```json
// 匹配多个值中的任意一个
{
  "query": {
    "terms": {
      "status": ["active", "pending"]
    }
  }
}

等价于SQL：
WHERE status IN ('active', 'pending')
```

#### Range Query（范围查询）

```json
// 范围查询
{
  "query": {
    "range": {
      "price": {
        "gte": 1000,  // >=
        "lte": 5000   // <=
      }
    }
  }
}

操作符：
- gte：大于等于（>=）
- gt：大于（>）
- lte：小于等于（<=）
- lt：小于（<）

日期范围：
{
  "query": {
    "range": {
      "created_at": {
        "gte": "2024-01-01",
        "lte": "2024-12-31"
      }
    }
  }
}
```

#### Exists Query（存在性查询）

```json
// 查询字段存在的文档
{
  "query": {
    "exists": {
      "field": "email"
    }
  }
}

// 查询字段不存在的文档
{
  "query": {
    "bool": {
      "must_not": [
        {"exists": {"field": "email"}}
      ]
    }
  }
}
```

### 4.3 复合查询（Compound Queries）

#### Bool Query（布尔查询）

```json
// 最强大的查询组合
{
  "query": {
    "bool": {
      "must": [
        {"match": {"name": "手机"}}
      ],
      "must_not": [
        {"term": {"status": "deleted"}}
      ],
      "should": [
        {"term": {"brand": "Apple"}},
        {"term": {"brand": "Huawei"}}
      ],
      "filter": [
        {"range": {"price": {"gte": 1000}}}
      ]
    }
  }
}

四种子句：
1. must：必须匹配，计算评分
2. must_not：必须不匹配，不计算评分
3. should：可以匹配，计算评分
4. filter：必须匹配，不计算评分

评分规则：
- must和should的评分会累加
- must_not和filter不影响评分

minimum_should_match：
{
  "query": {
    "bool": {
      "should": [
        {"term": {"tag": "5G"}},
        {"term": {"tag": "拍照"}},
        {"term": {"tag": "游戏"}}
      ],
      "minimum_should_match": 2  // 至少匹配2个
    }
  }
}
```

### 4.4 查询类型对比

```
┌──────────────┬────────┬────────┬──────────┬──────────┐
│ 查询类型     │ 分词   │ 评分   │ 缓存     │ 适用场景 │
├──────────────┼────────┼────────┼──────────┼──────────┤
│ Match        │ ✓      │ ✓      │ ✗        │ 全文搜索 │
│ Match Phrase │ ✓      │ ✓      │ ✗        │ 短语搜索 │
│ Multi Match  │ ✓      │ ✓      │ ✗        │ 多字段   │
│ Term         │ ✗      │ ✓      │ ✓        │ 精确匹配 │
│ Range        │ ✗      │ ✓      │ ✓        │ 范围查询 │
│ Bool(must)   │ -      │ ✓      │ ✗        │ 组合查询 │
│ Bool(filter) │ -      │ ✗      │ ✓        │ 过滤条件 │
└──────────────┴────────┴────────┴──────────┴──────────┘
```

---

## 总结

### 搜索流程

```
两阶段搜索：
1. Query Phase：查询、评分、返回Top N的ID
2. Fetch Phase：获取完整文档

优势：
- 节省网络传输
- 减少内存占用
- 提高性能
```

### Query vs Filter

```
Query：
- 计算评分
- 不缓存
- 用于全文搜索

Filter：
- 不计算评分
- 可缓存
- 用于精确匹配
```

### 相关性评分

```
BM25算法（ES 5.0+）：
- TF饱和度
- 文档长度归一化
- 避免关键词堆砌
```

### 常用查询

```
全文查询：Match、Match Phrase、Multi Match
精确查询：Term、Range、Exists
复合查询：Bool Query
```

---

**下一步**：深入理解分布式架构与数据分片

**相关文档**：
- [06-分布式架构与数据分片.md](./06-分布式架构与数据分片.md)
- [10-查询DSL实战指南.md](./10-查询DSL实战指南.md)
