# 16-æºç è®¾è®¡ç²¾åä¸å®æˆ˜å€Ÿé‰´

## æœ¬ç« æ¦‚è¿°

æœ¬ç« æ·±å…¥åˆ†æElasticsearchçš„æ ¸å¿ƒè®¾è®¡æ€æƒ³å’Œå®ç°åŸç†ï¼Œæç‚¼å¯å€Ÿé‰´çš„è®¾è®¡ç²¾åï¼š
- **é—®é¢˜1**ï¼šESçš„æ ¸å¿ƒè®¾è®¡æ€æƒ³æ˜¯ä»€ä¹ˆï¼Ÿ
- **é—®é¢˜2**ï¼šåˆ†å¸ƒå¼æ¶æ„å¦‚ä½•è®¾è®¡ï¼Ÿ
- **é—®é¢˜3**ï¼šå€’æ’ç´¢å¼•å¦‚ä½•å®ç°ï¼Ÿ
- **é—®é¢˜4**ï¼šæœ‰å“ªäº›ä¼˜ç§€çš„è®¾è®¡æ¨¡å¼ï¼Ÿ
- **é—®é¢˜5**ï¼šå¦‚ä½•åº”ç”¨åˆ°å®é™…é¡¹ç›®ä¸­ï¼Ÿ

---

## é—®é¢˜1ï¼šESçš„æ ¸å¿ƒè®¾è®¡æ€æƒ³

### 1.1 åˆ†å¸ƒå¼ä¼˜å…ˆï¼ˆDistributed Firstï¼‰

```
è®¾è®¡ç†å¿µï¼š
- å¤©ç”Ÿåˆ†å¸ƒå¼
- æ— å•ç‚¹æ•…éšœ
- è‡ªåŠ¨è´Ÿè½½å‡è¡¡
- æ˜“äºæ‰©å±•

æ ¸å¿ƒå®ç°ï¼š

1. è‡ªåŠ¨åˆ†ç‰‡
   - æ•°æ®è‡ªåŠ¨åˆ†å¸ƒåˆ°å¤šä¸ªèŠ‚ç‚¹
   - æ— éœ€æ‰‹åŠ¨å¹²é¢„

2. è‡ªåŠ¨å‰¯æœ¬
   - ä¸»å‰¯åˆ†ç‰‡æœºåˆ¶
   - è‡ªåŠ¨æ•…éšœè½¬ç§»

3. è‡ªåŠ¨å‘ç°
   - èŠ‚ç‚¹è‡ªåŠ¨å‘ç°
   - é›†ç¾¤è‡ªåŠ¨ç»„å»º

å€Ÿé‰´ç‚¹ï¼š
âœ… è®¾è®¡ç³»ç»Ÿæ—¶ä¼˜å…ˆè€ƒè™‘åˆ†å¸ƒå¼
âœ… é¿å…å•ç‚¹æ•…éšœ
âœ… è‡ªåŠ¨åŒ–ä¼˜äºæ‰‹åŠ¨é…ç½®
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿè®¾è®¡
 * å€Ÿé‰´ESçš„åˆ†å¸ƒå¼æ€æƒ³
 */
public class DistributedTaskScheduler {
    
    // 1. ä»»åŠ¡è‡ªåŠ¨åˆ†ç‰‡
    public void scheduleTask(Task task) {
        // æ ¹æ®ä»»åŠ¡IDè®¡ç®—åˆ†ç‰‡
        int shardId = hash(task.getId()) % totalShards;
        
        // è·¯ç”±åˆ°å¯¹åº”çš„èŠ‚ç‚¹
        Node node = getNodeByShard(shardId);
        node.execute(task);
    }
    
    // 2. è‡ªåŠ¨æ•…éšœè½¬ç§»
    public void handleNodeFailure(Node failedNode) {
        // è·å–å¤±è´¥èŠ‚ç‚¹çš„ä»»åŠ¡
        List<Task> tasks = failedNode.getTasks();
        
        // é‡æ–°åˆ†é…åˆ°å…¶ä»–èŠ‚ç‚¹
        for (Task task : tasks) {
            Node healthyNode = selectHealthyNode();
            healthyNode.execute(task);
        }
    }
    
    // 3. è‡ªåŠ¨èŠ‚ç‚¹å‘ç°
    public void discoverNodes() {
        // ä½¿ç”¨ZooKeeperæˆ–Consulè¿›è¡ŒæœåŠ¡å‘ç°
        List<Node> nodes = serviceDiscovery.getNodes();
        
        // æ›´æ–°é›†ç¾¤æ‹“æ‰‘
        updateClusterTopology(nodes);
    }
}
```

### 1.2 è¿‘å®æ—¶ï¼ˆNear Real-Timeï¼‰

```
è®¾è®¡ç†å¿µï¼š
- å¹³è¡¡å®æ—¶æ€§å’Œæ€§èƒ½
- 1ç§’å»¶è¿Ÿå¯æ¥å—
- æ‰¹é‡å¤„ç†æå‡æ€§èƒ½

æ ¸å¿ƒå®ç°ï¼š

1. Refreshæœºåˆ¶
   - é»˜è®¤1ç§’refreshä¸€æ¬¡
   - å°†å†…å­˜ç¼“å†²åŒºå†™å…¥segment
   - æ•°æ®å˜ä¸ºå¯æœç´¢

2. æ‰¹é‡å†™å…¥
   - Bulk API
   - å‡å°‘ç½‘ç»œå¼€é”€
   - æå‡ååé‡

3. å¼‚æ­¥å¤„ç†
   - å†™å…¥å…ˆè¿”å›
   - åå°å¼‚æ­¥åˆ·ç›˜

å€Ÿé‰´ç‚¹ï¼š
âœ… ä¸è¿½æ±‚ç»å¯¹å®æ—¶
âœ… æ‰¹é‡å¤„ç†æå‡æ€§èƒ½
âœ… å¼‚æ­¥åŒ–æå‡å“åº”é€Ÿåº¦
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * æ•°æ®åŒæ­¥ç³»ç»Ÿè®¾è®¡
 * å€Ÿé‰´ESçš„è¿‘å®æ—¶æ€æƒ³
 */
public class DataSyncService {
    
    private final BlockingQueue<DataChange> buffer = 
        new LinkedBlockingQueue<>(10000);
    
    private final ScheduledExecutorService scheduler = 
        Executors.newScheduledThreadPool(1);
    
    // 1. å¼‚æ­¥æ¥æ”¶æ•°æ®å˜æ›´
    public void onChange(DataChange change) {
        // å…ˆè¿”å›ï¼Œä¸é˜»å¡
        buffer.offer(change);
    }
    
    // 2. å®šæœŸæ‰¹é‡å¤„ç†ï¼ˆ1ç§’ä¸€æ¬¡ï¼‰
    public void start() {
        scheduler.scheduleAtFixedRate(() -> {
            List<DataChange> changes = new ArrayList<>();
            buffer.drainTo(changes, 1000);
            
            if (!changes.isEmpty()) {
                // æ‰¹é‡åŒæ­¥
                batchSync(changes);
            }
        }, 1, 1, TimeUnit.SECONDS);
    }
    
    // 3. æ‰¹é‡åŒæ­¥
    private void batchSync(List<DataChange> changes) {
        // æ‰¹é‡å†™å…¥ç›®æ ‡ç³»ç»Ÿ
        targetSystem.batchWrite(changes);
    }
}
```

### 1.3 Schema-Freeï¼ˆæ— æ¨¡å¼ï¼‰

```
è®¾è®¡ç†å¿µï¼š
- çµæ´»çš„æ•°æ®æ¨¡å‹
- è‡ªåŠ¨æ¨æ–­ç±»å‹
- å¿«é€Ÿè¿­ä»£

æ ¸å¿ƒå®ç°ï¼š

1. åŠ¨æ€Mapping
   - è‡ªåŠ¨æ£€æµ‹å­—æ®µç±»å‹
   - æ— éœ€é¢„å®šä¹‰schema

2. åŠ¨æ€æ¨¡æ¿
   - æ ¹æ®è§„åˆ™è‡ªåŠ¨æ˜ å°„
   - çµæ´»é…ç½®

å€Ÿé‰´ç‚¹ï¼š
âœ… æä¾›çµæ´»æ€§
âœ… é™ä½ä½¿ç”¨é—¨æ§›
âœ… ä½†è¦æ³¨æ„æ§åˆ¶ï¼ˆé¿å…Mappingçˆ†ç‚¸ï¼‰
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * é…ç½®ä¸­å¿ƒè®¾è®¡
 * å€Ÿé‰´ESçš„Schema-Freeæ€æƒ³
 */
public class ConfigCenter {
    
    // å­˜å‚¨é…ç½®ï¼ˆæ— å›ºå®šschemaï¼‰
    private final Map<String, Map<String, Object>> configs = 
        new ConcurrentHashMap<>();
    
    // 1. çµæ´»å­˜å‚¨é…ç½®
    public void setConfig(String namespace, String key, Object value) {
        configs.computeIfAbsent(namespace, k -> new ConcurrentHashMap<>())
               .put(key, value);
    }
    
    // 2. è‡ªåŠ¨ç±»å‹æ¨æ–­
    public <T> T getConfig(String namespace, String key, Class<T> type) {
        Object value = configs.getOrDefault(namespace, Collections.emptyMap())
                              .get(key);
        
        if (value == null) {
            return null;
        }
        
        // è‡ªåŠ¨ç±»å‹è½¬æ¢
        return convertType(value, type);
    }
    
    // 3. æ”¯æŒå¤æ‚ç»“æ„
    public void setNestedConfig(String namespace, String path, Object value) {
        String[] parts = path.split("\\.");
        Map<String, Object> current = configs.computeIfAbsent(
            namespace, k -> new ConcurrentHashMap<>()
        );
        
        // è‡ªåŠ¨åˆ›å»ºåµŒå¥—ç»“æ„
        for (int i = 0; i < parts.length - 1; i++) {
            current = (Map<String, Object>) current.computeIfAbsent(
                parts[i], k -> new ConcurrentHashMap<>()
            );
        }
        
        current.put(parts[parts.length - 1], value);
    }
}
```

### 1.4 RESTful APIè®¾è®¡

```
è®¾è®¡ç†å¿µï¼š
- ç®€å•æ˜“ç”¨
- è·¨è¯­è¨€
- ç¬¦åˆHTTPè¯­ä¹‰

æ ¸å¿ƒå®ç°ï¼š

1. èµ„æºå¯¼å‘
   - ç´¢å¼•ã€æ–‡æ¡£ã€é›†ç¾¤éƒ½æ˜¯èµ„æº
   - ä½¿ç”¨HTTPæ–¹æ³•æ“ä½œèµ„æº

2. ç»Ÿä¸€æ¥å£
   - GETï¼šæŸ¥è¯¢
   - POSTï¼šåˆ›å»º
   - PUTï¼šæ›´æ–°
   - DELETEï¼šåˆ é™¤

3. JSONæ ¼å¼
   - æ˜“è¯»æ˜“å†™
   - è·¨è¯­è¨€æ”¯æŒ

å€Ÿé‰´ç‚¹ï¼š
âœ… APIè®¾è®¡è¦ç®€å•ç›´è§‚
âœ… éµå¾ªRESTè§„èŒƒ
âœ… ä½¿ç”¨æ ‡å‡†åè®®
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * RESTful APIè®¾è®¡
 * å€Ÿé‰´ESçš„APIè®¾è®¡æ€æƒ³
 */
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    // 1. èµ„æºå¯¼å‘
    
    // æŸ¥è¯¢æ‰€æœ‰å•†å“
    @GetMapping
    public List<Product> listProducts() {
        return productService.findAll();
    }
    
    // æŸ¥è¯¢å•ä¸ªå•†å“
    @GetMapping("/{id}")
    public Product getProduct(@PathVariable String id) {
        return productService.findById(id);
    }
    
    // åˆ›å»ºå•†å“
    @PostMapping
    public Product createProduct(@RequestBody Product product) {
        return productService.create(product);
    }
    
    // æ›´æ–°å•†å“
    @PutMapping("/{id}")
    public Product updateProduct(
        @PathVariable String id, 
        @RequestBody Product product
    ) {
        return productService.update(id, product);
    }
    
    // åˆ é™¤å•†å“
    @DeleteMapping("/{id}")
    public void deleteProduct(@PathVariable String id) {
        productService.delete(id);
    }
    
    // 2. æ‰¹é‡æ“ä½œ
    @PostMapping("/_bulk")
    public BulkResponse bulkOperation(@RequestBody BulkRequest request) {
        return productService.bulk(request);
    }
    
    // 3. æœç´¢
    @GetMapping("/_search")
    public SearchResponse search(@RequestBody SearchRequest request) {
        return productService.search(request);
    }
}
```

---

## é—®é¢˜2ï¼šåˆ†å¸ƒå¼æ¶æ„è®¾è®¡

### 2.1 ä¸€è‡´æ€§å“ˆå¸Œï¼ˆRoutingï¼‰

```
è®¾è®¡ç›®æ ‡ï¼š
- æ•°æ®å‡åŒ€åˆ†å¸ƒ
- æœ€å°åŒ–æ•°æ®è¿ç§»
- æ”¯æŒåŠ¨æ€æ‰©å®¹

æ ¸å¿ƒå®ç°ï¼š

routing_hash = hash(routing_value) % number_of_primary_shards

ç‰¹ç‚¹ï¼š
- è·¯ç”±å€¼å¯è‡ªå®šä¹‰ï¼ˆé»˜è®¤ä¸ºæ–‡æ¡£IDï¼‰
- åˆ†ç‰‡æ•°å›ºå®šï¼ˆåˆ›å»ºæ—¶ç¡®å®šï¼‰
- ç›¸åŒè·¯ç”±å€¼çš„æ–‡æ¡£åœ¨åŒä¸€åˆ†ç‰‡
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * ä¸€è‡´æ€§å“ˆå¸Œå®ç°
 * ç”¨äºåˆ†å¸ƒå¼ç¼“å­˜ã€åˆ†åº“åˆ†è¡¨ç­‰
 */
public class ConsistentHash<T> {
    
    private final TreeMap<Integer, T> circle = new TreeMap<>();
    private final int virtualNodes;
    
    public ConsistentHash(int virtualNodes) {
        this.virtualNodes = virtualNodes;
    }
    
    // æ·»åŠ èŠ‚ç‚¹
    public void addNode(T node) {
        for (int i = 0; i < virtualNodes; i++) {
            String key = node.toString() + "#" + i;
            int hash = hash(key);
            circle.put(hash, node);
        }
    }
    
    // ç§»é™¤èŠ‚ç‚¹
    public void removeNode(T node) {
        for (int i = 0; i < virtualNodes; i++) {
            String key = node.toString() + "#" + i;
            int hash = hash(key);
            circle.remove(hash);
        }
    }
    
    // è·å–èŠ‚ç‚¹
    public T getNode(String key) {
        if (circle.isEmpty()) {
            return null;
        }
        
        int hash = hash(key);
        
        // é¡ºæ—¶é’ˆæ‰¾åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
        Map.Entry<Integer, T> entry = circle.ceilingEntry(hash);
        if (entry == null) {
            entry = circle.firstEntry();
        }
        
        return entry.getValue();
    }
    
    private int hash(String key) {
        return Math.abs(key.hashCode());
    }
}

// ä½¿ç”¨ç¤ºä¾‹
ConsistentHash<String> hash = new ConsistentHash<>(150);
hash.addNode("node1");
hash.addNode("node2");
hash.addNode("node3");

String node = hash.getNode("user123");  // è·¯ç”±åˆ°æŸä¸ªèŠ‚ç‚¹
```

### 2.2 ä¸»å‰¯åˆ†ç‰‡æœºåˆ¶

```
è®¾è®¡ç›®æ ‡ï¼š
- é«˜å¯ç”¨
- è´Ÿè½½å‡è¡¡
- æ•°æ®å†—ä½™

æ ¸å¿ƒå®ç°ï¼š

1. ä¸»åˆ†ç‰‡ï¼ˆPrimary Shardï¼‰
   - è´Ÿè´£å†™å…¥
   - æ•°æ®æƒå¨æ¥æº

2. å‰¯æœ¬åˆ†ç‰‡ï¼ˆReplica Shardï¼‰
   - ä¸»åˆ†ç‰‡çš„å‰¯æœ¬
   - è´Ÿè´£è¯»å–
   - æ•…éšœè½¬ç§»

3. åˆ†ç‰‡åˆ†é…è§„åˆ™
   - ä¸»å‰¯åˆ†ç‰‡ä¸åœ¨åŒä¸€èŠ‚ç‚¹
   - å°½é‡å‡åŒ€åˆ†å¸ƒ
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * ä¸»å‰¯åˆ†ç‰‡æœºåˆ¶å®ç°
 * ç”¨äºåˆ†å¸ƒå¼å­˜å‚¨ç³»ç»Ÿ
 */
public class ShardManager {
    
    private final Map<Integer, Shard> primaryShards = new ConcurrentHashMap<>();
    private final Map<Integer, List<Shard>> replicaShards = new ConcurrentHashMap<>();
    
    // 1. å†™å…¥æ•°æ®ï¼ˆå†™ä¸»åˆ†ç‰‡ï¼‰
    public void write(String key, String value) {
        int shardId = getShardId(key);
        Shard primaryShard = primaryShards.get(shardId);
        
        // å†™å…¥ä¸»åˆ†ç‰‡
        primaryShard.write(key, value);
        
        // åŒæ­¥åˆ°å‰¯æœ¬åˆ†ç‰‡
        List<Shard> replicas = replicaShards.get(shardId);
        for (Shard replica : replicas) {
            replica.write(key, value);
        }
    }
    
    // 2. è¯»å–æ•°æ®ï¼ˆè¯»å‰¯æœ¬åˆ†ç‰‡ï¼‰
    public String read(String key) {
        int shardId = getShardId(key);
        
        // ä¼˜å…ˆè¯»å–å‰¯æœ¬åˆ†ç‰‡ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
        List<Shard> replicas = replicaShards.get(shardId);
        if (!replicas.isEmpty()) {
            Shard replica = selectReplica(replicas);
            return replica.read(key);
        }
        
        // å‰¯æœ¬ä¸å¯ç”¨ï¼Œè¯»å–ä¸»åˆ†ç‰‡
        Shard primaryShard = primaryShards.get(shardId);
        return primaryShard.read(key);
    }
    
    // 3. æ•…éšœè½¬ç§»
    public void handleShardFailure(Shard failedShard) {
        if (failedShard.isPrimary()) {
            // ä¸»åˆ†ç‰‡å¤±è´¥ï¼Œæå‡å‰¯æœ¬ä¸ºä¸»
            int shardId = failedShard.getId();
            List<Shard> replicas = replicaShards.get(shardId);
            
            if (!replicas.isEmpty()) {
                Shard newPrimary = replicas.remove(0);
                newPrimary.promoteAsPrimary();
                primaryShards.put(shardId, newPrimary);
            }
        } else {
            // å‰¯æœ¬åˆ†ç‰‡å¤±è´¥ï¼Œä»ä¸»åˆ†ç‰‡å¤åˆ¶æ–°å‰¯æœ¬
            int shardId = failedShard.getId();
            Shard primaryShard = primaryShards.get(shardId);
            Shard newReplica = primaryShard.createReplica();
            replicaShards.get(shardId).add(newReplica);
        }
    }
    
    private int getShardId(String key) {
        return Math.abs(key.hashCode()) % primaryShards.size();
    }
    
    private Shard selectReplica(List<Shard> replicas) {
        // è½®è¯¢æˆ–éšæœºé€‰æ‹©
        return replicas.get(ThreadLocalRandom.current().nextInt(replicas.size()));
    }
}
```

### 2.3 åˆ†å¸ƒå¼åè°ƒï¼ˆMasteré€‰ä¸¾ï¼‰

```
è®¾è®¡ç›®æ ‡ï¼š
- é›†ç¾¤å…ƒæ•°æ®ç®¡ç†
- é¿å…è„‘è£‚
- å¿«é€Ÿé€‰ä¸¾

æ ¸å¿ƒå®ç°ï¼ˆES 7.x+ï¼‰ï¼š

1. Raftç®—æ³•
   - å¼ºä¸€è‡´æ€§
   - å¤šæ•°æ´¾åŸåˆ™
   - ä»»æœŸï¼ˆTermï¼‰æ¦‚å¿µ

2. é€‰ä¸¾æµç¨‹
   - èŠ‚ç‚¹å‘èµ·é€‰ä¸¾
   - è·å¾—å¤šæ•°æ´¾æŠ•ç¥¨
   - æˆä¸ºMaster

3. è„‘è£‚é¢„é˜²
   - æœ€å°ä¸»èŠ‚ç‚¹æ•°ï¼š(master_nodes / 2) + 1
   - å¤šæ•°æ´¾åŸåˆ™
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * ç®€åŒ–çš„Rafté€‰ä¸¾å®ç°
 * ç”¨äºåˆ†å¸ƒå¼ç³»ç»Ÿçš„Leaderé€‰ä¸¾
 */
public class RaftElection {
    
    private volatile NodeState state = NodeState.FOLLOWER;
    private volatile int currentTerm = 0;
    private volatile String votedFor = null;
    private volatile String currentLeader = null;
    
    private final String nodeId;
    private final List<String> clusterNodes;
    private final Random random = new Random();
    
    public RaftElection(String nodeId, List<String> clusterNodes) {
        this.nodeId = nodeId;
        this.clusterNodes = clusterNodes;
    }
    
    // 1. å¯åŠ¨é€‰ä¸¾è¶…æ—¶æ£€æµ‹
    public void start() {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        scheduler.scheduleAtFixedRate(() -> {
            if (state == NodeState.FOLLOWER && isElectionTimeout()) {
                startElection();
            }
        }, 150, 150, TimeUnit.MILLISECONDS);
    }
    
    // 2. å‘èµ·é€‰ä¸¾
    private void startElection() {
        state = NodeState.CANDIDATE;
        currentTerm++;
        votedFor = nodeId;
        
        int votes = 1;  // æŠ•ç¥¨ç»™è‡ªå·±
        
        // è¯·æ±‚å…¶ä»–èŠ‚ç‚¹æŠ•ç¥¨
        for (String node : clusterNodes) {
            if (!node.equals(nodeId)) {
                if (requestVote(node, currentTerm)) {
                    votes++;
                }
            }
        }
        
        // è·å¾—å¤šæ•°æ´¾æŠ•ç¥¨
        if (votes > clusterNodes.size() / 2) {
            becomeLeader();
        } else {
            state = NodeState.FOLLOWER;
        }
    }
    
    // 3. æˆä¸ºLeader
    private void becomeLeader() {
        state = NodeState.LEADER;
        currentLeader = nodeId;
        
        // å®šæœŸå‘é€å¿ƒè·³
        ScheduledExecutorService heartbeat = Executors.newScheduledThreadPool(1);
        heartbeat.scheduleAtFixedRate(() -> {
            if (state == NodeState.LEADER) {
                sendHeartbeat();
            }
        }, 0, 50, TimeUnit.MILLISECONDS);
    }
    
    // 4. å¤„ç†æŠ•ç¥¨è¯·æ±‚
    public boolean handleVoteRequest(String candidateId, int term) {
        if (term < currentTerm) {
            return false;  // æ‹’ç»æ—§ä»»æœŸçš„æŠ•ç¥¨
        }
        
        if (term > currentTerm) {
            currentTerm = term;
            votedFor = null;
            state = NodeState.FOLLOWER;
        }
        
        if (votedFor == null || votedFor.equals(candidateId)) {
            votedFor = candidateId;
            return true;
        }
        
        return false;
    }
    
    // 5. å¤„ç†å¿ƒè·³
    public void handleHeartbeat(String leaderId, int term) {
        if (term >= currentTerm) {
            currentTerm = term;
            currentLeader = leaderId;
            state = NodeState.FOLLOWER;
            resetElectionTimeout();
        }
    }
    
    private boolean isElectionTimeout() {
        // éšæœºè¶…æ—¶æ—¶é—´ï¼š150-300ms
        return true;  // ç®€åŒ–å®ç°
    }
    
    private void resetElectionTimeout() {
        // é‡ç½®è¶…æ—¶è®¡æ—¶å™¨
    }
    
    private boolean requestVote(String node, int term) {
        // å‘é€æŠ•ç¥¨è¯·æ±‚åˆ°å…¶ä»–èŠ‚ç‚¹
        return true;  // ç®€åŒ–å®ç°
    }
    
    private void sendHeartbeat() {
        // å‘é€å¿ƒè·³åˆ°æ‰€æœ‰èŠ‚ç‚¹
        for (String node : clusterNodes) {
            if (!node.equals(nodeId)) {
                // å‘é€å¿ƒè·³
            }
        }
    }
    
    enum NodeState {
        FOLLOWER, CANDIDATE, LEADER
    }
}
```

---

## é—®é¢˜3ï¼šå€’æ’ç´¢å¼•å®ç°

### 3.1 å€’æ’ç´¢å¼•æ•°æ®ç»“æ„

```
æ ¸å¿ƒç»„ä»¶ï¼š

1. Term Dictionaryï¼ˆè¯å…¸ï¼‰
   - å­˜å‚¨æ‰€æœ‰Term
   - ä½¿ç”¨FSTï¼ˆFinite State Transducerï¼‰
   - å‹ç¼©å­˜å‚¨ï¼ŒèŠ‚çœå†…å­˜

2. Posting Listï¼ˆå€’æ’åˆ—è¡¨ï¼‰
   - å­˜å‚¨åŒ…å«Termçš„æ–‡æ¡£IDåˆ—è¡¨
   - ä½¿ç”¨Frame of Referenceå‹ç¼©
   - ä½¿ç”¨Skip ListåŠ é€ŸæŸ¥è¯¢

3. Term Frequencyï¼ˆè¯é¢‘ï¼‰
   - è®°å½•Termåœ¨æ–‡æ¡£ä¸­å‡ºç°çš„æ¬¡æ•°
   - ç”¨äºç›¸å…³æ€§è¯„åˆ†

4. Positionï¼ˆä½ç½®ï¼‰
   - è®°å½•Termåœ¨æ–‡æ¡£ä¸­çš„ä½ç½®
   - ç”¨äºçŸ­è¯­æŸ¥è¯¢
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * ç®€åŒ–çš„å€’æ’ç´¢å¼•å®ç°
 * ç”¨äºç†è§£å€’æ’ç´¢å¼•åŸç†
 */
public class InvertedIndex {
    
    // Term Dictionary: Term -> Posting List
    private final Map<String, PostingList> index = new ConcurrentHashMap<>();
    
    // Document Store: DocId -> Document
    private final Map<Integer, Document> documents = new ConcurrentHashMap<>();
    
    private final AtomicInteger docIdGenerator = new AtomicInteger(0);
    
    // 1. ç´¢å¼•æ–‡æ¡£
    public int indexDocument(String content) {
        int docId = docIdGenerator.incrementAndGet();
        
        // å­˜å‚¨æ–‡æ¡£
        Document doc = new Document(docId, content);
        documents.put(docId, doc);
        
        // åˆ†è¯
        List<String> terms = tokenize(content);
        
        // æ„å»ºå€’æ’ç´¢å¼•
        for (int position = 0; position < terms.size(); position++) {
            String term = terms.get(position);
            
            PostingList postingList = index.computeIfAbsent(
                term, k -> new PostingList()
            );
            
            postingList.addPosting(docId, position);
        }
        
        return docId;
    }
    
    // 2. æœç´¢
    public List<Integer> search(String query) {
        List<String> terms = tokenize(query);
        
        if (terms.isEmpty()) {
            return Collections.emptyList();
        }
        
        // è·å–ç¬¬ä¸€ä¸ªTermçš„Posting List
        PostingList result = index.get(terms.get(0));
        if (result == null) {
            return Collections.emptyList();
        }
        
        // ä¸å…¶ä»–Termçš„Posting Listæ±‚äº¤é›†
        for (int i = 1; i < terms.size(); i++) {
            PostingList postingList = index.get(terms.get(i));
            if (postingList == null) {
                return Collections.emptyList();
            }
            result = result.intersect(postingList);
        }
        
        return result.getDocIds();
    }
    
    // 3. çŸ­è¯­æœç´¢
    public List<Integer> phraseSearch(String phrase) {
        List<String> terms = tokenize(phrase);
        
        if (terms.isEmpty()) {
            return Collections.emptyList();
        }
        
        // è·å–ç¬¬ä¸€ä¸ªTermçš„Posting List
        PostingList firstPostingList = index.get(terms.get(0));
        if (firstPostingList == null) {
            return Collections.emptyList();
        }
        
        List<Integer> result = new ArrayList<>();
        
        // æ£€æŸ¥æ¯ä¸ªæ–‡æ¡£
        for (Posting posting : firstPostingList.getPostings()) {
            int docId = posting.getDocId();
            List<Integer> positions = posting.getPositions();
            
            // æ£€æŸ¥åç»­Termæ˜¯å¦åœ¨ç›¸é‚»ä½ç½®
            boolean match = true;
            for (int i = 1; i < terms.size(); i++) {
                PostingList nextPostingList = index.get(terms.get(i));
                if (nextPostingList == null) {
                    match = false;
                    break;
                }
                
                Posting nextPosting = nextPostingList.getPosting(docId);
                if (nextPosting == null) {
                    match = false;
                    break;
                }
                
                // æ£€æŸ¥ä½ç½®æ˜¯å¦è¿ç»­
                boolean foundAdjacent = false;
                for (int pos : positions) {
                    if (nextPosting.getPositions().contains(pos + i)) {
                        foundAdjacent = true;
                        break;
                    }
                }
                
                if (!foundAdjacent) {
                    match = false;
                    break;
                }
            }
            
            if (match) {
                result.add(docId);
            }
        }
        
        return result;
    }
    
    // ç®€å•åˆ†è¯ï¼ˆå®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨ä¸“ä¸šåˆ†è¯å™¨ï¼‰
    private List<String> tokenize(String text) {
        return Arrays.asList(text.toLowerCase().split("\\s+"));
    }
    
    // Posting List
    static class PostingList {
        private final List<Posting> postings = new ArrayList<>();
        
        public void addPosting(int docId, int position) {
            Posting posting = getPosting(docId);
            if (posting == null) {
                posting = new Posting(docId);
                postings.add(posting);
            }
            posting.addPosition(position);
        }
        
        public Posting getPosting(int docId) {
            for (Posting posting : postings) {
                if (posting.getDocId() == docId) {
                    return posting;
                }
            }
            return null;
        }
        
        public List<Posting> getPostings() {
            return postings;
        }
        
        public List<Integer> getDocIds() {
            return postings.stream()
                .map(Posting::getDocId)
                .collect(Collectors.toList());
        }
        
        // æ±‚äº¤é›†
        public PostingList intersect(PostingList other) {
            PostingList result = new PostingList();
            
            int i = 0, j = 0;
            while (i < this.postings.size() && j < other.postings.size()) {
                int docId1 = this.postings.get(i).getDocId();
                int docId2 = other.postings.get(j).getDocId();
                
                if (docId1 == docId2) {
                    result.postings.add(this.postings.get(i));
                    i++;
                    j++;
                } else if (docId1 < docId2) {
                    i++;
                } else {
                    j++;
                }
            }
            
            return result;
        }
    }
    
    // Posting
    static class Posting {
        private final int docId;
        private final List<Integer> positions = new ArrayList<>();
        
        public Posting(int docId) {
            this.docId = docId;
        }
        
        public void addPosition(int position) {
            positions.add(position);
        }
        
        public int getDocId() {
            return docId;
        }
        
        public List<Integer> getPositions() {
            return positions;
        }
        
        public int getTermFrequency() {
            return positions.size();
        }
    }
    
    // Document
    static class Document {
        private final int id;
        private final String content;
        
        public Document(int id, String content) {
            this.id = id;
            this.content = content;
        }
        
        public int getId() {
            return id;
        }
        
        public String getContent() {
            return content;
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
InvertedIndex index = new InvertedIndex();

// ç´¢å¼•æ–‡æ¡£
index.indexDocument("Elasticsearch is a search engine");
index.indexDocument("Elasticsearch is distributed");
index.indexDocument("Search engine is powerful");

// æœç´¢
List<Integer> results = index.search("elasticsearch search");
// è¿”å›ï¼š[1, 3]

// çŸ­è¯­æœç´¢
List<Integer> phraseResults = index.phraseSearch("search engine");
// è¿”å›ï¼š[1, 3]
```

### 3.2 FSTï¼ˆFinite State Transducerï¼‰

```
è®¾è®¡ç›®æ ‡ï¼š
- å‹ç¼©Term Dictionary
- å¿«é€ŸæŸ¥æ‰¾
- èŠ‚çœå†…å­˜

ç‰¹ç‚¹ï¼š
- å‰ç¼€å…±äº«
- æœ‰åºå­˜å‚¨
- æ”¯æŒèŒƒå›´æŸ¥è¯¢
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * ç®€åŒ–çš„FSTå®ç°
 * ç”¨äºç†è§£FSTåŸç†
 */
public class SimpleFST {
    
    private final Node root = new Node();
    
    // 1. æ„å»ºFST
    public void build(List<String> terms) {
        // å¿…é¡»å…ˆæ’åº
        Collections.sort(terms);
        
        for (String term : terms) {
            insert(term);
        }
    }
    
    // 2. æ’å…¥Term
    private void insert(String term) {
        Node current = root;
        
        for (char c : term.toCharArray()) {
            current = current.children.computeIfAbsent(c, k -> new Node());
        }
        
        current.isTerminal = true;
    }
    
    // 3. æŸ¥æ‰¾Term
    public boolean contains(String term) {
        Node current = root;
        
        for (char c : term.toCharArray()) {
            current = current.children.get(c);
            if (current == null) {
                return false;
            }
        }
        
        return current.isTerminal;
    }
    
    // 4. å‰ç¼€æŸ¥è¯¢
    public List<String> findByPrefix(String prefix) {
        Node current = root;
        
        // æ‰¾åˆ°å‰ç¼€èŠ‚ç‚¹
        for (char c : prefix.toCharArray()) {
            current = current.children.get(c);
            if (current == null) {
                return Collections.emptyList();
            }
        }
        
        // æ”¶é›†æ‰€æœ‰ä»¥è¯¥å‰ç¼€å¼€å¤´çš„Term
        List<String> results = new ArrayList<>();
        collectTerms(current, prefix, results);
        return results;
    }
    
    private void collectTerms(Node node, String prefix, List<String> results) {
        if (node.isTerminal) {
            results.add(prefix);
        }
        
        for (Map.Entry<Character, Node> entry : node.children.entrySet()) {
            collectTerms(entry.getValue(), prefix + entry.getKey(), results);
        }
    }
    
    static class Node {
        Map<Character, Node> children = new HashMap<>();
        boolean isTerminal = false;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
SimpleFST fst = new SimpleFST();
fst.build(Arrays.asList("apple", "application", "apply", "banana", "band"));

// æŸ¥æ‰¾
boolean exists = fst.contains("apple");  // true

// å‰ç¼€æŸ¥è¯¢
List<String> results = fst.findByPrefix("app");
// è¿”å›ï¼š["apple", "application", "apply"]
```

---

## é—®é¢˜4ï¼šä¼˜ç§€çš„è®¾è®¡æ¨¡å¼

### 4.1 Builderæ¨¡å¼

```
åº”ç”¨åœºæ™¯ï¼š
- æŸ¥è¯¢æ„å»º
- ç´¢å¼•åˆ›å»º
- å®¢æˆ·ç«¯é…ç½®

ä¼˜ç‚¹ï¼š
- é“¾å¼è°ƒç”¨
- å¯è¯»æ€§å¥½
- çµæ´»æ€§é«˜
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * Builderæ¨¡å¼å®ç°
 * ç”¨äºæ„å»ºå¤æ‚å¯¹è±¡
 */
public class SearchRequest {
    
    private String index;
    private String query;
    private int from;
    private int size;
    private List<String> fields;
    private Map<String, String> filters;
    
    private SearchRequest() {}
    
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private final SearchRequest request = new SearchRequest();
        
        public Builder index(String index) {
            request.index = index;
            return this;
        }
        
        public Builder query(String query) {
            request.query = query;
            return this;
        }
        
        public Builder from(int from) {
            request.from = from;
            return this;
        }
        
        public Builder size(int size) {
            request.size = size;
            return this;
        }
        
        public Builder fields(String... fields) {
            request.fields = Arrays.asList(fields);
            return this;
        }
        
        public Builder filter(String field, String value) {
            if (request.filters == null) {
                request.filters = new HashMap<>();
            }
            request.filters.put(field, value);
            return this;
        }
        
        public SearchRequest build() {
            // éªŒè¯å¿…å¡«å­—æ®µ
            if (request.index == null) {
                throw new IllegalStateException("Index is required");
            }
            return request;
        }
    }
    
    // Getters
    public String getIndex() { return index; }
    public String getQuery() { return query; }
    public int getFrom() { return from; }
    public int getSize() { return size; }
    public List<String> getFields() { return fields; }
    public Map<String, String> getFilters() { return filters; }
}

// ä½¿ç”¨ç¤ºä¾‹
SearchRequest request = SearchRequest.builder()
    .index("products")
    .query("æ‰‹æœº")
    .from(0)
    .size(10)
    .fields("name", "price", "brand")
    .filter("category", "ç”µå­äº§å“")
    .filter("price_range", "1000-5000")
    .build();
```

### 4.2 ç­–ç•¥æ¨¡å¼

```
åº”ç”¨åœºæ™¯ï¼š
- è¯„åˆ†ç®—æ³•ï¼ˆTF-IDFã€BM25ï¼‰
- åˆ†ç‰‡åˆ†é…ç­–ç•¥
- å‹ç¼©ç®—æ³•

ä¼˜ç‚¹ï¼š
- ç®—æ³•å¯æ›¿æ¢
- æ˜“äºæ‰©å±•
- ç¬¦åˆå¼€é—­åŸåˆ™
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * ç­–ç•¥æ¨¡å¼å®ç°
 * ç”¨äºå¯æ›¿æ¢çš„ç®—æ³•
 */
// è¯„åˆ†ç­–ç•¥æ¥å£
public interface ScoringStrategy {
    double score(Document doc, String query);
}

// TF-IDFè¯„åˆ†
public class TFIDFScoring implements ScoringStrategy {
    @Override
    public double score(Document doc, String query) {
        // TF-IDFè®¡ç®—
        double tf = doc.getTermFrequency(query);
        double idf = Math.log(totalDocs / docsContainingTerm(query));
        return tf * idf;
    }
}

// BM25è¯„åˆ†
public class BM25Scoring implements ScoringStrategy {
    private final double k1 = 1.2;
    private final double b = 0.75;
    
    @Override
    public double score(Document doc, String query) {
        // BM25è®¡ç®—
        double tf = doc.getTermFrequency(query);
        double idf = Math.log((totalDocs - docsContainingTerm(query) + 0.5) / 
                              (docsContainingTerm(query) + 0.5));
        double docLength = doc.getLength();
        double avgDocLength = getAvgDocLength();
        
        return idf * (tf * (k1 + 1)) / 
               (tf + k1 * (1 - b + b * (docLength / avgDocLength)));
    }
}

// æœç´¢å¼•æ“
public class SearchEngine {
    private ScoringStrategy scoringStrategy;
    
    public SearchEngine(ScoringStrategy scoringStrategy) {
        this.scoringStrategy = scoringStrategy;
    }
    
    public void setScoringStrategy(ScoringStrategy scoringStrategy) {
        this.scoringStrategy = scoringStrategy;
    }
    
    public List<Document> search(String query) {
        List<Document> docs = findDocuments(query);
        
        // ä½¿ç”¨ç­–ç•¥è®¡ç®—è¯„åˆ†
        docs.forEach(doc -> {
            double score = scoringStrategy.score(doc, query);
            doc.setScore(score);
        });
        
        // æŒ‰è¯„åˆ†æ’åº
        docs.sort((d1, d2) -> Double.compare(d2.getScore(), d1.getScore()));
        
        return docs;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
SearchEngine engine = new SearchEngine(new BM25Scoring());
List<Document> results = engine.search("elasticsearch");

// åˆ‡æ¢è¯„åˆ†ç®—æ³•
engine.setScoringStrategy(new TFIDFScoring());
results = engine.search("elasticsearch");
```

### 4.3 è§‚å¯Ÿè€…æ¨¡å¼

```
åº”ç”¨åœºæ™¯ï¼š
- é›†ç¾¤çŠ¶æ€å˜æ›´
- ç´¢å¼•äº‹ä»¶ç›‘å¬
- èŠ‚ç‚¹çŠ¶æ€ç›‘æ§

ä¼˜ç‚¹ï¼š
- è§£è€¦
- æ˜“äºæ‰©å±•
- æ”¯æŒå¤šä¸ªè§‚å¯Ÿè€…
```

**å®æˆ˜åº”ç”¨**ï¼š
```java
/**
 * è§‚å¯Ÿè€…æ¨¡å¼å®ç°
 * ç”¨äºäº‹ä»¶é€šçŸ¥
 */
// é›†ç¾¤äº‹ä»¶
public interface ClusterEvent {
    String getType();
    Object getData();
}

// é›†ç¾¤ç›‘å¬å™¨
public interface ClusterListener {
    void onEvent(ClusterEvent event);
}

// é›†ç¾¤çŠ¶æ€ç®¡ç†å™¨
public class ClusterStateManager {
    private final List<ClusterListener> listeners = new CopyOnWriteArrayList<>();
    
    // æ³¨å†Œç›‘å¬å™¨
    public void addListener(ClusterListener listener) {
        listeners.add(listener);
    }
    
    // ç§»é™¤ç›‘å¬å™¨
    public void removeListener(ClusterListener listener) {
        listeners.remove(listener);
    }
    
    // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
    private void notifyListeners(ClusterEvent event) {
        for (ClusterListener listener : listeners) {
            try {
                listener.onEvent(event);
            } catch (Exception e) {
                // è®°å½•æ—¥å¿—ï¼Œä¸å½±å“å…¶ä»–ç›‘å¬å™¨
                e.printStackTrace();
            }
        }
    }
    
    // èŠ‚ç‚¹åŠ å…¥
    public void nodeJoined(String nodeId) {
        ClusterEvent event = new NodeJoinedEvent(nodeId);
        notifyListeners(event);
    }
    
    // èŠ‚ç‚¹ç¦»å¼€
    public void nodeLeft(String nodeId) {
        ClusterEvent event = new NodeLeftEvent(nodeId);
        notifyListeners(event);
    }
    
    // ä¸»èŠ‚ç‚¹å˜æ›´
    public void masterChanged(String newMaster) {
        ClusterEvent event = new MasterChangedEvent(newMaster);
        notifyListeners(event);
    }
}

// å…·ä½“ç›‘å¬å™¨å®ç°
public class LoggingListener implements ClusterListener {
    @Override
    public void onEvent(ClusterEvent event) {
        System.out.println("Event: " + event.getType() + ", Data: " + event.getData());
    }
}

public class AlertingListener implements ClusterListener {
    @Override
    public void onEvent(ClusterEvent event) {
        if (event.getType().equals("NODE_LEFT")) {
            // å‘é€å‘Šè­¦
            sendAlert("Node left: " + event.getData());
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
ClusterStateManager manager = new ClusterStateManager();
manager.addListener(new LoggingListener());
manager.addListener(new AlertingListener());

manager.nodeJoined("node-1");
manager.nodeLeft("node-2");
manager.masterChanged("node-3");
```

---

## é—®é¢˜5ï¼šå®æˆ˜åº”ç”¨å»ºè®®

### 5.1 æ„å»ºæœç´¢ç³»ç»Ÿ

```java
/**
 * å®Œæ•´çš„æœç´¢ç³»ç»Ÿæ¶æ„
 * ç»¼åˆåº”ç”¨ESçš„è®¾è®¡æ€æƒ³
 */
@Service
public class ProductSearchService {
    
    @Autowired
    private ElasticsearchRestTemplate elasticsearchTemplate;
    
    @Autowired
    private ProductRepository productRepository;
    
    // 1. ç´¢å¼•æ–‡æ¡£ï¼ˆæ‰¹é‡ï¼‰
    public void indexProducts(List<Product> products) {
        List<IndexQuery> queries = products.stream()
            .map(product -> new IndexQueryBuilder()
                .withId(product.getId())
                .withObject(product)
                .build())
            .collect(Collectors.toList());
        
        elasticsearchTemplate.bulkIndex(queries, Product.class);
        elasticsearchTemplate.indexOps(Product.class).refresh();
    }
    
    // 2. æœç´¢ï¼ˆä½¿ç”¨Builderæ¨¡å¼ï¼‰
    public SearchResult search(SearchParams params) {
        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()
            .withQuery(buildQuery(params))
            .withFilter(buildFilter(params))
            .withPageable(PageRequest.of(params.getPage(), params.getSize()))
            .withSort(buildSort(params))
            .withHighlightFields(buildHighlight())
            .build();
        
        SearchHits<Product> hits = elasticsearchTemplate.search(
            searchQuery, 
            Product.class
        );
        
        return convertToSearchResult(hits);
    }
    
    // 3. èšåˆåˆ†æ
    public Map<String, Long> aggregateByCategory() {
        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()
            .withQuery(QueryBuilders.matchAllQuery())
            .addAggregation(
                AggregationBuilders.terms("category_agg")
                    .field("category")
                    .size(100)
            )
            .build();
        
        SearchHits<Product> hits = elasticsearchTemplate.search(
            searchQuery, 
            Product.class
        );
        
        Aggregations aggregations = hits.getAggregations();
        Terms categoryAgg = aggregations.get("category_agg");
        
        return categoryAgg.getBuckets().stream()
            .collect(Collectors.toMap(
                Terms.Bucket::getKeyAsString,
                Terms.Bucket::getDocCount
            ));
    }
    
    // 4. æ•°æ®åŒæ­¥ï¼ˆMySQL -> ESï¼‰
    @Scheduled(fixedDelay = 60000)  // æ¯åˆ†é’ŸåŒæ­¥ä¸€æ¬¡
    public void syncData() {
        // è·å–æœ€è¿‘æ›´æ–°çš„æ•°æ®
        List<Product> products = productRepository.findRecentlyUpdated();
        
        if (!products.isEmpty()) {
            indexProducts(products);
        }
    }
    
    // 5. æ„å»ºæŸ¥è¯¢
    private QueryBuilder buildQuery(SearchParams params) {
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // å…³é”®è¯æœç´¢
        if (params.getKeyword() != null) {
            boolQuery.must(
                QueryBuilders.multiMatchQuery(params.getKeyword())
                    .field("name", 2.0f)  // boost
                    .field("description")
            );
        }
        
        return boolQuery;
    }
    
    // 6. æ„å»ºè¿‡æ»¤å™¨
    private QueryBuilder buildFilter(SearchParams params) {
        BoolQueryBuilder filterQuery = QueryBuilders.boolQuery();
        
        // åˆ†ç±»è¿‡æ»¤
        if (params.getCategory() != null) {
            filterQuery.filter(
                QueryBuilders.termQuery("category", params.getCategory())
            );
        }
        
        // ä»·æ ¼åŒºé—´è¿‡æ»¤
        if (params.getMinPrice() != null || params.getMaxPrice() != null) {
            RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery("price");
            if (params.getMinPrice() != null) {
                rangeQuery.gte(params.getMinPrice());
            }
            if (params.getMaxPrice() != null) {
                rangeQuery.lte(params.getMaxPrice());
            }
            filterQuery.filter(rangeQuery);
        }
        
        return filterQuery;
    }
    
    // 7. æ„å»ºæ’åº
    private Sort buildSort(SearchParams params) {
        if ("price_asc".equals(params.getSort())) {
            return Sort.by(Sort.Direction.ASC, "price");
        } else if ("price_desc".equals(params.getSort())) {
            return Sort.by(Sort.Direction.DESC, "price");
        } else {
            return Sort.by(Sort.Direction.DESC, "_score");
        }
    }
    
    // 8. æ„å»ºé«˜äº®
    private HighlightBuilder.Field[] buildHighlight() {
        return new HighlightBuilder.Field[]{
            new HighlightBuilder.Field("name"),
            new HighlightBuilder.Field("description")
        };
    }
    
    // 9. è½¬æ¢æœç´¢ç»“æœ
    private SearchResult convertToSearchResult(SearchHits<Product> hits) {
        List<ProductDTO> products = hits.stream()
            .map(hit -> {
                Product product = hit.getContent();
                ProductDTO dto = new ProductDTO(product);
                dto.setScore(hit.getScore());
                
                // è®¾ç½®é«˜äº®
                Map<String, List<String>> highlights = hit.getHighlightFields();
                if (highlights.containsKey("name")) {
                    dto.setHighlightedName(highlights.get("name").get(0));
                }
                
                return dto;
            })
            .collect(Collectors.toList());
        
        return new SearchResult(
            products,
            hits.getTotalHits(),
            hits.getMaxScore()
        );
    }
}
```

### 5.2 æ€§èƒ½ä¼˜åŒ–å®è·µ

```java
/**
 * æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ
 */
@Configuration
public class ElasticsearchOptimization {
    
    // 1. è¿æ¥æ± ä¼˜åŒ–
    @Bean
    public RestHighLevelClient elasticsearchClient() {
        RestClientBuilder builder = RestClient.builder(
            new HttpHost("localhost", 9200)
        );
        
        // è¿æ¥æ± é…ç½®
        builder.setHttpClientConfigCallback(httpClientBuilder -> 
            httpClientBuilder
                .setMaxConnTotal(100)
                .setMaxConnPerRoute(50)
                .setKeepAliveStrategy((response, context) -> 60000)
        );
        
        // è¶…æ—¶é…ç½®
        builder.setRequestConfigCallback(requestConfigBuilder -> 
            requestConfigBuilder
                .setConnectTimeout(5000)
                .setSocketTimeout(60000)
        );
        
        return new RestHighLevelClient(builder);
    }
    
    // 2. æ‰¹é‡å†™å…¥ä¼˜åŒ–
    public void bulkIndexOptimized(List<Product> products) {
        int batchSize = 1000;
        
        for (int i = 0; i < products.size(); i += batchSize) {
            int end = Math.min(i + batchSize, products.size());
            List<Product> batch = products.subList(i, end);
            
            BulkRequest bulkRequest = new BulkRequest();
            for (Product product : batch) {
                bulkRequest.add(new IndexRequest("products")
                    .id(product.getId())
                    .source(convertToMap(product)));
            }
            
            try {
                client.bulk(bulkRequest, RequestOptions.DEFAULT);
            } catch (IOException e) {
                // è®°å½•å¤±è´¥çš„æ‰¹æ¬¡ï¼Œç¨åé‡è¯•
                logFailedBatch(batch);
            }
        }
    }
    
    // 3. æŸ¥è¯¢ä¼˜åŒ–
    public List<Product> searchOptimized(String keyword) {
        SearchRequest searchRequest = new SearchRequest("products");
        
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        
        // ä½¿ç”¨filterä»£æ›¿queryï¼ˆå¯ç¼“å­˜ï¼‰
        sourceBuilder.query(
            QueryBuilders.boolQuery()
                .must(QueryBuilders.matchQuery("name", keyword))
                .filter(QueryBuilders.termQuery("status", "active"))
        );
        
        // åªè¿”å›éœ€è¦çš„å­—æ®µ
        sourceBuilder.fetchSource(
            new String[]{"id", "name", "price"}, 
            null
        );
        
        // ä½¿ç”¨search_afterä»£æ›¿æ·±åº¦åˆ†é¡µ
        sourceBuilder.size(10);
        sourceBuilder.sort("_id", SortOrder.ASC);
        
        searchRequest.source(sourceBuilder);
        
        try {
            SearchResponse response = client.search(
                searchRequest, 
                RequestOptions.DEFAULT
            );
            return convertToProducts(response);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

---

## æœ¬ç« æ€»ç»“

### æ ¸å¿ƒè®¾è®¡æ€æƒ³

```
1. åˆ†å¸ƒå¼ä¼˜å…ˆ
   - å¤©ç”Ÿåˆ†å¸ƒå¼
   - è‡ªåŠ¨åŒ–
   - æ— å•ç‚¹æ•…éšœ

2. è¿‘å®æ—¶
   - å¹³è¡¡å®æ—¶æ€§å’Œæ€§èƒ½
   - æ‰¹é‡å¤„ç†
   - å¼‚æ­¥åŒ–

3. Schema-Free
   - çµæ´»æ€§
   - å¿«é€Ÿè¿­ä»£
   - ä½†è¦æ§åˆ¶

4. RESTful API
   - ç®€å•æ˜“ç”¨
   - è·¨è¯­è¨€
   - æ ‡å‡†åè®®
```

### å¯å€Ÿé‰´çš„è®¾è®¡

```
1. ä¸€è‡´æ€§å“ˆå¸Œ
   - æ•°æ®åˆ†ç‰‡
   - è´Ÿè½½å‡è¡¡
   - åŠ¨æ€æ‰©å®¹

2. ä¸»å‰¯åˆ†ç‰‡
   - é«˜å¯ç”¨
   - è¯»å†™åˆ†ç¦»
   - æ•…éšœè½¬ç§»

3. å€’æ’ç´¢å¼•
   - å…¨æ–‡æœç´¢
   - é«˜æ€§èƒ½
   - å‹ç¼©å­˜å‚¨

4. è®¾è®¡æ¨¡å¼
   - Builderæ¨¡å¼
   - ç­–ç•¥æ¨¡å¼
   - è§‚å¯Ÿè€…æ¨¡å¼
```

### å®æˆ˜å»ºè®®

```
1. æ¶æ„è®¾è®¡
   - æ··åˆæ¶æ„ï¼ˆES + MySQLï¼‰
   - æ•°æ®åŒæ­¥
   - è¯»å†™åˆ†ç¦»

2. æ€§èƒ½ä¼˜åŒ–
   - æ‰¹é‡æ“ä½œ
   - è¿æ¥æ± 
   - æŸ¥è¯¢ä¼˜åŒ–

3. è¿ç»´å®è·µ
   - ç›‘æ§å‘Šè­¦
   - å¤‡ä»½æ¢å¤
   - å®¹é‡è§„åˆ’

4. æŒç»­å­¦ä¹ 
   - å…³æ³¨æ–°ç‰ˆæœ¬
   - é˜…è¯»æºç 
   - å®è·µæ€»ç»“
```

---

## å…¨ç³»åˆ—æ€»ç»“

æ­å–œä½ å®Œæˆäº†Elasticsearchå­¦ä¹ ä¹‹æ—…ï¼

**ä½ å·²ç»æŒæ¡**ï¼š
- âœ… ESçš„æ ¸å¿ƒæ¦‚å¿µå’Œæ¶æ„
- âœ… å€’æ’ç´¢å¼•åŸç†
- âœ… åˆ†è¯å™¨å’Œæ–‡æœ¬åˆ†æ
- âœ… æœç´¢å’ŒæŸ¥è¯¢åŸç†
- âœ… åˆ†å¸ƒå¼æ¶æ„è®¾è®¡
- âœ… é›†ç¾¤ç®¡ç†å’Œé«˜å¯ç”¨
- âœ… å®‰è£…é…ç½®å’Œä½¿ç”¨
- âœ… ç´¢å¼•è®¾è®¡å’ŒMapping
- âœ… æŸ¥è¯¢DSLå®æˆ˜
- âœ… Javaå®¢æˆ·ç«¯ä½¿ç”¨
- âœ… æ€§èƒ½ä¼˜åŒ–å’Œè¸©å‘
- âœ… ä¼˜ç¼ºç‚¹åˆ†æ
- âœ… æ–¹æ¡ˆå¯¹æ¯”å’Œé€‰å‹
- âœ… ç‰ˆæœ¬æ¼”è¿›
- âœ… æºç è®¾è®¡ç²¾å

**ä¸‹ä¸€æ­¥å»ºè®®**ï¼š
1. æ­å»ºå®éªŒç¯å¢ƒï¼ŒåŠ¨æ‰‹å®è·µ
2. åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨
3. é˜…è¯»å®˜æ–¹æ–‡æ¡£å’Œæºç 
4. å…³æ³¨ç¤¾åŒºåŠ¨æ€
5. æŒç»­ä¼˜åŒ–å’Œæ€»ç»“

**å­¦ä¹ èµ„æº**ï¼š
- å®˜æ–¹æ–‡æ¡£ï¼šhttps://www.elastic.co/guide/
- GitHubï¼šhttps://github.com/elastic/elasticsearch
- ç¤¾åŒºè®ºå›ï¼šhttps://discuss.elastic.co/
- ä¸­æ–‡ç¤¾åŒºï¼šhttps://elasticsearch.cn/

ç¥ä½ åœ¨Elasticsearchçš„é“è·¯ä¸Šè¶Šèµ°è¶Šè¿œï¼ğŸš€
