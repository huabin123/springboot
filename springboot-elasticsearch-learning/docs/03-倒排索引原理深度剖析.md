# 03-倒排索引原理深度剖析

## 引言

倒排索引是Elasticsearch实现快速搜索的核心技术。理解倒排索引，就理解了ES为什么这么快。

本文将深入剖析：**什么是倒排索引？它是如何工作的？为什么要这样设计？**

---

## 问题1：什么是倒排索引？为什么不用正排索引？

### 1.1 正排索引 vs 倒排索引

#### 正排索引（Forward Index）

正排索引是传统数据库使用的索引方式，从文档ID到文档内容的映射。

```
正排索引示例：

文档ID → 文档内容
─────────────────────────────────────
Doc1 → "苹果手机很好用"
Doc2 → "华为手机也不错"
Doc3 → "小米手机性价比高"
Doc4 → "苹果电脑很强大"

查询："手机"

查询流程：
1. 扫描Doc1："苹果手机很好用" → 包含"手机" ✓
2. 扫描Doc2："华为手机也不错" → 包含"手机" ✓
3. 扫描Doc3："小米手机性价比高" → 包含"手机" ✓
4. 扫描Doc4："苹果电脑很强大" → 不包含"手机" ✗

结果：Doc1, Doc2, Doc3
时间复杂度：O(n) - 需要扫描所有文档
```

#### 倒排索引（Inverted Index）

倒排索引是从词到文档的映射，提前建立好词典。

```
倒排索引示例：

词 → 文档列表
─────────────────────────────────────
苹果 → [Doc1, Doc4]
手机 → [Doc1, Doc2, Doc3]
华为 → [Doc2]
小米 → [Doc3]
电脑 → [Doc4]
好用 → [Doc1]
不错 → [Doc2]
性价比 → [Doc3]
强大 → [Doc4]

查询："手机"

查询流程：
1. 在词典中查找"手机"
2. 直接返回：[Doc1, Doc2, Doc3]

结果：Doc1, Doc2, Doc3
时间复杂度：O(1) - 直接查找
```

### 1.2 性能对比

```
场景：1000万个文档，查询"手机"

正排索引：
- 需要扫描：1000万个文档
- 时间：约10秒（假设每秒扫描100万）
- 结果：不可用

倒排索引：
- 需要查找：1次词典查找
- 时间：约10毫秒
- 结果：优秀

性能差距：1000倍
```

### 1.3 为什么不用正排索引？

```
原因1：性能问题
- 全表扫描，时间复杂度O(n)
- 数据量大时不可用

原因2：无法支持复杂查询
- 无法快速实现多词查询
- 无法计算相关性评分

原因3：无法优化
- 即使加索引，也只能优化精确匹配
- 无法优化全文搜索

结论：
正排索引适合：精确查询（如ID查询）
倒排索引适合：全文搜索
```

---

## 问题2：倒排索引的数据结构是什么样的？

### 2.1 倒排索引的组成部分

倒排索引由两部分组成：

```
倒排索引 = 词典（Term Dictionary） + 倒排列表（Posting List）

┌─────────────────────────────────────────────────────┐
│                    倒排索引                          │
├─────────────────────────────────────────────────────┤
│                                                      │
│  ┌────────────────┐         ┌──────────────────┐   │
│  │  词典           │         │  倒排列表         │   │
│  │ (Term Dict)    │         │ (Posting List)   │   │
│  ├────────────────┤         ├──────────────────┤   │
│  │ 苹果 ──────────┼────────→│ [Doc1, Doc4]     │   │
│  │ 手机 ──────────┼────────→│ [Doc1, Doc2, Doc3]│  │
│  │ 华为 ──────────┼────────→│ [Doc2]           │   │
│  │ 小米 ──────────┼────────→│ [Doc3]           │   │
│  │ 电脑 ──────────┼────────→│ [Doc4]           │   │
│  └────────────────┘         └──────────────────┘   │
│                                                      │
└─────────────────────────────────────────────────────┘
```

### 2.2 词典（Term Dictionary）

#### 词典的作用

```
词典的作用：
1. 存储所有的词（Term）
2. 快速查找词是否存在
3. 指向对应的倒排列表

数据结构：
- 有序的词列表
- 支持快速查找（二分查找）
- 支持前缀查询
```

#### 词典的优化：FST（Finite State Transducer）

```
传统方式：HashMap
问题：内存占用大

ES的优化：FST（有限状态转换器）
优势：
1. 内存占用小（共享前缀）
2. 查找速度快（O(len(key))）
3. 支持前缀查询

FST示例：

词典：["cat", "cats", "dog", "dogs"]

传统HashMap：
cat  → Posting List 1
cats → Posting List 2
dog  → Posting List 3
dogs → Posting List 4

FST（共享前缀）：
    c
    ├─ a
    │  └─ t → Posting List 1
    │     └─ s → Posting List 2
    d
    └─ o
       └─ g → Posting List 3
          └─ s → Posting List 4

内存节省：约50%
```

### 2.3 倒排列表（Posting List）

#### 倒排列表的基本结构

```
倒排列表包含：
1. 文档ID列表
2. 词频（Term Frequency）
3. 位置信息（Position）
4. 偏移量（Offset）

完整的倒排列表示例：

词："手机"

倒排列表：
┌──────────┬────────┬──────────┬────────────┐
│ 文档ID   │ 词频   │ 位置     │ 偏移量     │
├──────────┼────────┼──────────┼────────────┤
│ Doc1     │ 1      │ [1]      │ [2-4]      │
│ Doc2     │ 1      │ [1]      │ [2-4]      │
│ Doc3     │ 1      │ [1]      │ [2-4]      │
└──────────┴────────┴──────────┴────────────┘

说明：
- 文档ID：包含该词的文档
- 词频：该词在文档中出现的次数
- 位置：该词在文档中的位置（用于短语查询）
- 偏移量：该词在文档中的字符偏移（用于高亮）
```

#### 词频（Term Frequency）

```
词频的作用：
- 计算相关性评分
- 词频越高，相关性越高

示例：

Doc1: "手机手机手机很好用"（词频=3）
Doc2: "手机很好用"（词频=1）

查询："手机"
结果：Doc1的评分 > Doc2的评分
```

#### 位置信息（Position）

```
位置信息的作用：
- 支持短语查询（Phrase Query）
- 支持邻近查询（Proximity Query）

示例：

Doc1: "苹果手机很好用"
分词：["苹果", "手机", "很", "好用"]
位置：[0, 1, 2, 3]

倒排列表：
苹果 → [Doc1: position=0]
手机 → [Doc1: position=1]
很   → [Doc1: position=2]
好用 → [Doc1: position=3]

短语查询："苹果手机"
步骤：
1. 查找"苹果"：[Doc1: position=0]
2. 查找"手机"：[Doc1: position=1]
3. 检查位置是否连续：0和1连续 ✓
结果：匹配
```

#### 偏移量（Offset）

```
偏移量的作用：
- 支持高亮显示
- 标记词在原文中的位置

示例：

原文："苹果手机很好用"
分词：["苹果", "手机", "很", "好用"]

倒排列表：
苹果 → [Doc1: offset=0-2]   （字符0到2）
手机 → [Doc1: offset=2-4]   （字符2到4）
很   → [Doc1: offset=4-5]   （字符4到5）
好用 → [Doc1: offset=5-7]   （字符5到7）

高亮查询："手机"
步骤：
1. 查找"手机"的offset：2-4
2. 在原文中标记：苹果<em>手机</em>很好用
```

### 2.4 倒排索引的完整示例

```
文档集合：
Doc1: "苹果手机很好用"
Doc2: "华为手机也不错"
Doc3: "小米手机性价比高"

分词后的倒排索引：

┌──────┬─────────────────────────────────────────┐
│ 词   │ 倒排列表                                 │
├──────┼─────────────────────────────────────────┤
│ 苹果 │ Doc1: TF=1, Pos=[0], Offset=[0-2]       │
├──────┼─────────────────────────────────────────┤
│ 手机 │ Doc1: TF=1, Pos=[1], Offset=[2-4]       │
│      │ Doc2: TF=1, Pos=[1], Offset=[2-4]       │
│      │ Doc3: TF=1, Pos=[1], Offset=[2-4]       │
├──────┼─────────────────────────────────────────┤
│ 很   │ Doc1: TF=1, Pos=[2], Offset=[4-5]       │
├──────┼─────────────────────────────────────────┤
│ 好用 │ Doc1: TF=1, Pos=[3], Offset=[5-7]       │
├──────┼─────────────────────────────────────────┤
│ 华为 │ Doc2: TF=1, Pos=[0], Offset=[0-2]       │
├──────┼─────────────────────────────────────────┤
│ 也   │ Doc2: TF=1, Pos=[2], Offset=[4-5]       │
├──────┼─────────────────────────────────────────┤
│ 不错 │ Doc2: TF=1, Pos=[3], Offset=[5-7]       │
├──────┼─────────────────────────────────────────┤
│ 小米 │ Doc3: TF=1, Pos=[0], Offset=[0-2]       │
├──────┼─────────────────────────────────────────┤
│性价比│ Doc3: TF=1, Pos=[2], Offset=[4-7]       │
├──────┼─────────────────────────────────────────┤
│ 高   │ Doc3: TF=1, Pos=[3], Offset=[7-8]       │
└──────┴─────────────────────────────────────────┘

说明：
TF = Term Frequency（词频）
Pos = Position（位置）
Offset = 字符偏移量
```

---

## 问题3：倒排索引如何实现快速搜索？

### 3.1 单词查询流程

```
查询："手机"

流程图：

┌─────────────┐
│ 1. 查询请求 │
│   "手机"    │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│ 2. 分词         │
│   "手机" → [手机]│
└──────┬──────────┘
       │
       ▼
┌─────────────────────┐
│ 3. 查找词典         │
│   在FST中查找"手机" │
└──────┬──────────────┘
       │
       ▼
┌──────────────────────────┐
│ 4. 获取倒排列表          │
│   [Doc1, Doc2, Doc3]     │
└──────┬───────────────────┘
       │
       ▼
┌──────────────────────────┐
│ 5. 计算评分              │
│   Doc1: score=1.5        │
│   Doc2: score=1.3        │
│   Doc3: score=1.2        │
└──────┬───────────────────┘
       │
       ▼
┌──────────────────────────┐
│ 6. 排序返回              │
│   [Doc1, Doc2, Doc3]     │
└──────────────────────────┘

时间复杂度：
- 查找词典：O(len(key)) - FST查找
- 获取倒排列表：O(1) - 直接读取
- 计算评分：O(m) - m为文档数
- 总计：O(len(key) + m)
```

### 3.2 多词查询流程（AND）

```
查询："苹果 手机"（AND操作）

流程图：

┌─────────────────┐
│ 1. 查询请求     │
│   "苹果 手机"   │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ 2. 分词         │
│   [苹果, 手机]  │
└──────┬──────────┘
       │
       ▼
┌──────────────────────────┐
│ 3. 查找词典              │
│   苹果 → [Doc1, Doc4]    │
│   手机 → [Doc1, Doc2, Doc3]│
└──────┬───────────────────┘
       │
       ▼
┌──────────────────────────┐
│ 4. 求交集（AND）         │
│   [Doc1, Doc4] ∩         │
│   [Doc1, Doc2, Doc3]     │
│   = [Doc1]               │
└──────┬───────────────────┘
       │
       ▼
┌──────────────────────────┐
│ 5. 计算评分              │
│   Doc1: score=2.8        │
└──────┬───────────────────┘
       │
       ▼
┌──────────────────────────┐
│ 6. 返回结果              │
│   [Doc1]                 │
└──────────────────────────┘

优化：Skip List（跳表）
- 倒排列表使用跳表存储
- 求交集时可以跳过不相关的文档
- 时间复杂度：O(m + n) → O(log(m) + log(n))
```

### 3.3 多词查询流程（OR）

```
查询："苹果 OR 华为"

流程图：

┌─────────────────┐
│ 1. 查询请求     │
│   "苹果 OR 华为"│
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ 2. 分词         │
│   [苹果, 华为]  │
└──────┬──────────┘
       │
       ▼
┌──────────────────────────┐
│ 3. 查找词典              │
│   苹果 → [Doc1, Doc4]    │
│   华为 → [Doc2]          │
└──────┬───────────────────┘
       │
       ▼
┌──────────────────────────┐
│ 4. 求并集（OR）          │
│   [Doc1, Doc4] ∪ [Doc2]  │
│   = [Doc1, Doc2, Doc4]   │
└──────┬───────────────────┘
       │
       ▼
┌──────────────────────────┐
│ 5. 计算评分              │
│   Doc1: score=1.5        │
│   Doc2: score=1.3        │
│   Doc4: score=1.2        │
└──────┬───────────────────┘
       │
       ▼
┌──────────────────────────┐
│ 6. 排序返回              │
│   [Doc1, Doc2, Doc4]     │
└──────────────────────────┘
```

### 3.4 短语查询流程

```
查询："苹果手机"（短语查询，要求连续）

流程图：

┌─────────────────┐
│ 1. 查询请求     │
│   "苹果手机"    │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ 2. 分词         │
│   [苹果, 手机]  │
└──────┬──────────┘
       │
       ▼
┌──────────────────────────────┐
│ 3. 查找词典（带位置信息）    │
│   苹果 → [Doc1: pos=0]       │
│   手机 → [Doc1: pos=1]       │
└──────┬───────────────────────┘
       │
       ▼
┌──────────────────────────────┐
│ 4. 检查位置是否连续          │
│   Doc1: 苹果(pos=0), 手机(pos=1)│
│   0和1连续 ✓                 │
└──────┬───────────────────────┘
       │
       ▼
┌──────────────────────────────┐
│ 5. 返回结果                  │
│   [Doc1]                     │
└──────────────────────────────┘

关键：位置信息（Position）
- 短语查询必须使用位置信息
- 检查词的位置是否连续
```

---

## 问题4：为什么要这样设计？不这样设计会有什么问题？

### 4.1 设计权衡：空间换时间

#### 空间成本

```
倒排索引的空间占用：

原始数据：
Doc1: "苹果手机很好用"（10字节）
Doc2: "华为手机也不错"（10字节）
Doc3: "小米手机性价比高"（12字节）
总计：32字节

倒排索引：
词典：约50字节
倒排列表：约100字节
位置信息：约50字节
总计：约200字节

空间放大：约6倍

结论：
- 倒排索引占用更多空间
- 但换来了极大的性能提升
- 这是值得的权衡
```

#### 时间收益

```
查询性能对比：

正排索引：
- 时间复杂度：O(n)
- 1000万文档：约10秒

倒排索引：
- 时间复杂度：O(1)
- 1000万文档：约10毫秒

性能提升：1000倍

结论：
- 空间增加6倍
- 性能提升1000倍
- 非常值得
```

### 4.2 为什么需要词频（TF）？

```
场景：计算相关性评分

不使用词频：
Doc1: "手机手机手机很好用"
Doc2: "手机很好用"
查询："手机"
结果：Doc1和Doc2评分相同 ❌

使用词频：
Doc1: TF=3
Doc2: TF=1
查询："手机"
结果：Doc1评分 > Doc2评分 ✓

结论：
- 词频反映了词的重要性
- 词频越高，相关性越高
- 必须存储词频
```

### 4.3 为什么需要位置信息？

```
场景：短语查询

不使用位置信息：
Doc1: "苹果手机很好用"
Doc2: "手机很好用，我喜欢苹果"
查询："苹果手机"（短语）
结果：Doc1和Doc2都匹配 ❌

使用位置信息：
Doc1: 苹果(pos=0), 手机(pos=1) → 连续 ✓
Doc2: 手机(pos=0), 苹果(pos=4) → 不连续 ✗
查询："苹果手机"
结果：只有Doc1匹配 ✓

结论：
- 位置信息支持短语查询
- 位置信息支持邻近查询
- 必须存储位置信息
```

### 4.4 为什么需要偏移量？

```
场景：高亮显示

不使用偏移量：
- 无法准确定位词在原文中的位置
- 无法实现高亮

使用偏移量：
原文："苹果手机很好用"
手机: offset=2-4
高亮：苹果<em>手机</em>很好用 ✓

结论：
- 偏移量支持高亮显示
- 偏移量支持摘要生成
- 必须存储偏移量
```

### 4.5 不这样设计会有什么问题？

```
问题1：不使用倒排索引
→ 性能极差，无法支撑大规模搜索

问题2：不存储词频
→ 无法计算相关性评分，搜索结果不准确

问题3：不存储位置信息
→ 无法支持短语查询，功能受限

问题4：不存储偏移量
→ 无法高亮显示，用户体验差

问题5：不优化词典（不使用FST）
→ 内存占用大，成本高

结论：
倒排索引的每个设计都是必要的
去掉任何一个都会导致功能或性能问题
```

---

## 问题5：倒排索引的优化技术有哪些？

### 5.1 FST（Finite State Transducer）

#### FST的作用

```
FST优化词典存储：

传统HashMap：
cat  → Posting List 1
cats → Posting List 2
dog  → Posting List 3
dogs → Posting List 4

内存占用：4个完整的字符串

FST（共享前缀和后缀）：
    c
    ├─ a
    │  └─ t → 1
    │     └─ s → 2
    d
    └─ o
       └─ g → 3
          └─ s → 4

内存占用：共享的字符 + 指针

节省：约50-70%
```

#### FST的优势

```
优势1：内存占用小
- 共享前缀和后缀
- 压缩存储

优势2：查找速度快
- 时间复杂度：O(len(key))
- 不依赖于词典大小

优势3：支持前缀查询
- 可以快速找到所有以"cat"开头的词
- 支持自动补全
```

### 5.2 Skip List（跳表）

#### Skip List的作用

```
Skip List优化倒排列表的合并：

场景：求交集
List1: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
List2: [2, 3, 6, 9, 12, 15, 18]

传统方法（双指针）：
- 需要比较：10 + 7 = 17次

Skip List方法：
List1: [1] → [5] → [9] → [13] → [17]
       ↓     ↓     ↓      ↓      ↓
      [1,3] [5,7] [9,11] [13,15] [17,19]

List2: [2] → [9] → [18]
       ↓     ↓     ↓
      [2,3,6] [9,12,15] [18]

查找过程：
1. 比较顶层：1 vs 2 → 跳到5
2. 比较顶层：5 vs 2 → 跳到9
3. 比较顶层：9 vs 9 → 匹配 ✓
4. 继续...

比较次数：约10次（减少40%）
```

#### Skip List的优势

```
优势1：加速合并
- 求交集时可以跳过不相关的文档
- 时间复杂度：O(m + n) → O(log m + log n)

优势2：加速查找
- 可以快速定位到特定文档
- 类似于二分查找

优势3：动态调整
- 可以动态添加跳跃指针
- 适应不同的查询模式
```

### 5.3 Frame of Reference（FOR）压缩

#### FOR压缩原理

```
FOR压缩倒排列表：

原始倒排列表：
[100, 105, 110, 115, 120, 125]

存储方式1（直接存储）：
每个数字4字节
总计：6 × 4 = 24字节

存储方式2（增量存储）：
[100, 5, 5, 5, 5, 5]
总计：6 × 4 = 24字节（没有节省）

存储方式3（FOR压缩）：
基准值：100
增量：[0, 5, 5, 5, 5, 5]
压缩：每个增量用1字节存储
总计：4（基准值）+ 6 × 1 = 10字节

节省：58%
```

#### FOR压缩的优势

```
优势1：节省空间
- 增量通常很小
- 可以用更少的位存储

优势2：解压速度快
- 简单的加法运算
- CPU友好

优势3：压缩率高
- 对于有序的ID列表效果很好
- 压缩率可达50-80%
```

### 5.4 Roaring Bitmap

#### Roaring Bitmap的作用

```
Roaring Bitmap优化文档ID列表：

场景：存储大量文档ID

传统方式（数组）：
[1, 3, 5, 7, 9, ..., 999999]
内存：1000000 × 4字节 = 4MB

Bitmap方式：
位图：1000000位 = 125KB
节省：97%

Roaring Bitmap（混合方式）：
- 稀疏区域：使用数组
- 密集区域：使用Bitmap
- 自动选择最优方式

内存：约50KB
节省：98.75%
```

#### Roaring Bitmap的优势

```
优势1：内存占用小
- 自适应压缩
- 比纯Bitmap更省空间

优势2：操作速度快
- 位运算（AND、OR、NOT）
- CPU指令优化

优势3：灵活性好
- 自动选择最优存储方式
- 适应不同的数据分布
```

### 5.5 优化技术总结

```
┌──────────────┬────────────┬──────────────┬──────────┐
│ 优化技术     │ 优化对象   │ 主要优势     │ 节省比例 │
├──────────────┼────────────┼──────────────┼──────────┤
│ FST          │ 词典       │ 内存占用小   │ 50-70%   │
│ Skip List    │ 倒排列表   │ 查询速度快   │ 40%      │
│ FOR压缩      │ 文档ID     │ 空间占用小   │ 50-80%   │
│ Roaring      │ 文档ID     │ 内存+速度    │ 95-99%   │
│ Bitmap       │            │              │          │
└──────────────┴────────────┴──────────────┴──────────┘
```

---

## 总结

### 倒排索引的核心思想

```
1. 提前建立"词 → 文档"的映射
2. 查询时直接查找，无需扫描
3. 空间换时间，性能提升1000倍
```

### 倒排索引的组成

```
1. 词典（Term Dictionary）
   - 存储所有词
   - 使用FST优化

2. 倒排列表（Posting List）
   - 文档ID列表
   - 词频（TF）
   - 位置信息（Position）
   - 偏移量（Offset）
```

### 关键设计思想

```
1. 空间换时间
   - 空间增加6倍
   - 性能提升1000倍

2. 信息完整性
   - 存储词频：支持相关性评分
   - 存储位置：支持短语查询
   - 存储偏移：支持高亮显示

3. 持续优化
   - FST：优化词典
   - Skip List：优化查询
   - FOR压缩：优化存储
   - Roaring Bitmap：优化ID列表
```

### 为什么ES这么快？

```
1. 倒排索引：O(1)查找
2. FST：内存占用小，查找快
3. Skip List：加速合并
4. 压缩技术：节省空间，提升IO
5. 分布式：并行搜索
```

---

**下一步**：深入理解分词器与文本分析

**相关文档**：
- [04-分词器与文本分析.md](./04-分词器与文本分析.md)
- [05-搜索与查询原理.md](./05-搜索与查询原理.md)
