# 02-Elasticsearch核心概念与架构

## 引言

理解了为什么需要Elasticsearch后，接下来我们要深入理解：**ES是如何工作的？它的核心概念和架构是什么样的？**

本文将通过问题驱动的方式，带你全面掌握ES的核心概念和整体架构。

---

## 问题1：ES的核心概念有哪些？

### 1.1 核心概念对比

ES的核心概念与传统关系型数据库的对应关系：

| Elasticsearch | 关系型数据库 | 说明 |
|---------------|-------------|------|
| Index（索引） | Database（数据库） | 数据的逻辑分组 |
| Type（类型）❌ | Table（表） | ES 7.0+已废弃 |
| Document（文档） | Row（行） | 一条数据记录 |
| Field（字段） | Column（列） | 数据的属性 |
| Mapping（映射） | Schema（表结构） | 字段定义 |
| Shard（分片） | Partition（分区） | 数据的物理分片 |
| Replica（副本） | Replication（备份） | 数据的冗余备份 |

**注意**：这个对比只是帮助理解，ES和关系型数据库的设计理念完全不同。

### 1.2 Index（索引）

#### 什么是Index？

Index是ES中数据的逻辑分组，类似于关系型数据库中的Database。

```
示例：
- products（商品索引）
- users（用户索引）
- orders（订单索引）
- logs-2024-01（日志索引）
```

#### Index的特点

1. **独立的命名空间**：每个Index有自己的Mapping和Settings
2. **可以跨Index搜索**：支持同时搜索多个Index
3. **支持别名**：一个别名可以指向多个Index

#### Index命名规范

```
规范：
✅ 小写字母
✅ 数字
✅ 下划线、连字符
❌ 大写字母
❌ 特殊字符（除了-和_）
❌ 以-、_、+开头

示例：
✅ products
✅ user_profiles
✅ logs-2024-01
❌ Products（大写）
❌ user.profiles（点号）
```

### 1.3 Document（文档）

#### 什么是Document？

Document是ES中的基本数据单元，类似于关系型数据库中的一行记录。Document以JSON格式存储。

```json
{
  "_index": "products",
  "_id": "1",
  "_source": {
    "name": "iPhone 14 Pro",
    "brand": "Apple",
    "price": 7999,
    "category": "手机",
    "tags": ["5G", "拍照", "高端"],
    "created_at": "2024-01-20T10:00:00Z"
  }
}
```

#### Document的元数据

每个Document都有以下元数据：

| 元数据 | 说明 | 示例 |
|--------|------|------|
| `_index` | 所属索引 | "products" |
| `_id` | 文档唯一标识 | "1" |
| `_source` | 原始JSON数据 | {...} |
| `_version` | 版本号（乐观锁） | 1 |
| `_score` | 相关性评分 | 1.5 |
| `_seq_no` | 序列号 | 0 |
| `_primary_term` | 主分片任期 | 1 |

#### Document ID

Document ID有两种生成方式：

```json
// 方式1：手动指定ID
PUT /products/_doc/1
{
  "name": "iPhone 14 Pro"
}

// 方式2：自动生成ID（UUID）
POST /products/_doc
{
  "name": "iPhone 14 Pro"
}
// 返回：_id = "A1B2C3D4E5F6"
```

### 1.4 Field（字段）

#### 什么是Field？

Field是Document中的一个属性，类似于关系型数据库中的列。

```json
{
  "name": "iPhone 14 Pro",      // 文本字段
  "price": 7999,                // 数值字段
  "in_stock": true,             // 布尔字段
  "tags": ["5G", "拍照"],       // 数组字段
  "specs": {                    // 对象字段
    "screen": "6.1英寸",
    "memory": "256GB"
  },
  "created_at": "2024-01-20"    // 日期字段
}
```

#### Field的数据类型

ES支持丰富的数据类型：

| 类型分类 | 具体类型 | 说明 |
|---------|---------|------|
| 文本类型 | text | 全文搜索，会分词 |
| | keyword | 精确匹配，不分词 |
| 数值类型 | long, integer, short, byte | 整数 |
| | double, float | 浮点数 |
| 日期类型 | date | 日期时间 |
| 布尔类型 | boolean | true/false |
| 二进制类型 | binary | Base64编码的二进制 |
| 范围类型 | integer_range, date_range | 范围值 |
| 复杂类型 | object | 嵌套对象 |
| | nested | 嵌套文档 |
| 地理类型 | geo_point | 地理坐标点 |
| | geo_shape | 地理形状 |

### 1.5 Mapping（映射）

#### 什么是Mapping？

Mapping定义了Index中Document的结构，类似于关系型数据库的表结构（Schema）。

```json
{
  "mappings": {
    "properties": {
      "name": {
        "type": "text",
        "analyzer": "ik_max_word",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "price": {
        "type": "double"
      },
      "category": {
        "type": "keyword"
      },
      "tags": {
        "type": "keyword"
      },
      "created_at": {
        "type": "date",
        "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"
      }
    }
  }
}
```

#### 动态Mapping vs 静态Mapping

**动态Mapping**：

```
特点：
- ES自动推断字段类型
- 无需手动定义Mapping
- 灵活但可能不精确

示例：
插入 {"name": "iPhone"} 
→ ES推断 name 为 text 类型

风险：
- 可能推断错误（如数字被识别为text）
- 字段爆炸（动态添加大量字段）
```

**静态Mapping**：

```
特点：
- 手动定义字段类型
- 精确控制
- 推荐生产环境使用

示例：
先定义Mapping，再插入数据

优势：
- 类型精确
- 可控性强
- 性能更好
```

### 1.6 Shard（分片）

#### 什么是Shard？

Shard是Index数据的物理分片，是ES实现分布式的基础。

```
概念：
一个Index可以分成多个Shard
每个Shard是一个独立的Lucene索引
Shard分为主分片（Primary Shard）和副本分片（Replica Shard）

示例：
Index: products
├─ Primary Shard 0（主分片0）
├─ Primary Shard 1（主分片1）
├─ Primary Shard 2（主分片2）
├─ Replica Shard 0（副本分片0）
├─ Replica Shard 1（副本分片1）
└─ Replica Shard 2（副本分片2）
```

#### 主分片（Primary Shard）

```
特点：
- 每个Document只存在于一个主分片
- 主分片数量在创建Index时指定，之后不能修改
- 默认值：ES 7.0+ 为 1个主分片

为什么不能修改？
- 路由算法：shard = hash(_id) % number_of_primary_shards
- 修改主分片数会导致路由失效，数据找不到
```

#### 副本分片（Replica Shard）

```
特点：
- 主分片的完整拷贝
- 提供数据冗余和高可用
- 可以动态修改数量
- 默认值：1个副本

作用：
1. 高可用：主分片故障时，副本可以提升为主分片
2. 读性能：副本可以分担读请求
```

#### Shard数量规划

```
主分片数量建议：
- 小数据量（< 10GB）：1个主分片
- 中等数据量（10GB - 100GB）：3-5个主分片
- 大数据量（> 100GB）：根据数据量和节点数规划

副本数量建议：
- 开发环境：0个副本
- 测试环境：1个副本
- 生产环境：1-2个副本

计算公式：
总Shard数 = 主分片数 × (1 + 副本数)
建议：总Shard数 ≤ 节点数 × 20
```

### 1.7 Replica（副本）

#### 副本的分布原则

```
原则：
1. 副本分片不会和对应的主分片在同一个节点
2. 尽量均匀分布在不同节点

示例：
3个节点，3个主分片，1个副本

节点1：P0, R1, R2
节点2：P1, R0, R2
节点3：P2, R0, R1

说明：
P0 = Primary Shard 0
R0 = Replica Shard 0
```

#### 副本的作用

```
作用1：高可用
- 节点故障时，副本可以提升为主分片
- 保证数据不丢失

作用2：提升读性能
- 搜索请求可以路由到副本
- 分担主分片的读压力

作用3：负载均衡
- 多个副本可以并行处理请求
```

### 1.8 核心概念总结

```
层次结构：

Cluster（集群）
  ├─ Node 1（节点1）
  │   ├─ Index: products
  │   │   ├─ Primary Shard 0
  │   │   └─ Replica Shard 1
  │   └─ Index: users
  │       └─ Primary Shard 0
  ├─ Node 2（节点2）
  │   ├─ Index: products
  │   │   ├─ Primary Shard 1
  │   │   └─ Replica Shard 0
  │   └─ Index: users
  │       └─ Replica Shard 0
  └─ Node 3（节点3）
      └─ Index: products
          └─ Primary Shard 2
```

---

## 问题2：ES的整体架构是什么样的？

### 2.1 ES集群架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      Elasticsearch集群                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  Master Node │  │  Master Node │  │  Master Node │      │
│  │  (候选节点1)  │  │  (候选节点2)  │  │  (当选主节点) │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         │                  │                  │             │
│         └──────────────────┴──────────────────┘             │
│                      集群状态管理                            │
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  Data Node 1 │  │  Data Node 2 │  │  Data Node 3 │      │
│  │              │  │              │  │              │      │
│  │  ┌────┐┌────┐│  │  ┌────┐┌────┐│  │  ┌────┐┌────┐│      │
│  │  │ P0 ││ R1 ││  │  │ P1 ││ R2 ││  │  │ P2 ││ R0 ││      │
│  │  └────┘└────┘│  │  └────┘└────┘│  │  └────┘└────┘│      │
│  │  ┌────┐      │  │  ┌────┐      │  │  ┌────┐      │      │
│  │  │ R2 │      │  │  │ R0 │      │  │  │ R1 │      │      │
│  │  └────┘      │  │  └────┘      │  │  └────┘      │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         │                  │                  │             │
│         └──────────────────┴──────────────────┘             │
│                      数据存储与搜索                          │
│                                                              │
│  ┌──────────────┐  ┌──────────────┐                         │
│  │Coordinating  │  │Coordinating  │                         │
│  │   Node 1     │  │   Node 2     │                         │
│  │ (协调节点)    │  │ (协调节点)    │                         │
│  └──────────────┘  └──────────────┘                         │
│         │                  │                                │
│         └──────────────────┘                                │
│              请求路由与结果聚合                               │
│                                                              │
│  ┌──────────────┐                                           │
│  │ Ingest Node  │                                           │
│  │ (预处理节点)  │                                           │
│  └──────────────┘                                           │
│         │                                                   │
│    数据预处理                                                │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 节点类型详解

#### 2.2.1 Master Node（主节点）

**职责**：
- 管理集群状态
- 创建/删除索引
- 分配分片
- 维护集群元数据

**配置**：
```yaml
node.master: true
node.data: false
node.ingest: false
```

**特点**：
- 轻量级操作，不存储数据
- 建议：3个Master候选节点（奇数个，避免脑裂）
- 通过选举产生一个Active Master

#### 2.2.2 Data Node（数据节点）

**职责**：
- 存储数据
- 执行搜索查询
- 执行聚合操作
- 执行CRUD操作

**配置**：
```yaml
node.master: false
node.data: true
node.ingest: false
```

**特点**：
- 重量级操作，需要大量CPU、内存、磁盘
- 建议：根据数据量和查询量配置

#### 2.2.3 Coordinating Node（协调节点）

**职责**：
- 接收客户端请求
- 将请求路由到相关的Data Node
- 聚合各Data Node的结果
- 返回最终结果给客户端

**配置**：
```yaml
node.master: false
node.data: false
node.ingest: false
```

**特点**：
- 所有节点默认都是协调节点
- 可以配置专用协调节点（大集群）
- 类似于负载均衡器

#### 2.2.4 Ingest Node（预处理节点）

**职责**：
- 在数据索引前进行预处理
- 执行Pipeline操作（如字段转换、数据清洗）

**配置**：
```yaml
node.master: false
node.data: false
node.ingest: true
```

**特点**：
- 可选节点类型
- 适用于需要数据预处理的场景

### 2.3 为什么要分这么多节点类型？

#### 原因1：职责分离

```
传统方式（所有节点都做所有事）：
问题：
- 资源竞争（搜索和管理抢CPU）
- 性能不稳定
- 难以优化

ES方式（职责分离）：
优势：
- Master专注集群管理
- Data专注数据存储和搜索
- Coordinating专注请求路由
- 各司其职，性能稳定
```

#### 原因2：资源优化

```
不同节点类型的资源需求：

Master Node：
- CPU：低
- 内存：中
- 磁盘：低
- 网络：中

Data Node：
- CPU：高
- 内存：高
- 磁盘：高
- 网络：高

Coordinating Node：
- CPU：中
- 内存：中
- 磁盘：低
- 网络：高
```

#### 原因3：可扩展性

```
场景1：查询量大，数据量小
解决：增加Coordinating Node

场景2：数据量大，查询量小
解决：增加Data Node

场景3：集群规模大
解决：增加Master候选节点
```

### 2.4 典型集群架构

#### 小型集群（< 10个节点）

```
架构：
- 3个节点
- 每个节点都是Master候选 + Data节点

配置：
node.master: true
node.data: true

优点：
- 简单
- 资源利用率高

缺点：
- 职责不分离
- 扩展性有限
```

#### 中型集群（10-50个节点）

```
架构：
- 3个Master候选节点
- 10-20个Data节点
- 2-3个Coordinating节点

配置：
Master节点：
  node.master: true
  node.data: false

Data节点：
  node.master: false
  node.data: true

Coordinating节点：
  node.master: false
  node.data: false

优点：
- 职责分离
- 性能稳定
- 易于扩展
```

#### 大型集群（> 50个节点）

```
架构：
- 3个专用Master节点
- 50+个Data节点
- 5-10个Coordinating节点
- 若干Ingest节点（按需）

优点：
- 高性能
- 高可用
- 灵活扩展
```

---

## 问题3：ES如何实现分布式？

### 3.1 数据分片机制

#### 分片的目的

```
目的1：水平扩展
- 单机存储有限
- 通过分片将数据分散到多个节点
- 突破单机限制

目的2：并行处理
- 多个分片可以并行搜索
- 提升查询性能

目的3：负载均衡
- 请求分散到多个节点
- 避免单点压力过大
```

#### 分片分配策略

```
ES的分片分配原则：

1. 均衡性
   - 每个节点的分片数量尽量相等
   - 避免某个节点负载过重

2. 高可用
   - 主分片和副本分片不在同一节点
   - 节点故障时数据不丢失

3. 本地性
   - 尽量将相关数据放在同一节点
   - 减少跨节点通信
```

### 3.2 副本机制

#### 副本的同步方式

```
写入流程：
1. 客户端发送写入请求到协调节点
2. 协调节点路由到主分片所在节点
3. 主分片写入数据
4. 主分片将数据同步到所有副本分片
5. 所有副本写入成功后，返回成功响应

同步策略：
- 默认：等待所有副本写入成功（强一致性）
- 可配置：等待部分副本（性能优先）
```

### 3.3 路由机制

#### 路由算法

```
路由公式：
shard = hash(_routing) % number_of_primary_shards

默认情况：
_routing = _id（文档ID）

示例：
文档ID = "product_123"
主分片数 = 3

计算：
shard = hash("product_123") % 3
     = 1234567890 % 3
     = 0

结果：文档存储在主分片0
```

#### 自定义路由

```json
// 使用自定义路由字段
PUT /products/_doc/1?routing=user_123
{
  "name": "iPhone 14 Pro",
  "user_id": "user_123"
}

// 查询时也要指定相同的routing
GET /products/_doc/1?routing=user_123

优势：
- 将同一用户的数据放在同一分片
- 查询时只需查询一个分片
- 提升查询性能
```

### 3.4 分布式架构流程图

#### 数据写入流程

```
┌─────────┐
│ Client  │
└────┬────┘
     │ 1. 写入请求
     ▼
┌─────────────────┐
│ Coordinating    │
│ Node            │
│ (协调节点)       │
└────┬────────────┘
     │ 2. 计算路由，找到主分片
     ▼
┌─────────────────┐
│ Data Node 1     │
│ ┌─────────────┐ │
│ │Primary Shard│ │ 3. 写入主分片
│ │     0       │ │
│ └─────────────┘ │
└────┬────────────┘
     │ 4. 同步到副本
     ├──────────────┐
     ▼              ▼
┌─────────────┐ ┌─────────────┐
│Data Node 2  │ │Data Node 3  │
│┌───────────┐│ │┌───────────┐│
││Replica    ││ ││Replica    ││
││Shard 0    ││ ││Shard 0    ││
│└───────────┘│ │└───────────┘│
└─────────────┘ └─────────────┘
     │              │
     └──────┬───────┘
            │ 5. 所有副本写入成功
            ▼
     ┌─────────────┐
     │ Client      │
     │ (返回成功)   │
     └─────────────┘
```

#### 数据读取流程

```
┌─────────┐
│ Client  │
└────┬────┘
     │ 1. 查询请求
     ▼
┌─────────────────┐
│ Coordinating    │
│ Node            │
│ (协调节点)       │
└────┬────────────┘
     │ 2. 广播到所有相关分片
     ├──────────────┬──────────────┐
     ▼              ▼              ▼
┌─────────┐    ┌─────────┐    ┌─────────┐
│ Shard 0 │    │ Shard 1 │    │ Shard 2 │
│(主或副本)│    │(主或副本)│    │(主或副本)│
└────┬────┘    └────┬────┘    └────┬────┘
     │              │              │
     │ 3. 各分片并行搜索，返回Top N
     └──────┬───────┴──────────────┘
            ▼
     ┌─────────────┐
     │Coordinating │
     │    Node     │
     │ 4. 合并结果 │
     │ 5. 排序     │
     │ 6. 返回Top N│
     └──────┬──────┘
            ▼
     ┌─────────┐
     │ Client  │
     └─────────┘
```

---

## 问题4：ES的核心组件有哪些？

### 4.1 Lucene（底层搜索库）

```
Lucene是什么？
- Apache开源的全文搜索库
- ES的底层基础
- 每个Shard就是一个Lucene索引

Lucene的核心功能：
1. 倒排索引
2. 分词
3. 评分
4. 排序

ES在Lucene之上的增强：
1. 分布式架构
2. RESTful API
3. 自动分片和副本
4. 集群管理
5. 实时搜索
```

### 4.2 Gateway（持久化）

```
Gateway的作用：
- 将集群状态持久化到磁盘
- 节点重启后恢复集群状态

持久化内容：
1. 集群元数据
2. 索引Mapping
3. 索引Settings
4. 分片分配信息

持久化位置：
- 默认：每个Data节点的data目录
- 路径：path.data配置
```

### 4.3 Discovery（节点发现）

```
Discovery的作用：
- 节点之间相互发现
- 组成集群
- 选举Master节点

发现机制：
1. Zen Discovery（ES 7.0之前）
   - 基于Ping/Pong
   - 多播或单播

2. Raft协议（ES 7.0+）
   - 更可靠的选举机制
   - 避免脑裂

配置示例：
discovery.seed_hosts: ["node1:9300", "node2:9300", "node3:9300"]
cluster.initial_master_nodes: ["node1", "node2", "node3"]
```

### 4.4 Transport（节点通信）

```
Transport的作用：
- 节点之间的通信
- 数据传输
- 集群状态同步

通信端口：
- HTTP端口：9200（客户端通信）
- Transport端口：9300（节点间通信）

通信协议：
- 基于TCP
- 二进制协议（高效）
```

---

## 总结

### 核心概念回顾

```
1. Index：数据的逻辑分组
2. Document：基本数据单元（JSON）
3. Field：文档的属性
4. Mapping：字段定义
5. Shard：数据的物理分片
6. Replica：分片的副本
```

### 架构特点

```
1. 分布式原生设计
2. 职责分离（Master、Data、Coordinating）
3. 水平扩展能力
4. 高可用保证
5. 基于Lucene的强大搜索能力
```

### 关键设计思想

```
1. 分片机制：实现分布式存储和并行搜索
2. 副本机制：保证高可用和读性能
3. 路由机制：快速定位数据
4. 节点分类：职责分离，资源优化
```

---

**下一步**：深入理解倒排索引原理

**相关文档**：
- [03-倒排索引原理深度剖析.md](./03-倒排索引原理深度剖析.md)
- [06-分布式架构与数据分片.md](./06-分布式架构与数据分片.md)
